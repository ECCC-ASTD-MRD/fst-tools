
***s/p scalair  interpolation horizontale d un champ
*               defini par l usager
*     
      subroutine scalair(cnom,  iheur, nniv, niveaux)
#include "impnone.cdk"
#include "defin.cdk"
      external ecritur,pgsmluk,fstinf,fstsui,memoir,fstprm,qaaqr,fstcvt,
     $     fstsel,symetri,imprime,itrouve,messags,pgsmabt
      external cvtr2i
      external liraxez
      integer  pgsmluk, fstinf, fstsui, fstprm, fstcvt, fstsel, fstinl
      integer diesinf, dieslir,diesisincache,res
      integer ezgdef_fmem, ezqkdef, ezsint, ezdefset
      logical skip
*     
*auteur  p. sarrazin  dorval quebec fevrier 82 drpn
*revision 4.0.2
*   conversion des variables hollerith en caractere
*   y. chartier -aout 90- drpn dorval quebec
*revision 5.0.0
*   utilisation de la cuvee 91 des interpolateurs
*   elimination des appels a 'fstcvt' pour convertir etikent
*   y. chartier -mai 1991- drpn dorval quebec
*
*revision 5.2.1
*   utilisation de fstinl au lieu de fstinf-fstsui
*   l'utilisation des deux dernieres avec les grilles Z
*   causait un probleme lorsqu'on lisait les axes
*   y. chartier -oct. 92- drpn dorval quebec
*langage ratfor
*
*objet(scalair)
*              interpolation horizontale des scalaires gz,tt,dd,ww,qq,es.
*              d une grille a une autre pour nniv niveaux
*              ecrire resultat sur fichier standard,ms,sequentiel
*
*librairies
*         -source  armnsrc,drpn
*         -objet   pgsmlib,id=armnpjs.
*
*arguments
*  in   nom    nom du champ 2 caracteres gz.tt.dd.......
*  in   iheur  heure de la variable sur fichier d entre
*  in   nniv   nombre de niveaux
*  in   niveaux table contenant nniv niveaux
*
*appel
*         -via routine champ
*         call scalair(nom, iheur, nniv, niveaux) 
*
*messages 
*         mauvaise directive champ (scalair)
*         aucun niveau specifie dans directive champ
*         record n'existe pas sur fichier d'entre (scalair) 
*         aucune interpolation horizontale champ
*
*
*modules pgsmabt,rfl,fstinf,fstprm,pgsmlir,rgscint,ecritur
*
*-----------------------------------------------------------------
*
#include "llccmm.cdk"
#include "dummys.cdk"
#include "dates.cdk"
#include "grilles.cdk"
#include "indptr.cdk"
#include "lires.cdk"
#include "accum.cdk"
#include "ecrires.cdk"
#include "pairs.cdk"
#include "voir.cdk"
#include "packin.cdk"
#include "gdz.cdk"

      character *12 cetiket
      character *4 cnom,cnomvar,cnomx
      character *2 ctypvar
      character *1 cigtyp
      
      integer nniv,dat,i,nunv,itrouve,key,ii
      integer niveaux(nniv),deet,ig1,ig2,ig3,ig4,iheur
      integer iprs,irec,iunit,jp1,jp2,jp3,ne,ni,nj,nk
      integer cnbits,cdatyp,cswa,clng,cdltf,cubc,extra1,extra2,extra3
      logical sym,symetri
      real fbidon
      real, dimension(:), allocatable :: ax, ay

      real, dimension(:), pointer :: tmpout
*
      integer liste(24000),nrecs
      nunv=0 
*
*


      iunit=1
      cnomx = cnom
      if (cnom.eq.cnomqr) cnom=cnomqq
      
*     
*     
      do iprs = 1,nniv 
*
*  conversion de l etiquette d'entree en caracteres
*
        
        if (etikent(1) .ne. -1) then
          write(cetiket,'(3A4)') (etikent(i), i=1,nwetike)
        else 
          cetiket = '            '
        endif
        
        if (typeent .ne. -1) then
          write(ctypvar, '(A2)') typeent
        else 
          ctypvar = '  ' 
        endif
        
*     identifier numero du record
*
        if (cnom.eq.cnommt) then
          if (.not.mtdone) then
            irec = fstinl(iunit,ni,nj,nk,-1,'            ',-1,-1,-1,'  ',cnom,
     $           liste,nrecs,24000) 
            if (nrecs .eq. 0) then
              if (message) then
                write(6,*)
     $               'RECORD FICHIER DE MONTAGNE PAS LA (SCALAIR)'
              endif
              go to 5000
            endif
            
            
            if (nk.gt.1) then
              write(6,*)'******************************************'
              write(6,*)'       PGSM N ACCEPTE PAS UN          '
              write(6,*)' CHAMP DE 3 DIMENSIONS NK>1 ?? 
     $             (MT DANS SCALAIR)'
              write(6,*)'*****************************************'
              call pgsmabt
            endif
 5000       mtdone=.true.
          endif
        else
         if (date .eq. 1) then
            if (date3.eq.-1) then
               date=date2
            else
               call newdate(date, date2, date3, 3)
            endif
         endif

          irec=fstinl(iunit,ni,nj,nk,date,cetiket,niveaux(iprs),iheur,
     $         ip3ent,ctypvar,cnom, liste, nrecs, 24000)
          
          if (nrecs .eq. 24000) then
            print *, 
     $           'LA LIMITE DE 24000 ENREGISTREMENTS A ETE ATTEINTE'
            print 
     $           *, 'CONSULTER LE RESPONSABLE DU PROGRAMME'
          endif
          
          if (nrecs .eq. 0) then
            if (message) then
              write(6,*)
     $             'RECORD N EXISTE PAS SUR FICHIER D ENTRE (SCALAIR)'
            endif
            goto 22000
          endif
          
          if (nk.gt.1) then
            write(6,*)
     $           '************************************************'
            write(6,*)'         PGSM N ACCEPTE PAS UN          ' 
            write(6,*)
     $           ' CHAMP DE 3 DIMENSIONS NK>1 ?? (CHAMP SCALAIR)'
            write(6,*)
     $           '************************************************'
            call pgsmabt 
          endif
        endif
*     
*     
        do ii=1,nrecs
*     
*     identifier parametres
          irec = liste(ii)
          ier=fstprm(irec, dat,deet,npas,ni, nj, nk, cnbits,cdatyp,
     $         jp1,jp2,jp3,ctypvar,cnomvar,cetiket,
     $         cigtyp,ig1,ig2, ig3, ig4, cswa, clng, cdltf, cubc, 
     $         extra1, extra2, extra3)
          if (ier .lt. 0) write(6,*)
     $         ' IER = FSTPRM NEGATIF VOIR SCALAIR'

          if (cnomvar(1:2).eq.'>>'.or.cnomvar(1:2).eq.'^^'.or.cnomvar(1:2).eq.'HY') then
             goto 99999
          endif

*     
*   si la directive de champ emploi tout  champ(tout,tout) on doit faire
*     attention pour les vecteurs u-v car l'interpolation serait scalair
*     on verifie et les interpolations pour les vecteurs ne sont pas
C faite
*     
          do i=1,npair 
             if (cnom.eq.'    ') then
                if ((paire(i)(9:10).eq.cnomvar(1:2)).or.
     $               (paire(i)(13:14).eq.cnomvar(1:2)))  then
                   nunv=nunv + 1
                   go to 99999
              endif
            endif
          enddo
*     
*     lire champ
          
          skip = .false.
          
          if (cigtyp.eq.'#'.and.diese.eq.1) then
	     res = diesisincache(irec)
	     if (res.lt.0) then
                ier = diesinf(irec, iunit, ni, nj, nk, date, cetiket, jp1, jp2, jp3, ig1, ig2, ctypvar, cnomvar)
                allocate(tmpif1(ni*nj))
                allocate(ax(ni))
                allocate(ay(nj))
                ier = dieslir(iunit, irec, tmpif1, ax, ay, grref, ig1ref, ig2ref, ig3ref, ig4ref)
             else
                skip = .true.
             endif
          else
             allocate(tmpif1(ni*nj))
             key = pgsmluk(tmpif1, irec, ni,nj,nk,cnomvar,cigtyp)
          endif
          
*     
          if (cdatyp .eq. 2 .or. cdatyp .eq. 4) then
             call cvtr2i(tmpif1, tmpif1, ni, nj)
          endif
          
          if (printen)  call imprime(cnomvar,tmpif1,ni,nj)
          if (ig1.ne.0) sym = symetri(cnomvar)
*     
*     on ne fait pas d'interpolation si igtyp=grtyp  ig1=lg1  ig2=lg2
*     ig3=lg3  ig4=lg4
*     
          if (.not.skip) then
             if (cigtyp.ne.cgrtyp.or.cigtyp.eq.'Z'.or.
     $            ig1.ne.lg1.or.ig2.ne.lg2.or.ig3.ne.lg3.or.
     $            ig4.ne.lg4.or.li.ne.ni.or.lj.ne.nj) then
*     
*     interpolation
*     
                allocate(tmpif2(li*lj))
                
                if (cigtyp.eq.'#'.and.diese.eq.0) then
                   gdin = ezgdef_fmem(ni, nj, 'Z', grref, ig1ref, ig2ref, ig3ref, ig4ref, ax, ay)
                else
                   gdin = ezqkdef(ni, nj, cigtyp, ig1, ig2, ig3, ig4, iunit)
                endif
                ier = ezdefset(gdout, gdin)
                ier = ezsint(tmpif2, tmpif1)
                tmpout => tmpif2
             else
                tmpout => tmpif1
                if (message) write(6,660) cnom
 660            format(2x,'AUCUNE INTERPOLATION HORIZONTALE CHAMP=',a2)
             endif
*     
*     
*     ecrire sur fichier approprie(std,ms,seq)
*     
             if (cnomx.eq.cnomqr) then
                call qaaqr(tmpif2,li,lj,tmplat)
                cnomvar=cnomqr
             endif
             
             call ecritur(tmpout,npack,dat,deet,npas,li,lj,nk,jp1,jp2,
     $            jp3,ctypvar,cnomvar,cetiket,cgrtyp,lg1,lg2,lg3,lg4)
*     
             if (associated(tmpif2)) then
                deallocate(tmpif2)
             endif
             deallocate(tmpif1)
*     
          endif
99999     continue
*     
          if (unefois) goto 23000
*     
       enddo
22000 enddo
23000 continue
*     
      if (nunv.gt.0) then
         write(6,666)
 666     format(' AUCUNE INTERPOLATION SUR VARIABLE PAIRE CHAMP(TOUT,TOUT)')
         write(6,668)
 668     format(' ON DOIT UTILISER LE NOM DE LA VARIABLE EX: CHAMP(UU,TOUT)')
         write(6,669)
 669     format(' ATTENTION L INTERPOLATION DES VECTEURS SERA SCALAIRE (!!!)')
*     
      endif
      return 
      end
      
      
      subroutine cvtr2i(rfld, ifld, ni, nj)
      integer ni, nj
      real rfld(ni,nj)
      integer ifld(ni,nj)
      integer i
      
      do j=1,nj
         do i=1,ni
            rfld(i,j) = real(ifld(i,j))
         enddo
      enddo
      
      return
      end 
      
      
