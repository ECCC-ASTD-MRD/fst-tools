*     
***S/P CALCUL  MOYENNE ZONALE OU MERIDIONALE D UN CHAMP
*     
      subroutine calcul(entre, sortie, ni, nj, poids, ccoupe, cigtyp)
#include "impnone.cdk"
*
*AUTEUR 
*    P. SARRAZIN  DORVAL QUEBEC AVRIL 85 DRPN 
*REVISION 4.0.2
*   CONVERSION DES VARIABLES HOLLERITH EN CARACTERE
*   Y. CHARTIER AOUT 90 DRPN DORVAL QUEBEC. 
*
*LANGAGE RATFOR
*
*OBJET(CALCUL)
*            CALCUL MOYENNE ZONALE OU MERIDIONALE 
*            LA MOYENNE ZONALE(EST-OUEST) CONTIENT NJ POINTS
*            LA MOYENNE MERIDIONALE(NORD-SUD) CONTIENT NI POINTS
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*ARGUMENTS
*  IN   ENTRE  -CHAMP(NI,NJ) LUT PAR COUPZM ROUTINE
*  IN   SORTIE -CHAMP(NI) MERIDIONAL  CHAMP(NJ) ZONALE
*               CONTENANT MOYENNE ZONALE OU MERIDIONALE
*  IN   NI     -DIMENSION DU CHAMP ENTRE EST-OUEST
*  IN   NJ     -DIMENSION DU CHAMP ENTRE NORD-SUD 
*  IN   POIDS  -UTILISE POUR LE CALCUL DE LA MOYENNE MERIDIONALE D UN 
*               CHAMP GAUSSIEN MAX NJ
*  IN   JCOUP  -COUPE ZONALE JCOUP="ZON"
*               COUPE MERIDIONALE JCOUP="MER"
*  IN   IGTYP  -TYPE DE GRILLE SI IGTYP="B" ELIMINER DERNIERE LONG
*
*APPEL
*         -VIA ROUTINE COUPZM 
*          CALL CALCUL(ENTRE, SORTIE, NI, NJ, POIDS, JCOUP, IGTYP)
*
*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
#include "voir.cdk"
*
      integer i,ni,j,nj,nii
*
      real entre(ni,nj),sortie(1),poids(1),sum,sump
      character ccoupe*8, cigtyp*1
*
*     SI COUPE MERIDIONALE
*     
      if (ccoupe.eq.'MER') then
*
         do i=1,ni  
            sum=0.0
            sump=0.0
            do j=1,nj  
               sum=sum + entre(i,j)*poids(j)
               sump = sump + poids(j)
               sortie(i)=sum/sump
            enddo
         enddo
*
*   COUPE ZONALE
*
      else
         nii=ni
*     
*     SI IGTYP='B' ON ELIMINE LA DERNIERE LONGITUDE 
*     
         if (cigtyp.eq.'B') then
            nii=ni-1
         endif
*     
         do j=1,nj  
            sum=0.0
            do i=1,nii
               sum=sum + entre(i,j)
*     
               sortie(j)=sum/nii
            enddo
         enddo
      endif
      return
      end
      
*
***S/P ECRITS   ECRIRE SUR FICHIER STANDARD, MS, SEQUENTIEL 
*
      subroutine ecrits(nom,npac,idat,ip1,ip2,ip3,type,
     $     etiqet,igtyp,imprim,ig1srt,ig2srt,ig3srt,ig4srt) 
#include "impnone.cdk"
      external conver,fstecr,fclos,memoir,pgsmabt,
     $     imprims,fstopc,messags,fstcvt,putfld
      integer fstecr,fstopc,fstcvt,iopc
*
*AUTEUR  P.SARRAZIN  AOUT 82  DRPN DORVAL P.Q. CANADA
*
*LANGAGE RATFOR
*
*OBJET(ECRITS)
*          ECRIRE SUR FICHIER STANDARD AVEC ROUTINE ECRIRE
*          ECRIRE SUR FICHIER MS AVEC PUTFLD
*          ECRIRE SUR FICHIER SEQUENTIEL AVEC PUTFLD
*
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*ARGUMENTS
*   IN    NOM     NOM DU CHAMP 2 CARACTERES
*   IN    NPAC    COMPACTION DU DATA DANS CHAMP
*   IN    IDAT    DATE DU CHAMP (CMC STAMP)
*   IN    IP1     NORMALEMENT NIVEAU DU CHAMP
*   IN    IP2     HEURE DU CHAMP
*   IN    IP3     LIBRE
*   IN    TYPV    TYPE DU CHAMP 1 CARACTERE
*   IN    ETIK    ETIQUETTE 1 MOT CDC (USAGER)
*   IN    IGTYP   TYPE DE GRILLE 1 CARACTERE
*   IN    IMPRIM   IMPRIMME LES ELEMENTS DES FICHIERS
*                  D'ENTRE OU DE SORTI
*
*IMPLICITES
*MESSAGES 
*          MAUVAISE DIRECTIVE NUMERO=0 FICHIER MS 
*          FICHIER INCONNU ROUTINE ECRITUR
*          FIN DU FICHIER CA DEBORDE
*
*MODULES  FSTECR,PUTFLD
*
*APPEL   VIA DIRECTIVE
*        ECRITS(NOM,NPACK,IDAT,IP1,IP2,IP3,TYPE ETIQET,IGTYP,IMPRIM)
*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*
#include "lires.cdk"
#include "voir.cdk"
#include "dummys.cdk"
#include "ecrires.cdk"
#include "chck.cdk"
#include "convers.cdk"
#include "accum.cdk"
#include "indptr.cdk"
#include "enrege.cdk"
#include "dates.cdk"
#include "llccmm.cdk"

      character *12 cetiqet
      character *4 cnomvar
      character *2 ctypvar
      character *1 cigtyp
      
      integer i
      integer nom,npac,idat,ip1,ip2,ip3,igtyp,imprim,npkc
      integer iun,istamp,etiqet(*),type,cdatyp
      integer ig1srt,ig2srt,ig3srt,ig4srt,ig1s,ig2s,ig3s,ig4s
      logical rewrit
      integer letiket(3)

      integer argdims
      external argdims
*-----------------------------------------------------------------
*
      cnomvar = '    '
      ctypvar = '  '
      cetiqet = '            '
      cigtyp  = ' '
      letiket(1) = etiqet(1)
      letiket(2) = "    "
      letiket(3) = "    "
      if (argdims(8).gt.1) then 
         letiket(2) = etiqet(2)
      endif
      if (argdims(8).gt.2) then 
         letiket(3) = etiqet(3)
      endif
      ier = fstcvt(      nom,    type,  letiket,  igtyp, 
     $     cnomvar, ctypvar, cetiqet, cigtyp, .true.)

      print *, cnomvar, '--', ctypvar, '--' , cetiqet, '--', cigtyp
      
      if (nom.eq.-1)        cnomvar=cnumv
      if (type.eq.-1)       ctypvar=ctypv
      if (etiqet(1).eq.-1)  cetiqet=cetik
      if (igtyp.eq.-1)      cigtyp=cigty
      
      npkc=npac
      if (npac.eq.-1)  npkc=-16
      if (idat.eq.-1)  idat=idatt
      if (ip1.eq.-1)  ip1=jpp1
      if (ip2.eq.-1)  ip2=jpp2
      if (ip3.eq.-1)  ip3=jpp3
      if (ip3.eq.   4095)  ip3=icnt  
      
*     
      if (necrt.lt.11) then
         ig4s=igg4
         ig3s=igg3
         ig2s=igg2
         ig1s=igg1
      endif
      
      if (necrt.eq.11) then
         ig4s=igg4
         ig3s=igg3
         ig2s=igg2
         ig1s=ig1srt
      endif

      if (necrt.eq.12)  then
         ig4s=igg4
         ig3s=igg3
         ig2s=ig2srt
         ig1s=ig1srt
      endif
         
      if (necrt.eq.13) then
         ig4s=igg4
         ig3s=ig3srt
         ig2s=ig2srt
         ig1s=ig1srt
      endif
      
      if (necrt.eq.14) then
         ig4s=ig4srt
         ig3s=ig3srt
         ig2s=ig2srt
         ig1s=ig1srt
      endif
*     
      if (necrt.gt.9) then
         write(6,660) cnumv,idatt,jpp1,jpp2,jpp3,ctypv,cetik,cigty
 660     format('*   ENTRE     ',a2,2x,i10,3x,i5,3x,i2,
     $        3x,i3,4x,a1,4x,a10,3x,a1)
         write(6,670) cnomvar,idat,ip1,ip2,ip3,ctypvar,cetiqet,cigtyp
 670     format('*   SORTIE    ',a2,2x,i10,3x,i5,3x,i2,
     $        3x,i3,4x,a1,4x,a10,3x,a1)
*
      endif
*
      if (ichck.eq.0)  then
         write(6,*)
     $        'DIRECTIVE LIREN OU LIRSR DOIT-ETRE APPELE AVANT ECRITS'
         call pgsmabt
      endif
*
*     SI LE NOM EXISTE DANS LA TABLE BATIE PAR L USAGER ALORS
*     LE CHAMP EST MODIFIE
*     EX: ACUMULA(NNI,NNJ)= AMAX1(BAS,AMIN1(HAUT,(ACUMULA(NNI,NNJ) +
*     ECART)*FACT))
*     
      call conver(tmpif0, nni, nnj, cnomvar)
*     
      if (printsr) then
         call imprims(cnomvar,tmpif0,nni,nnj)
      endif
*
      iun=2
      if (mode.eq.1) then
         if (iwrit.eq.+1) then
            if (.not.message) iopc= fstopc('TOLRNC','DEBUGS',.true.)
            rewrit = .true.
            cdatyp = 1
*
            ier = fstecr(tmpif0,tmpif0,npkc,iun,idat,ideet,npas,
     $           nni,nnj,nnk,ip1,ip2,ip3,ctypvar,cnomvar,cetiqet,cigtyp,
     $           ig1s,ig2s,ig3s,ig4s,cdatyp,rewrit )
         else
            if (.not.message) iopc= fstopc('TOLRNC','DEBUGS',.true.)
            cdatyp = 1      
            rewrit = .false.
*     
            ier = fstecr(tmpif0,tmpif0,npkc,iun,idat,ideet,npas,
     $           nni,nnj,nnk,ip1,ip2,ip3,ctypvar,cnomvar,cetiqet,cigtyp,
     $           ig1s,ig2s,ig3s,ig4s,cdatyp,rewrit)
         endif
#if defined (SGI) || defined (NEC)
      else if (mode.eq.2) then
         write(6,*) 'LES FICHIERS DE TYPE "MS" NE SONT PAS SUPPORTES'
         write(6,*)' DANS CETTE VERSION DE PGSM'
#endif
#if defined (CRAY)
      else if (mode.eq.2)  then
         if (numero.le.0) 
         write(6,*)
     $        'MAUVAISE DIRECTIVE NUMERO.LE.0  FICHIER MS (ECRITS)'
         if (numero.ge.(iset-indxs))  then
*            call closms(2)
            call fclos(2)
            write(6,*)'FIN DU FICHIER CA DEBORDE (ECRITS)'
            call pgsmabt
         endif
*     
         if (valid)  then
            istamp=idat 
         else 
            istamp = 0
         endif
         
         
         call putfld(tmpif0,tmpif0,iun,numero,iwrit,nni,nnj, 
     $        nbrow,npkc,istamp)
         if (message)then
            write(6,600)ctypvar,cnomvar,ip1,ip2,
     $           ip3,nni,nnj,iun,numero
         endif
         numero = numero + numdel
*
#endif
*     
      else if (mode.eq.3) then
         
         if (valid) then
            istamp=idat
         else 
            istamp=0 
         endif
         call putfld(tmpif0,tmpif0,iun,0,iwrit,nni,nnj,
     $        nbrow,npkc,istamp)
         if (message) then
            write(6,610)ctypvar,cnomvar,ip1,ip2,ip3,nni,nnj,iun
         endif
      else
         if (message) then
            write(6,*)'FICHIER INCONNU ROUTINE ECRITS'
         endif
      endif
*
*
      call hpdeallc(tmpif0p,ier,1)
*      call hpdeallc(tmpiftp,ier,1)
*
 600  format(2x,' ENREG.ECRIT ',2(a2,'- '),3(i5,'- '),
     $     'TAILLE ',2(i5,'- '),
     $     'FICHIER MS ',i4,'   REC=',i4)
 610  format(2x,' ENREG.ECRIT ',2(a2,'- '),3(i5,'- '),'TAILLE ',
     $     2(i5,'- '), 'FICHIER SEQUENTIEL',i4)
*     
      return 
      end
*
***S/P GRISTDB   CALCUL LAT LONG DE CHAQUE PT D'UNE GRILLE STD "B"
*
      subroutine gristdb(nni,nnj,hem)
#include "impnone.cdk"
*
*AUTEUR   - P. SARRAZIN JANVIER 87 DRPN DORVAL P.Q. CANADA
*
*LANGAGE - RATFOR
*
*OBJET(GRISTDB)
*          CALCULER LA LATITUDE ET LA LONGITUDE DE TOUS LES POINTS
*          DE LA GRILLE DE SORTIE STANDARD 'B' LAT ET LONG EQUIDISTANT
*          LONGITUDE ZERO ET 360 PRESENT.
*
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*------------------------------------------------------
      external memoir,pgsmabt,grll,lastcol,messags
      external ezqkdef
      integer ezqkdef
*
*
#include "llccmm.cdk"
*
*
#include "grilles.cdk"
*
*     
      integer nni,nnj,hem,ier
      real xla0,xlo0,dlat,dlon,valeur
*     
      li=nni
      lj=nnj
*     
*     
*   RESERVER MEMOIR POUR LATITUDE ET LONGITUDE
*
      call hpalloc(tmplatp,nni*nnj,ier,1)
      call hpalloc(tmplonp,nni*nnj,ier,1)
*     
      lg1=hem
      cgrtyp='B'
      lg2=0
      lg3=0
      lg4=0
*     
      if (lg1.lt.0 .or. lg1.gt.2) then
         write(6,*)'GRILLE(STDB.....DOIT-ETRE  GLOBAL,NORD,SUD '
         call pgsmabt
      endif
*

      gdout = ezqkdef(li,lj,cgrtyp,lg1,lg2,lg3,lg4,0)
*     
*     
      return
      end 
*
***S/P   LIREN   LIRE UN CHAMP DANS ACCUMULATEUR
*
      subroutine liren(nom, type, idat, niv, ihr, ip3, etiqet) 
#include "impnone.cdk"
      external fstinf,pgsmlir,memoir,fstprm,pgsmabt,imprime 
      external fstopc,messags,fstcvt
      integer fstinf,pgsmlir,fstprm,fstopc,fstcvt 
*
*AUTEUR P. SARRAZIN  AOUT 82 DRPN DORVAL P.Q. CANADA
*
*LANGAGE RATFOR
*
*OBJET(LIREN)
*         LIRE UN CHAMP SUR FICHIER 1 OU 2 ET SAUVE DANS UN ACCUMULATEUR
*         POUR ETRE UTILISER PAR LES DIRECTIVES PLUSE-PLUSS 
*         MOINSE-MOINSS-PFOIS-MOYENE-RACINE-MODUL2E-MODUL2S 
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*ARGUMENTS
*   IN   NOM     NOM DU CHAMP LCAR(GZ),"TT"...... 
*   IN   TYPE    TYPE DE CHAMP "P"=PREVISION  "A" ANALYSE
*   IN   NIV     NIVEAU DU CHAMP
*   IN   IHR     HEURE DU CHAMP
*   IN   IP3     LIBRE(USAGER) COMPTEUR POUR MOYENE UTILISER PAR ECRITS
*   IN   ETIQET  ETIQUETTE 10 CARACTERES
*
*IMPLICITES
*MESSAGES 
*         RECORD N EXISTE PAS SUR FICHIER (FSTINF DANS LIREN)
*         RECORD N EXISTE PAS (PGSMLIR DANS ROUTINE LIREN)
*
*MODULES  FSTINF,PGSMABT,FSTPRM,MEMOIR,PGSMLIR
*
*APPEL     VIA DIRECTIVE
*         LIREE(NOM, TYPE, IDAT, NIV, IHR, IP3, ETIQUET)
*         LIRES(NOM, TYPE, IDAT, NIV, IHR, IP3, ETIQUET)
*
* -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
#include "chck.cdk"
#include "voir.cdk"
#include "accum.cdk"
#include "llccmm.cdk"
#include "indptr.cdk"
#include "lires.cdk"
#include "ecrires.cdk"
#include "dummys.cdk"
*
*
      character *12 cetiqet
      character *4 cnomvar
      character *2 ctypvar
      character*1 cigtyp
      integer etiqet(3),idat,ihr,iip3,ip3,irec1,iunit,niv,nom,num1,type
      integer cnbits,cdatyp,extra1,extra2,extra3,cubc,cdltf,clng,cswa 
      integer iopc
      integer argdims, letiket(3)
      external argdims
*     
      iunit=1
      iip3=ip3
      if (ip3.eq.4095)iip3=-1
*     
*     MODIFICATION DE HOLLERITH A CARACTERE
*     
      cnomvar = '    '
      ctypvar = '  '
      cetiqet = '            '
      cigtyp  = ' '
      
      letiket(1) = etiqet(1)
      letiket(2) = "    "
      letiket(3) = "    "
      if (argdims(7).gt.1) then 
         letiket(2) = etiqet(2)
      endif
      if (argdims(7).gt.2) then 
         letiket(3) = etiqet(3)
      endif
 100  ier = fstcvt(    nom,   type, letiket,    -1,
     $     cnomvar,ctypvar,cetiqet,cigtyp,     .true.)
      irec1=fstinf(iunit,nni,nnj,nnk,idat,cetiqet,niv,ihr,iip3,
     $     ctypvar,cnomvar)
      if (irec1 .lt. 0)   then
         write(6,*)
     $        'RECORD N EXISTE PAS SUR FICHIER (FSTINF LIREE-LIRES)'
         call pgsmabt
      endif
*     
*      if (nnk.gt.1)   then
*         write(6,*)'*************************************************'
*         write(6,*)'         PGSM N ACCEPTE PAS UN          '
*         write(6,*)' CHAMP DE 3 DIMENSIONS NK>1 ?? (LIREE-LIRES)'
*         write(6,*)'*************************************************'
*         call pgsmabt
*      endif
*     
*     
*  #  clef pour directive pluse,moinse,ecrits....
      ichck=1 
*     
*     
      ier = fstprm(irec1,idatt,ideet,npas,nni,nnj,nnk, cnbits,cdatyp,
     $     jpp1,jpp2,jpp3,ctypvar,cnomvar,cetiqet,cigtyp,igg1,igg2,igg3,
     $     igg4,cswa, clng, cdltf, cubc, extra1, extra2, extra3)
      
      
      if (ier .lt. 0) write(6,*)' IER = FSTPRM NEGATIF VOIR LIREN'


      cnumv = cnomvar
      ctypv = ctypvar
      cetik = cetiqet
      cigty = cigtyp
*
*       VERIFIER SI GRILLE GAUSSIENNE NI DOIT ETRE PAIR
*
      if (cigtyp.eq.'G'.and.mod(nni,2).ne.0)  call messags(nni)
*
*
*    ALLOCATION DE LA MEMOIRE 
*
      call hpalloc(tmpif0p,nni*nnj*nnk,ier,1)
*      call hpalloc(tmpiftp,nni*nnj*nnk,ier,1)
*
      if (.not.message) iopc= fstopc('TOLRNC','DEBUGS',.true.)
      num1 =pgsmlir(tmpif0,iunit,nni,nnj,nnk,idat,cetiqet,jpp1,jpp2,
     $     jpp3,ctypvar,cnomvar,cigtyp) 
*     
      if (num1 .lt. 0) then
         write(6,*)'RECORD N EXISTE PAS (LIRE LIREE-LIRES)' 
         call pgsmabt
      endif

      if (printen)  call imprime(cnomvar,tmpif0,nni,nnj)
*
*     SI COMTEUR .NE. 4095  ICNT=1 
*
      icnt = 1
      if (iunit.eq.1.and.ip3.eq.   4095)  icnt = jpp3
      if (iunit.eq.2.and.ip3.eq.   4095)  icnt = jpp3
*
*     
      return
*     
      entry lirsr(nom, type, idat, niv, ihr, ip3, etiqet)
*
      iunit = 2 
      iip3=ip3
      if (ip3.eq.4095) iip3=-1
      go to 100
      end 
      
      subroutine pgsmgetlatlon(ilat, ilon)
#include "impnone.cdk"
      integer ilat, ilon
#include "llccmm.cdk"

      ilat = tmplatp
      ilon = tmplonp

      return
      end

      subroutine pgsmsetiset
#include "impnone.cdk"

#include "indptr.cdk"

      iset = 0

      return
      end

      subroutine pgsmsetngr(newngr)
#include "impnone.cdk"
      integer newngr
#include "grilles.cdk"

      ngr = newngr

      return
      end

      subroutine pgsminitptr

#include "llccmm.cdk"

      tmpif0p = 0
      tmpif1p = 0
      tmpif2p = 0
      tmpif3p = 0
      tmpif4p = 0
      tmpiftp = 0
      tmprootp= 0
      tmplatp = 0
      tmplonp = 0
      tmplatgp= 0
      tmplongp= 0

      return
      end
c     ***************************************************************
c     *                     A S S E M B L E                         *
c     * Object :                                                    *
c     *         To assemble data field                              *
c     *                                                             *
c     * Arguments :                                                 *
c     *            IN     ni    : 1st dimension of field ZOUT       *
c     *            IN     nj    : 2nd dimension of field ZOUT       *
c     *            IN     nrows : 3rd dimension of field ZOUT       *
c     *            IN     slab  : data to assemble                  *
c     *            IN     nX    : dimension of hxpos                *
c     *            IN     hxpos : indicator of position in the grid *
c     *                                                             *
c     *            OUT    ZOUT  : field to return (assembled)       *
c     *                                                             *
c     ***************************************************************
      subroutine assemble(ZOUT,ni,nj,nrows,slab,nX,hxpos)
      implicit none
      
      integer nj, ni, nX, nrows
      real ZOUT(ni * nj, nrows)
      integer hxpos(nX)
      real slab(nX,nrows)
      integer I,k
      do k=1, nrows
         do I=1, nX
            ZOUT(hxpos(I), k) = slab(I,k)
         enddo
      enddo
      return
      end
c     ***************************************************************
c     *                     W R T S T D F                           *
c     * Object :                                                    *
c     *         To write standard file (FSTD)                       *
c     *                                                             *
c     * Arguments :                                                 *
c     *            IN    ZOUT   : data field to read                *
c     *            IN    iun    : unit number of the file           *
c     *            IN    dateo  : origin date of the field          *
c     *            IN    deet   : time step length in seconds       *
c     *            IN    npas   : time step number                  *
c     *            IN    ni     : 1st dimension of field            *
c     *            IN    nj     : 2nd dimension of field            *
c     *            IN    nrows  : 3rd dimension of field            *
c     *            IN    ip1    : descriptor 1 (1 to 32767)         *
c     *            IN    ip2    : descriptor 2 (1 to 32767)         *
c     *            IN    ip3    : descriptor 3 (1 to 32767)         *
c     *            IN    typvar : field type                        *
c     *            IN    nomvar : name of field                     *
c     *            IN    etiket : 9 caracter stamp                  *
c     *            IN    grtyp  : grid type                         *
c     *            IN    ig1    : grid descriptor 1 (0 to 2047)     *
c     *            IN    ig2    : grid descriptor 2 (0 to 2047)     *
c     *            IN    ig3    : grid descriptor 3 (0 to 65535)    *
c     *            IN    ig4    : grid descriptor 4 (0 to 65535)    *
c     *            IN    datyp  : type of data field                *
c     *            IN    Nextra : number of extra parameters        *
c     *                           (Nextra >= 0)                     *
c     *            IN    xtra   : field of optionnal variable       *
c     *                                (absent IF Nextra = 0)       *
c     *                                                             *
c     ***************************************************************
      subroutine wrtstdf (ZOUT,iun, dateo, deet, npas, ni, nj,nxgrid,
     %           nygrid,  nrows, ip1, ip2, ip3, typvar,nomvar, etiket,
     %           grtyp, ig1, ig2, ig3, ig4, datyp,Nextra,xtra, nbits,
     %           iflt,list,L, S)
      implicit none
      integer fstecr
      integer ni, nj, nrows, k, Nextra, i, j
      integer nxgrid, nygrid
      real ZOUT(ni , nj, nrows), work(1), xtra(nrows, Nextra)
      integer ip1(nrows), ip2(nrows), ip3(nrows),npak, nbits(nrows)
      integer ig1, ig2, ig3, ig4
      integer iun, datyp(nrows)
      integer npas, deet, dateo
      character *4 nomvar(nrows)
      character *4 typvar(nrows)
      character *4 grtyp
      character *12 etiket
      integer ierr, ier, S 
      real Temp
      integer L, iflt(nrows)
      integer list(L)
      integer sum
      real FACT
      pointer (pfact,FACT(L, (L + 1)/2))
      pointer (ptemp,Temp(nxgrid, nj))

*     call stkmemw(l*(l+1)/2,pfact)
      call hpalloc(pfact,L * (L+1)/2,ier, 0)
      do k=1, (L+1)/2
         do I=1, L
            fact(I,k) = 0
         enddo
      enddo
      do k=1,(L + 1)/2
         sum = 0
         do I=k, L - k + 1
            sum = sum + list(I)
         enddo
         do I=k,L - k + 1
            FACT(I,k) = float(list(I)) / float(sum)
         enddo
      enddo
*     call stkmemw(nxgrid*nj,ptemp)
      call hpalloc(ptemp, (nxgrid * nj), ier, 0)
      do 300 k=1, nrows
         npak = -nbits(k)
         if (nxgrid .eq. (ni + 1)) then
            do j=1, nj
               do i=1, ni                  
                  Temp(i,j) = ZOUT(i,j,k)
               enddo
            enddo
            do j=1,nj
               Temp(nxgrid,j) = Temp(1,j)
            enddo
            if ((iflt(k) .GT. 0) .and. (L .gt. 1)) then
               call filtre (Temp,nxgrid,nj,nrows,iflt(k),FACT,list,L)
            endif    
            ierr = fstecr(Temp, work, npak, iun, dateo, deet, 
     %           npas, nxgrid, nj, 1, ip1(k), ip2(k), ip3(k), 
     %           typvar(k)(1:1), nomvar(k)(1:2), etiket(1:8),
     %           grtyp(1:1), ig1, ig2, ig3, ig4, datyp(k),
     %           .false.)
            
         else 
            if ((iflt(k) .GT. 0) .and. (L .gt. 1)) then
               call filtre (ZOUT(1,1,k),nxgrid,nj,nrows,iflt(k),FACT
     %              ,list,L)
            endif    
            ierr = fstecr(ZOUT(1,1,k), work, npak, iun, dateo, deet, 
     %           npas, ni, nj, 1, ip1(k), ip2(k), ip3(k), 
     %           typvar(k)(1:1), nomvar(k)(1:2), etiket(1:8),
     %           grtyp(1:1), ig1, ig2, ig3, ig4, datyp(k),
     %           .false.)
         endif
 300  continue
      
*      call unstakw(pfact)
*      call unstakw(ptemp)
      call hpdeallc(pfact,ier,0) 
      call hpdeallc(ptemp,ier,0)
      
      if (Nextra .ne. 0) then
         ierr = fstecr(xtra ,WORK,npak, iun, 20002020,
     %        1, 1, nrows, Nextra,1, 0,0,S,'|',
     %        '||' ,'||||*||||','x',0,0,
     %        0,0,1, .false.) 
      endif
      
      return
      end
c     ***************************************************************
c     *                       W S T D F X Y                         *
c     * Object :                                                    *
c     *         To write record ('>>' and '^^') in standard file    *
c     *                                                             *
c     * Arguments :                                                 *
c     *            IN    xpos   : field to write (dim : ni)         *
c     *            IN    ypos   : filed to write (dim : nj)         *
c     *            IN    iun    : unit number of the file           *
c     *            IN    datoe  : date of origine of the field      *
c     *            IN    deet   : time step lenght in seconds       *
c     *            IN    npas   : time step number                  *
c     *            IN    ni     : dimension of xpos                 *
c     *            IN    nj     : dimension of ypos                 *
c     *            IN    ip1    : descriptor 1                      *
c     *            IN    ip2    : descriptor 2                      *
c     *            IN    ip3    : descriptor 3                      *
c     *            IN    etiket : 9 caracter stamp                  *
c     *            IN    grtyp_ : grid type for ">>" and "^^"       *
c     *            IN    ig1_   : grid descriptor 1 of ">>" and "^^"*
c     *            IN    ig2_   : grid descriptor 2 of ">>" and "^^"*
c     *            IN    ig3_   : grid descriptor 3 of ">>" and "^^"*
c     *            IN    ig4_   : grid descriptor 4 of ">>" and "^^"*
c     *                                                             *
c     ***************************************************************
      subroutine wstdfxy (xpos, ypos, iun, dateo, deet, npas, ni, nj,
     % 	                  ip1, ip2, ip3, etiket, grtyp_, ig1_,
     %                    ig2_, ig3_, ig4_)
      implicit none
      integer fstecr
      integer ni, nj
      real xpos(ni), ypos(nj), work(1)
      integer ip1, ip2, ip3
      integer ig1_, ig2_, ig3_, ig4_
      integer datyp, npak, npas, deet, dateo
      
      integer i
      
      character *4 grtyp_
      character *12 etiket
      integer ierr, iun
      npak = -24
      datyp = 1
      
      ierr = fstecr(xpos, work, npak, iun, dateo, deet, 
     %                 npas, ni, 1, 1, ip1, ip2, ip3, 
     %                 'X', '>>', etiket,
     %                 grtyp_(1:1), ig1_, ig2_, ig3_, ig4_, datyp,
     %                 .false.)
      ierr = fstecr(ypos, work, npak, iun, dateo, deet, 
     %                 npas, 1, nj, 1, ip1, ip2, ip3, 
     %                 'X', '^^', etiket,
     %                 grtyp_(1:1), ig1_, ig2_, ig3_, ig4_, datyp,
     %                 .false.)
   
      return
      end
*     
***   S/P CHAMP, IDENTIFICATION DU CHAMP APPELER ROUTINE APPROPRIEE
*     
#include "defin.cdk"
      subroutine champ(nom,ipr1,ipr2,ipr3,ipr4,ipr5,
     $     ipr6,ipr7,ipr8,ipr9, 
     $     ipr10,ipr11,ipr12,ipr13,ipr14,ipr15,ipr16,ipr17,
     $     ipr18,ipr19,ipr20,ipr21,ipr22,ipr23,ipr24,
     $     ipr25,ipr26,ipr27,ipr28,ipr29,ipr30)
#include "impnone.cdk"
*     
*AUTEUR
*   P. SARRAZIN JANVIER 82 DRPN DORVAL P.Q. CANADA
*REVISION 4.0.2
*         CONVERSION DES VARIABLES HOLLERITH EN CARACTERE
*         MODIFS SUR LES TESTS TOUCHANT LE TABLEAU "PAIRE"
*         Y. CHARTIER AOUT 90 DRPN DORVAL QUEBEC. 
*
*LANGAGE RATFOR
*
*OBJET(CHAMP)
*         POINT D'ENTREE APPELE PAR LA DIRECTIVE
*         CHAMP(NOM,  PARM1,PARM2....PARMX)
*         EX.  CHAMP(Z,1000,850,700,500)
*         LE S/P CHAMP APPELLE LE SOUS PROGRAMME APPROPRIE
*         POUR LE TYPE DE CHAMP DEMANDE 
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*
*ARGUMENTS
*  IN    NOM         NOM DU CHAMP (DIRECTIVES DE L'USAGER)
*  IN    IPR1-IPR30  DESCRIPTEURS SUPLEMENTAIRES (HEURES - NIVEAUX)
*                    DEMANDEES PAR L'USAGER
*
*IMPLICITES
*
*     MODULES
      external fstcvt, argdims,
     $     grille2,epaisur,macpcp,uvectur,scalair
*
*APPEL
*          VIA DIRECTIVE
*          CHAMP(NOM,IPR1......IPR30)
*          MAXIMUM DE 30 IPR
*
*MESSAGES 
*          TYPE DE GRILLE NON DEFINI DEFAUT=GRILLE P.S.NORD(2805)
*          DIRECTIVE HEURE PAS NECESSAIRE POUR MAC(ST)
*          DIRECTIVE HEURE PAS NECESSAIRE POUR PRECIP
*
*-----------------------------------------------------------------------
*
#include "heures.cdk"
*
*
#include "voir.cdk"
#include "accum.cdk"
#include "indptr.cdk"
#include "dates.cdk"
#include "champs.cdk"
#include "lires.cdk"
#include "pairs.cdk"
#include "ecrires.cdk"
#include "grilles.cdk"
#include "llccmm.cdk"
#include "lnkflds.cdk"
*----------------------------------------------------------------------
*
*
*
      integer ihr,ihrs,ipr1,ipr2,ipr3,ipr4,ipr5,ipr6,ipr7
      integer ipr8,ipr9,ipr10,ipr11,ipr12,ipr13,ipr14,ipr15
      integer ipr16,ipr17,ipr18,ipr19,ipr20,ipr21,ipr22,ipr23
      integer ipr24,ipr25,ipr26,ipr27,ipr28,ipr29,ipr30,nparm
      integer i,np,nw,trouve
      integer fstcvt,argdims 
      
      integer nom(2)
      character*8 cnom 
*
*
      if (inputmod.eq.SEQUENTIEL) then
	   print *,'***************************************************'
	   print *,'* ON NE PEUT UTILISER LA DIRECTIVE "CHAMP"        *' 
	   print *,'* AVEC UN FICHIER D ENTREE SEQUENTIEL             *'
	   print *,'*                                                 *'
	   print *,'* UTILISEZ PLUTOT LA DIRECTIVE "CHAMP_SEQ"        *'
	   print *,'***************************************************'
           return
      endif


      champpr(1) = -1 
      nchamp = min0(31,nchamp)
      go to (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,
     $     21,22,23,24,25,26,27,28,29,30,31) ,nchamp
 31   champpr(30) = ipr30
 30   champpr(29) = ipr29
 29   champpr(28) = ipr28
 28   champpr(27) = ipr27
 27   champpr(26) = ipr26
 26   champpr(25) = ipr25
 25   champpr(24) = ipr24
 24   champpr(23) = ipr23
 23   champpr(22) = ipr22
 22   champpr(21) = ipr21
 21   champpr(20) = ipr20
 20   champpr(19) = ipr19
 19   champpr(18) = ipr18
 18   champpr(17) = ipr17
 17   champpr(16) = ipr16
 16   champpr(15) = ipr15
 15   champpr(14) = ipr14
 14   champpr(13) = ipr13
 13   champpr(12) = ipr12
 12   champpr(11) = ipr11
 11   champpr(10) = ipr10
 10   champpr(9) = ipr9
 9    champpr(8) = ipr8
 8    champpr(7) = ipr7
 7    champpr(6) = ipr6
 6    champpr(5) = ipr5
 5    champpr(4) = ipr4
 4    champpr(3) = ipr3
 3    champpr(2) = ipr2
 2    champpr(1) = ipr1
*
 1    nw = min(argdims(1), 2) 
  
      if (nw.eq.1) then
         if (nom(1).eq.-1) then
            cnom = ' '
         else
            write(cnom, '(A4)') nom(1)
         endif
      else
         write(cnom,'(2A4)') (nom(i), i=1,nw)
      endif
      call low2up(cnom,cnom)
*     
      nchmp = nchamp
*
*
      nparm = max0(1,nchmp - 1)
      if (tmplatp.eq.0.and.cgrtyp.ne.'*') then
         if (message) then
            write(6,*)'GRILLE NON DEFINIE ..GRILLE DE DEFAUT P.S.(2805)'
         endif
         ngr=8
         call grille2(3,51,55,26.,28.,381000.,350.,1) 
      endif
*
      if (cnom.eq.'DFPR'.or.cnom.eq.'DFST')  go to 99999
*
*   VERIFIER SI DIRECTIVE HEURE EXISTE OBLIGATOIRE AVEC CHAMP
*
      if (nhur.eq.0) then
         write(6,*)'  ON DOIT DEFINIR DIRECTIVE HEURE '
         return
      endif
*
99999 continue
*
      if (npair.gt.NPAIRMX) npair=NPAIRMX
*
      do ihrs = 1, nhur
         ihr = heures(ihrs)
*
*   CALCUL DES VECTEURS OU DE LA VITESSE DU VENT
*
         trouve=0
         do np=1,npair
            if (cnom.eq.paire(np)(1:8)) trouve=np
         enddo
*
*  SI ON A TROUVE ON VA A L'INTERPOLATION
*
         if (trouve.ne. 0) then
            vvent  = .false.
            wdvent = .false.
            if (paire(trouve)(17:20).ne.'??  ') then
               vvent= .true.
            endif
            if (paire(trouve)(21:24).eq.'WD  ') then
               wdvent= .true.
               vvent = .true.
            endif

            if (cgrtyp.eq.'*') then
               write (6,*) 'GRILLE(AUCUNE) NE FONCTIONNE QUE POUR LES VARIABLES'
               write (6,*) 'PCP, EPAIS, DFST ET NUAG'
            else
               call uvectur(paire(trouve)(9:12), paire(trouve)(13:16),
     $              paire(trouve)(17:20),ihr,nparm,champpr)
            endif
*     
*     CALCUL LA DIFFERENCE ENTRE DEUX "GZ"
*     
*     
         else if (cnom.eq.'DFGZ') then
            call epaisur(ihr, nparm, champpr)
*
*     CALCUL LA DIFFERENCE ENTRE DEUX "ST ACCUMULATEUR D'AJUSTEMENT"
*
*
         else if (cnom.eq.'DFST') then
            if (ihrs.eq.1)   then
               call macpcp('ST', nparm, champpr)
               if (message) then
                  if (nhur.gt.1)
     $                 write(6,*)' HEURE PAS NECESSAIRE  (ST)'
               endif
            endif
*
*
*     CALCUL LA DIFFERENCE ENTRE DEUX "PR" PRECIPITATION
*     
         else if (cnom.eq.'DFPR') then
            if (ihrs.eq.1) then
               call macpcp('PR', nparm, champpr)
               if (message) then
                  if (nhur.gt.1) then
                     write(6,*)
     $                    'DIRECTIVE HEURE PAS NECESSAIRE POUR PRECIP'
                  endif
               endif
            endif
*     
*     INTERPOLATION DES NUAGES BAS,MOYEN,HAUT
*     
         else if (cnom.eq.'NUAG') then
            call scalair('NB', ihr, 1, champpr) 
            call scalair('NM', ihr, 1, champpr) 
            call scalair('NH', ihr, 1, champpr) 
            
*     AUTRE NOM  (GZ,TT,DD,WW,QQ,ES,DZ,ST,PR........)
*     
         else 
            if (cgrtyp.eq.'*') then
               write (6,*) 'GRILLE(AUCUNE) NE FONCTIONNE QUE POUR LES VARIABLES'
               write (6,*) 'PCP, EPAIS, DFST ET NUAG'
            else
               call scalair(cnom, ihr, nparm, champpr)
            endif
         endif
         
      enddo

      return 
      end
      
***S/P ECRITUR   ECRIRE SUR FICHIER STANDARD, MS, SEQUENTIEL
*     
      subroutine ecritur(champ,npac,idat,deet,npas,ni,nj,nk,
     $     ip1,ip2,ip3, 
     $     ctypvar,cnomvar,cetiket,cgtyp,llg1,llg2,llg3,llg4)
#include "impnone.cdk"
      external conver,fstecr,fclos,memoir,pgsmabt,
     $     imprims,fstopc,messags,fstcvt,putfld
      integer fstopc,fstcvt,fstecr
*     
*AUTEUR  P.SARRAZIN  JANVIER 82  DRPN DORVAL P.Q. CANADA
*REVISION 4.0.2
*   MODIF. VARIABLES TYPE HOLLERITH EN CARACTERE
*   Y. CHARTIER -AOUT 90- DRPN DORVAL QUEBEC.
*Revision 5.0.0
*   Elimination appels a fstcvt pour etiksrt
*   Y. Chartier -mai  91- drpn Dorval Quebec
*
*LANGAGE RATFOR
*
*OBJET(ECRITUR)
*          ECRIRE SUR FICHIER STANDARD AVEC ROUTINE FSTECR
*          ECRIRE SUR FICHIER MS AVEC PUTFLD
*          ECRIRE SUR FICHIER SEQUENTIEL AVEC PUTFLD
*
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*ARGUMENTS
*   IN    CHAMP   CHAMP(NI,NJ,NK) A ECRIRE
*   IN    NPAC    COMPACTION DU DATA DANS CHAMP
*   IN    IDAT    DATE DU CHAMP (CMC STAMP)
*   IN    DEET    PAS DE TEMPS ENTIER SECONDES
*   IN    NPAS    NUMERO DU PAS DE TEMPS
*   IN    NI      1 ER DIMENSION DU CHAMP
*   IN    NJ      2 IEM DIMENSION DU CHAMP
*   IN    NK      3 IEME DIMENSION DU CHAMP
*   IN    IP1     NORMALEMENT NIVEAU DU CHAMP
*   IN    IP2     HEURE DU CHAMP
*   IN    IP3ENT     LIBRE
*   IN    TYPEENT   TYPE DU CHAMP 1 CARACTERE
*   IN    NOM     NOM DU CHAMP 2 CARACTERES
*   IN    ETIKE   ETIQUETTE 1 MOT CDC (USAGER)
*   IN    GRTYPE  TYPE DE GRILLE 1 CARACTERE
*   IN    LLG1    DESCRIPTEUR DE GRILLE 
*   IN    LLG2    PS - LLG1 POSITION J DU POLE
*   IN    LLG3         LLG2 POSITION I DU POLE
*   IN    LLG4         LLG3 DGRW*100
*                      LLG4 D60 HETOMETRE(0-36000)
*                 LAT-LON  LLG1- DLAT*100
*                          LLG2- DLON*100
*                          LLG3- (90-LAT)*100 0=POLE SUD
*                          LLG4- (LON*100) (0-36000) LONGITUDE COIN
*                 GAUSSIEN  LLG1= 1 HEMISPHERE NORD
*                           LLG1= 2 HEMISPHERE SUD
*                           LLG1= 3 GLOBALE
*
*MESSAGES 
*         FIN DU FICHIER CA DEBORDE
*         MAUVAISE DIRECTIVE NUMERO=0 FICHIER MS
*         FICHIER INCONNU ROUTINE ECRITUR
*
*MODULES  FSTECR,PUTFLD
*
*APPEL
*         CALL ECRITUR(CHAMP,NPAC,IDAT,DEET,NPAS,NI,NJ,NK,IP1,IP2,IP3,
*                      TYPEV,NOM,ETIKE,GRTYPE,LLG1,LLG2,LLG3,LLG4)
*
*- -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*
#include "lires.cdk"
#include "voir.cdk"
#include "ecrires.cdk"
#include "llccmm.cdk"
#include "indptr.cdk"
#include "enrege.cdk"
#include "dates.cdk"
#include "dummys.cdk"
#include "idents.cdk"
#include "qqqfilt.cdk"
*
*-----------------------------------------------------------------
*
      character *24 chaine
      character *12 cetiket, cetksrt
      character *4 cnomvar
      character *2 ctypvar
      character *1 cgtyp
      

      character*12 letiksrt
      character*4 lnomvar
      character*2 ltypsrt

      character*72 form1,form2

      integer i, npac,idat,idatv,npas,ni,nj,nk,ip1,ip2,ip3,deet
      real champ(ni,nj,nk)
      real dummy(2)
      integer llg1,llg2,llg3,llg4,iun,istamp,ip3o,ip2o
      integer cdatyp,iopc,ier,gdout
      logical rewrit

      integer gdll,ezgetgdout
      external gdll,ezgetgdout
      
      real*8 delta_t

*     
*      call hpalloc(tmpiftp,ni*nj + 20,ier,1)
      if (etiksrt(1) .eq. -1) then
         cetksrt = cetiket
      else
         write(cetksrt,'(3A4)') (etiksrt(i), i=1,nwetiks)
      endif

      if (typesrt .eq. -1) then
         ltypsrt = ctypvar
      else
         write(ltypsrt, '(A2)') typesrt
      endif
      
*     
      if (ip3srt.ne.-1) then
         ip3o=ip3srt
      else 
         ip3o=ip3
      endif
*
      if (ip2srt.ne.-1) then
         ip2o=ip2srt
      else 
         ip2o=ip2
      endif

*      ltypsrt = ctypsrt
      lnomvar = cnomvar
      letiksrt = cetksrt

*
*
*
*
*     SI LE NOM EXISTE DANS LA TABLE BATIT PAR L USAGER ALORS
*     LE CHAMP EST MODIFIE  EX: CHAMP(NI,NJ) = (CHAMP(NI,NJ)+ECART)*FACTEUR
*
      call conver(champ, ni, nj, cnomvar)
*     
*
*     filtrage du champ de sortie si le champ n'est pas un stream latlon
*

      if (fltoggle(2)) then
        if (cgtyp.eq.'Y') then
          write (6, *) '(ECRITUR) Impossible de filtrer des champs sur grille Y'
        else
          write (6, *) ' CHAMP FILTRE A L''ECRITURE'
*          call statfld4 (champ,cnomvar,0,'AVANFFLT',ni,nj,1,ni,nj,1,0,0
*     &         ,0)
          call filtre (champ, NI, NJ, 0, fltntimes(2), fltlist(1,2), fltwgtlng(2))
*          call statfld4 (champ,cnomvar,1,'APRESFLT',ni,nj,1,ni,nj,1,0,0
*     &         ,0)
        endif
      endif

*
*
*


      if (printsr)  then
         call imprims(cnomvar,champ,ni,nj) 
      endif
*     
      iun=2
      if (mode.eq.1) then
*     IWRIT=+1  SORTI(STD,500,R)
         if (iwrit.eq.+1) then
            if (.not.message) then
               iopc= fstopc('TOLRNC','DEBUGS',.true.)
            endif
            rewrit = .true.
            cdatyp = 1 
*     
            ier = fstecr(champ,dummy,npac,iun,idat,deet,npas,
     $           ni,nj,nk,ip1,ip2o,ip3o,ltypsrt,cnomvar,cetksrt,
     $           cgtyp,llg1,llg2,llg3,llg4,cdatyp,rewrit )
         else
            if (.not.message) then
               iopc= fstopc('TOLRNC','DEBUGS',.true.)
            endif
            cdatyp = 1      
            rewrit = .false.
            ier = fstecr(champ,dummy,npac,iun,idat,deet,npas,
     $           ni,nj,nk,ip1,ip2o,ip3o,ltypsrt,cnomvar,cetksrt,
     $           cgtyp,llg1,llg2,llg3,llg4,cdatyp,rewrit )
         endif
*     
      else
         if (mode.eq.2) then
            write(6,*)
     $           'LES FICHIERS DE TYPE "MS" NE SONT PLUS SUPPORTES' 
         else
         endif
*     
         if (mode.eq.3.or.mode.eq.4) then
            if (mode.eq.4) then
               cdatyp = 1
               write (chaine, 10) ltypsrt,lnomvar,letiksrt,cgtyp
 10            format(a2,2x,a4,a12,a1,3x)
               write (iun) npac, idat, deet, npas, ni, nj, nk, 
     $              ip1, ip2o, ip3o, llg1, llg2, llg3, llg4, cdatyp,
     $              chaine
            endif
            
            write(iun) champ
            if (message) then
               write(6,610)ltypsrt,cnomvar,ip1,ip2o,ip3o,ni,nj,iun
            endif
         else if (mode.eq.5) then
            if (valid) then
               if (date .ne. -1) then
                  istamp = date
               else
                  istamp = idat
               endif
            else
               istamp=0
            endif

            delta_t = deet*npas/3600.0
            call incdatr(idatv,idat,delta_t)

            gdout = ezgetgdout()
            ier = gdll(gdout, tmplat,tmplon)
            call pgsmwr(2,champ,ni,nj,nk,qcform,qposition,qitems,qcsepar,cnomvar,ctypvar,cetiket,
     $           idat,idatv,ip1,ip2,ip3,tmplat,tmplon)

*     
         else
            if (message) then
               write(6,*)'FICHIER INCONNU ROUTINE ECRITUR' 
            endif
         endif
      endif
*      call hpdeallc(tmpiftp,ier,1)
*     
*     
 600  format(2x,' ENREG.ECRIT ',2(a2,'- '),3(i5,'- '),
     $     'TAILLE ',2(i5,'- '),'FICHIER MS ',i4,'   REC=',i4)
 610  format(2x,' ENREG.ECRIT ',2(a2,'- '),3(i5,'- '),
     $     'TAILLE ',2(i5,'- '),'FICHIER SEQUENTIEL',i4)
      return 
      end
      
*
***S/P GRITP12   LIRE LAT LONG DE CHAQUE PT D'UNE GRILLE TYPE "Y" OU "Z"
*
      subroutine gritp12(it,ip1,ip2,ip3)
#include "impnone.cdk"
      integer it,ip1,ip2,ip3
*
*AUTEUR   - P. SARRAZIN JANVIER 87 DRPN DORVAL P.Q. CANADA
*
*LANGAGE - RATFOR
*
*OBJET(GRITP12)
*          LIRE UN REC DE LAT ET UN REC DE LONG
*          POUR LA GRILLE DE TYPE "Y" OU "Z".
*          Y = LISTE DE LAT-LON(NI,NJ) OU X-Y(NI,NJ)
*          Z = COLONNE DE LAT(NJ) OU RANGEE DE LONG(NI)
*              OU COLONNE DE Y(NJ)   RANGEE DE X(NI)
*          COORDONNEE X,Y SONT POLAIRE STEREOGRAPHIQUE
*
*
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*------------------------------------------------------
*
      external pgsmabt,memoir,fstprm,cigaxg,messags,fstcvt 
      external imprime,ecritur,fstopc,fstinf,fstlir,conlal2
      integer fstprm,fstopc,fstinf,fstlir,fstcvt 

      integer ezqkdef, ezgdef,ezgfstp, ezgxprm, gdgaxes, gdll, chkenrpos
      external ezqkdef, ezgdef,ezgfstp, ezgxprm, gdgaxes, gdll, chkenrpos
*

#include "llccmm.cdk"
#include "indptr.cdk"
#include "packin.cdk"
#include "grilles.cdk"
#include "lires.cdk"
#include "voir.cdk"
#include "tp12ig.cdk"

      character *12 etikx
      character *4 nomx
      character *2 ctpvrla,ctpvrlo,cgtyplo,cgtypla
      character*2 grref


      integer i
      integer swa, lng, dltf, ubc, extra1, extra2, extra3

      integer iunit,irecla,ireclo,ni,nj,nk
      integer dateo, deet, npas
      integer numla,numlo,ier,iopc
      integer ig1, ig2, ig3, ig4, ig1ref, ig2ref, ig3ref, ig4ref
      integer ip1x, ip2x, ip3x

      character*4 nomvarx, nomvary
      character*12  etiketx, etikety
      character*2   typvarx, typvary
      integer nix, njx, niy, njy, nkx, nky
      integer dateox, deetx,npasx, nbitsx, datypx
*     
      real pidum,pjdum,d60dum
      integer lip1, lip2, lip3

*     
*     
      if (it.eq.gr_tape2) then
         iunit=2
      else
         iunit=1
      endif
*
*  VERIFICATION DES PARAMETRES DES 2 RECORDS
*  SI LU SUR UNIT 1 ON ECRIT LES 2 RECORDS SUR UNIT 2
*     
      
      if (it.ne.gr_stations) then
         if (it.ne.gr_tape2) then
            ier = chkenrpos(1,2,ip1,ip2,ip3)
            if (ier.lt.0) then
               print *, '<gritp12> enregistrements positionnels absents!'
               print *, '          impossible de continuer...'
               call exit(13)
            endif
         endif
         
         if (mode.eq.1) then
            ireclo = fstinf(iunit, nix, njx, nkx, -1, '            ', ip1, ip2, ip3, '  ', '>>  ')
            irecla = fstinf(iunit, niy, njy, nky, -1, '            ', ip1, ip2, ip3, '  ', '^^  ')
            
            ier = fstprm(ireclo, dateox, deetx, npasx, nix, njx, nkx, nbitsx,
     $           datypx, lip1, lip2, lip3, typvarx, nomx, etikx,
     $           grref, ig1ref, ig2ref, ig3ref, ig4ref, 
     $           swa, lng, dltf, ubc, extra1, extra2, extra3)
            li = nix
            lj = njy
            gdout = ezqkdef(li,lj,'Z',lip1,lip2,lip3,0,iunit)
         else
            ireclo = fstinf(iunit, nix, njx, nkx, -1, '            ', ip1, ip2, ip3, '  ', '>>  ')
            irecla = fstinf(iunit, niy, njy, nky, -1, '            ', ip1, ip2, ip3, '  ', '^^  ')
            ier = fstprm(ireclo, dateox, deetx, npasx, nix, njx, nkx, nbitsx,
     $           datypx, lip1, lip2, lip3, typvarx, nomx, etikx,
     $           grref, ig1ref, ig2ref, ig3ref, ig4ref, 
     $           swa, lng, dltf, ubc, extra1, extra2, extra3)
            li = nix
            lj = njy
            gdout = ezqkdef(li,lj,'Z',lip1,lip2,lip3,0,1)
         endif
      else
         nix = ncoords
         niy = ncoords
         njx = 1
         njy = 1
         cgrtyp = 'Y'
         cgtypxy= 'L'
         nomvarx = '>>  '
         nomvary = '^^  '
         etikety=  'NORDSUD     '
         etiketx = 'ESTOUEST    '
         typvarx = 'C '
         typvary = 'C '
         ip1x = ip1
         ip2x = ip2
         ip3x = ip3
         deetx= 0
         npasx= 0
         dateox = 017901000
         li = ncoords
         lj = 1
         call cxgaig('L',ig1la,ig2la,ig3la,ig4la,0.,0.,1.0,1.0)
         call cxgaig('L',ig1lo,ig2lo,ig3lo,ig4lo,0.,0.,1.0,1.0)
         npack = -32

          do i=1,li*lj
             print *, i, dateox,typvarx,li,lj
          enddo

      endif
         
*     
*     INITIALISATION DE DGRWXY POUR UTILISATION DANS  ROUTINE VDAUV
*     
      call hpalloc(tmplonp,li*lj,ier,1)
      call hpalloc(tmplatp,li*lj,ier,1)
      
      if (cgtypxy.eq.'E') then
         call hpalloc(tmplongp,li*lj,ier,1)
         call hpalloc(tmplatgp,li*lj,ier,1)
      endif
*     
      if (.not.message) iopc= fstopc('TOLRNC','DEBUGS',.true.) 
*     
      if (it.eq.gr_stations) then
         call fillcoord(tmplat,tmplon,coordll,ncoords)
         gdout = ezgdef(nix,njx,cgrtyp,cgtypxy,ig1la,ig2la,
     $        ig3la,ig4la,tmplon,tmplat)

         if (mode.eq.1) then
            call ecritur(tmplon,npack,dateox,deetx,npasx,ncoords,1,1,
     $           ip1x,ip2x,ip3x,
     $           typvarx,nomvarx,etiketx,cgtypxy,ig1lo,ig2lo,ig3lo,ig4lo)
            
            call ecritur(tmplat,npack,dateox,deetx,npasx,ncoords,1,1,
     $           ip1x,ip2x,ip3x,
     $           typvary,nomvary,etikety,cgtypxy,ig1la,ig2la,ig3la,ig4la)
         endif
      else
*         ier = gdgaxes(gdout, tmplon, tmplat)
          ier = gdll(gdout, tmplon, tmplat)
      endif

      ier = ezgxprm(gdout,li,lj,cgrtyp,
     $     lg1,lg2,lg3,lg4,cgtypxy,ig1ref,ig2ref,ig3ref,ig4ref)
*     
*      lg1 = ip1
*      lg2 = ip2
*      lg3 = ip3
*      lg4 = 0
      if (printen)  call imprime(nomvary,tmplat,niy,njy)
      if (printen)  call imprime(nomvarx,tmplon,nix,njx)

*     
*     CALCUL LATITUDES LONGITUDES  DU TYPE "Z" OU "Y"
*     
      if (cgrtyp.eq.'Z') then
         ier = gdll(gdout,tmplat,tmplon)
      endif
      
      if (printen) write(6,*)' IMPRIME LAT LON APRES CALL GDLL'
      if (printen)  call imprime(nomvarx,tmplat,niy,njy)
      if (printen)  call imprime(nomvary,tmplon,nix,njx)
*     
      
      return
      end 
      
      
*
      subroutine lopascm(sortent,entre,fact,nombre)
#include "impnone.cdk"
*
*AUTEUR P. SARRAZIN DORVAL QUEBEC CANADA (DRPN)
*
*OBJET(LOPASCM)
*         LOPASCM - ADDITIONNE,SOUSTRAIT,MULTIPLI DEUX CHAMPS OU SOMME
*                   DEUX CHAMPS DONT CHAQUE PT EST AU CARRE 
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*ARGUMENTS
* IN-OUT  SORTENT - RESULTAT DE L'OPERATION ET ENTRE DU CHAMP
*   IN    ENTRE   - DEUXIEME CHAMP POUR OPERATION 
*   IN    FACT    - OPERATEUR 1=ADDITIONNE , -1=SOUSTRAIT 3=MULTIPLI
*                             2=ADDITIONNE CHAQUE POINT AU CARRE
*   IN    NOMBRE  - NOMBRE DE POINTS DANS LES CHAMPS SORTENT/ENTRE
*
*APPEL
*     - VIA PLMNMOD 
*      CALL LOPASCM(SORTENT,ENTRE,FACT,NOMBRE)
*
*----------------------------------------------------------------------
*
#include "voir.cdk"
*
*
*
      integer nombre,i,fact
      real sortent(nombre),entre(nombre)
*     
*       SOUSTRAIT SI FACT=-1  ADDITIONNE SI FACT=1
*
      if (abs(fact).eq.1) then
         do i=1,nombre
            sortent(i)=sortent(i) + entre(i)*fact
         enddo
*     
*     ADDITIONNE CHAQUE POINT DES DEUX CHAMPS AU CARRE
*     
      else if (fact.eq.2)  then
         do i=1,nombre
            sortent(i)=sortent(i)**2 + entre(i)**2
         enddo
*     
*     MULTIPLIT CHAQUE POINT DES DEUX CHAMPS
*     
      else if (fact.eq.3) then
         do i=1,nombre
            sortent(i)=sortent(i)*entre(i)
         enddo
      else  if (fact.eq.4) then
         do i=1,nombre
            if (entre(i).eq.0.0) then
               print *, 'LOPASCM - Un des elements du tableau a une valeur de 0.0'
               print *, 'Division impossible - sortie forcee'
               call qqexit(13)
            endif
         enddo
         do i=1,nombre
            sortent(i)=sortent(i)/entre(i)
         enddo
      else
         write(6,*)' ERREUR DANS ROUTINE LOPASCM (FACT..?)'
      endif
*     
      return
      end
      
***S/P PGSMLIC
*     
      integer function pgsmlic(fld,iun,ni,nj,nk,datev,etiket,
     $     ip1,ip2,ip3,typvar,nomvar,ig1,ig2,ig3,ig4,grtyp)
#include "impnone.cdk"
      integer iun,ni,nj,nk,ip1,ip2,ip3,datev,ig1,ig2,ig3,ig4
      real fld(ni,nj,nk)
      character*12 etiket
      character*4 nomvar
      character*2 typvar
      character*1 grtyp
      external fstlic
      integer fstlic


      integer ier,i
      
      ier = fstlic(fld,iun,ni,nj,nk,datev,etiket,ip1,ip2,ip3,typvar,nomvar,ig1,ig2,ig3,ig4,grtyp)

      if (ier.lt.0) then
        pgsmlic=ier
        return
      endif

      call prefiltre(fld,ni,nj,nomvar,grtyp)
      pgsmlic=ier
      return 
      end
      
*
***s/p scalair  interpolation horizontale d un champ
*               defini par l usager
*     
      subroutine scalair(cnom,  iheur, nniv, niveaux)
#include "impnone.cdk"
#include "defin.cdk"
      external ecritur,pgsmluk,fstinf,fstsui,memoir,fstprm,qaaqr,fstcvt,
     $     fstsel,symetri,imprime,itrouve,messags,pgsmabt
      external cvtr2i
      external liraxez
      integer  pgsmluk, fstinf, fstsui, fstprm, fstcvt, fstsel, fstinl
      integer diesinf, dieslir,diesisincache,res
      integer ezgdef_fmem, ezqkdef, ezsint, ezdefset
      logical skip
*     
*auteur  p. sarrazin  dorval quebec fevrier 82 drpn
*revision 4.0.2
*   conversion des variables hollerith en caractere
*   y. chartier -aout 90- drpn dorval quebec
*revision 5.0.0
*   utilisation de la cuvee 91 des interpolateurs
*   elimination des appels a 'fstcvt' pour convertir etikent
*   y. chartier -mai 1991- drpn dorval quebec
*
*revision 5.2.1
*   utilisation de fstinl au lieu de fstinf-fstsui
*   l'utilisation des deux dernieres avec les grilles Z
*   causait un probleme lorsqu'on lisait les axes
*   y. chartier -oct. 92- drpn dorval quebec
*langage ratfor
*
*objet(scalair)
*              interpolation horizontale des scalaires gz,tt,dd,ww,qq,es.
*              d une grille a une autre pour nniv niveaux
*              ecrire resultat sur fichier standard,ms,sequentiel
*
*librairies
*         -source  armnsrc,drpn
*         -objet   pgsmlib,id=armnpjs.
*
*arguments
*  in   nom    nom du champ 2 caracteres gz.tt.dd.......
*  in   iheur  heure de la variable sur fichier d entre
*  in   nniv   nombre de niveaux
*  in   niveaux table contenant nniv niveaux
*
*appel
*         -via routine champ
*         call scalair(nom, iheur, nniv, niveaux) 
*
*messages 
*         mauvaise directive champ (scalair)
*         aucun niveau specifie dans directive champ
*         record n'existe pas sur fichier d'entre (scalair) 
*         aucune interpolation horizontale champ
*
*
*modules pgsmabt,rfl,fstinf,fstprm,pgsmlir,rgscint,ecritur
*
*-----------------------------------------------------------------
*
#include "llccmm.cdk"
#include "dummys.cdk"
#include "dates.cdk"
#include "grilles.cdk"
#include "indptr.cdk"
#include "lires.cdk"
#include "accum.cdk"
#include "ecrires.cdk"
#include "pairs.cdk"
#include "voir.cdk"
#include "packin.cdk"
#include "gdz.cdk"

      character *12 cetiket
      character *4 cnom,cnomvar,cnomx
      character *2 ctypvar
      character *1 cigtyp
      
      integer nniv,dat,i,nunv,itrouve,key,ii
      integer niveaux(nniv),deet,ig1,ig2,ig3,ig4,iheur
      integer iprs,irec,iunit,jp1,jp2,jp3,ne,ni,nj,nk
      integer cnbits,cdatyp,cswa,clng,cdltf,cubc,extra1,extra2,extra3
      logical sym,symetri
      real fbidon
      real ax, ay
      pointer (axp, ax(*))
      pointer (ayp, ay(*))
*
      integer liste(24000),nrecs
      nunv=0 
*
*


      iunit=1
      cnomx = cnom
      if (cnom.eq.cnomqr) cnom=cnomqq
      
*     
*     
      do iprs = 1,nniv 
*
*  conversion de l etiquette d'entree en caracteres
*
        
        if (etikent(1) .ne. -1) then
          write(cetiket,'(2A4)') (etikent(i), i=1,nwetike)
        else 
          cetiket = '        '
        endif
        
        if (typeent .ne. -1) then
          write(ctypvar, '(A1)') typeent
        else 
          ctypvar = ' ' 
        endif
        
*     identifier numero du record
*
        if (cnom.eq.cnommt) then
          if (.not.mtdone) then
            irec = fstinl(iunit,ni,nj,nk,-1,'            ',-1,-1,-1,' ',cnom,
     $           liste,nrecs,24000) 
            if (nrecs .eq. 0) then
              if (message) then
                write(6,*)
     $               'RECORD FICHIER DE MONTAGNE PAS LA (SCALAIR)'
              endif
              go to 5000
            endif
            
            
            if (nk.gt.1) then
              write(6,*)'******************************************'
              write(6,*)'       PGSM N ACCEPTE PAS UN          '
              write(6,*)' CHAMP DE 3 DIMENSIONS NK>1 ?? 
     $             (MT DANS SCALAIR)'
              write(6,*)'*****************************************'
              call pgsmabt
            endif
 5000       mtdone=.true.
          endif
        else
         if (date .eq. 1) then
            if (date3.eq.-1) then
               date=date2
            else
               call newdate(date, date2, date3, 3)
            endif
         endif

          irec=fstinl(iunit,ni,nj,nk,date,cetiket,niveaux(iprs),iheur,
     $         ip3ent,ctypvar,cnom, liste, nrecs, 24000)
          
          if (nrecs .eq. 24000) then
            print *, 
     $           'LA LIMITE DE 24000 ENREGISTREMENTS A ETE ATTEINTE'
            print 
     $           *, 'CONSULTER LE RESPONSABLE DU PROGRAMME'
          endif
          
          if (nrecs .eq. 0) then
            if (message) then
              write(6,*)
     $             'RECORD N EXISTE PAS SUR FICHIER D ENTRE (SCALAIR)'
            endif
            goto 22000
          endif
          
          if (nk.gt.1) then
            write(6,*)
     $           '************************************************'
            write(6,*)'         PGSM N ACCEPTE PAS UN          ' 
            write(6,*)
     $           ' CHAMP DE 3 DIMENSIONS NK>1 ?? (CHAMP SCALAIR)'
            write(6,*)
     $           '************************************************'
            call pgsmabt 
          endif
        endif
*     
*     
        do ii=1,nrecs
*     
*     identifier parametres
          irec = liste(ii)
          ier=fstprm(irec, dat,deet,npas,ni, nj, nk, cnbits,cdatyp,
     $         jp1,jp2,jp3,ctypvar,cnomvar,cetiket,
     $         cigtyp,ig1,ig2, ig3, ig4, cswa, clng, cdltf, cubc, 
     $         extra1, extra2, extra3)
          if (ier .lt. 0) write(6,*)
     $         ' IER = FSTPRM NEGATIF VOIR SCALAIR'

          if (cnomvar(1:2).eq.'>>'.or.cnomvar(1:2).eq.'^^'.or.cnomvar(1:2).eq.'HY') then
             goto 99999
          endif

*     
*   si la directive de champ emploi tout  champ(tout,tout) on doit faire
*     attention pour les vecteurs u-v car l'interpolation serait scalair
*     on verifie et les interpolations pour les vecteurs ne sont pas
C faite
*     
          do i=1,npair 
             if (cnom.eq.' ') then
                if ((paire(i)(9:10).eq.cnomvar(1:2)).or.
     $               (paire(i)(13:14).eq.cnomvar(1:2)))  then
                   nunv=nunv + 1
                   go to 99999
              endif
            endif
          enddo
*     
*     lire champ
          
          skip = .false.
          
          if (cigtyp.eq.'#'.and.diese.eq.1) then
	     res = diesisincache(irec)
	     if (res.lt.0) then
                key=diesinf(iunit, ni, nj, nk, date, cetiket, jp1, jp2, jp3, ctypvar, cnomvar)
                call hpalloc(tmpif1p,ni*nj,ier,1)
                call hpalloc(axp,ni,ier,1)
                call hpalloc(ayp,nj,ier,1)
                ier = dieslir(iunit, key, tmpif1, ax, ay, grref, ig1ref, ig2ref, ig3ref, ig4ref)
             else
                skip = .true.
             endif
          else
             call hpalloc(tmpif1p,ni*nj,ier,1)
             key = pgsmluk(tmpif1, irec, ni,nj,nk,cnomvar,cigtyp)
          endif
          
*     
          if (cdatyp .eq. 2 .or. cdatyp .eq. 4) then
             call cvtr2i(tmpif1, tmpif1, ni, nj)
          endif
          
          if (printen)  call imprime(cnomvar,tmpif1,ni,nj)
          if (ig1.ne.0) sym = symetri(cnomvar)
*     
*     on ne fait pas d'interpolation si igtyp=grtyp  ig1=lg1  ig2=lg2
*     ig3=lg3  ig4=lg4
*     
          if (.not.skip) then
             if (cigtyp.ne.cgrtyp.or.cigtyp.eq.'Z'.or.
     $            ig1.ne.lg1.or.ig2.ne.lg2.or.ig3.ne.lg3.or.
     $            ig4.ne.lg4.or.li.ne.ni.or.lj.ne.nj) then
*     
*     interpolation
*     
                call hpalloc(tmpif2p,li*lj,ier,1)
                
                if (cigtyp.eq.'#'.and.diese.eq.0) then
                   gdin = ezgdef_fmem(ni, nj, 'Z', grref, ig1ref, ig2ref, ig3ref, ig4ref, ax, ay)
                else
                   gdin = ezqkdef(ni, nj, cigtyp, ig1, ig2, ig3, ig4, iunit)
                endif
                ier = ezdefset(gdout, gdin)
                ier = ezsint(tmpif2, tmpif1)
             else
                tmpif2p = tmpif1p
                if (message) write(6,660) cnom
 660            format(2x,'AUCUNE INTERPOLATION HORIZONTALE CHAMP=',a2)
             endif
*     
*     
*     ecrire sur fichier approprie(std,ms,seq)
*     
             if (cnomx.eq.cnomqr) then
                call qaaqr(tmpif2,li,lj,tmplat)
                cnomvar=cnomqr
             endif
             
             call ecritur(tmpif2,npack,dat,deet,npas,li,lj,1,jp1,jp2,
     $            jp3,ctypvar,cnomvar,cetiket,cgrtyp,lg1,lg2,lg3,lg4)
*     
             if (tmpif2p .ne. tmpif1p) then
                call hpdeallc(tmpif2p,ier,1)
             endif
             call hpdeallc(tmpif1p,ier,1)
*     
          endif
99999     continue
*     
          if (unefois) goto 23000
*     
       enddo
22000 enddo
23000 continue
*     
      if (nunv.gt.0) then
         write(6,666)
 666     format(' AUCUNE INTERPOLATION SUR VARIABLE PAIRE CHAMP(TOUT,TOUT)')
         write(6,668)
 668     format(' ON DOIT UTILISER LE NOM DE LA VARIABLE EX: CHAMP(UU,TOUT)')
         write(6,669)
 669     format(' ATTENTION L INTERPOLATION DES VECTEURS SERA SCALAIRE (!!!)')
*     
      endif
      return 
      end
      
      
      subroutine cvtr2i(rfld, ifld, ni, nj)
      integer ni, nj
      real rfld(ni,nj)
      integer ifld(ni,nj)
      integer i
      
      do j=1,nj
         do i=1,ni
            rfld(i,j) = real(ifld(i,j))
         enddo
      enddo
      
      return
      end 
      
      
*
***s/p champ_seq  Miroir de la directive champ pour fichiers sequentiels
*
#include "defin.cdk"
      subroutine champ_seq (listn,listip1,waitOrGo)
#include "impnone.cdk"
      integer listn(*),listip1(*),waitOrGo
      external ecritur,fstrwd,pgsmlir,fstprm,symetri,fstsel,fstsui,pgsmluk
      external loupneg,loupsou,fstopc,argdims,pgsmabt,imprims,grille2 
      external imprime,messags,fstcvt
      external liraxez
      integer  fstinf,pgsmlir,fstprm,fstopc,fstcvt,fstsel,fstsui,fstrwd,pgsmluk
      integer ezqkdef, ezsint, ezdefset
*
*auteur  Yves Chartier drpn Dorval Quebec Avril 1996
*revision 
*
*langage fortran
*
*objet(champ_seq)
*
*arguments
*  in    listn    liste de nomvar
*  in    listip1  liste de niveau
*  in    waitOrGo commutateur d'accumulation de directives
*
*
*implicites
*
*messages 
*          'mauvais appel a champdif il devrait y avoir 3 arguments'
*
*
*modules  fstinf,memoir,fstprm,pgsmlir,symetry,rgscint,ecritur,argdims
*         imprime,loupsou,pgsmabt
*
*appel     via directive champ_seq(listn, listip1, waitOrGo)
*
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
#include "voir.cdk"
#include "llccmm.cdk"
#include "accum.cdk"
#include "champs.cdk"
#include "indptr.cdk"
#include "grilles.cdk"
#include "lires.cdk"
#include "ecrires.cdk"
#include "dates.cdk"
#include "packin.cdk"
#include "dummys.cdk"
#include "gdz.cdk"
#include "champseq.cdk"
#include "lnkflds.cdk"
#include "heures.cdk"
*
      character*12 etiket
      character*4 nomvar
      character*2 typvar
      character*1 cigtyp
      
      integer ig1,ig2,ig3,ig4,irec,iunit
      integer num1,num2,num3,nloop,deet
      integer ip1,ip2,ip3,i,j,k
      integer ni,nj,nk,nbits,datyp,
     $     swa, lng, dltf, ubc, extra1, extra2, extra3
      integer argdims
      logical symetri,sym,heureok,ip3ok,processed

      real fbidon
      iunit = 1
*     
      if (npar.ne. 3) then
         if (message) then
            write(6,*) 'DIRECTIVE CHAMP_SEQ IL DEVRAIT Y AVOIR 3 ARGUMENTS (CHAMP_SEQ)'
         endif
         return
      endif
  
      if (tmplatp.eq.0) then
         if (message) then
            write(6,*)'GRILLE NON DEFINIE ..GRILLE P.S.(2805)'
         endif
         call grille2(3,51,55,26.,28.,381000.,350.,1) 
      endif
*
*   trouver nombre d'arguments dans une liste (ip1,ip2,ip3) 
*     

      ntitems = ntitems + 1
      if (ntitems.gt.nmaxlist1) then
         print *,'*******************************************************'
         print *,'* LA LIMITE DE 16 DIRECTIVES CHAMP_SEQ A ETE DEPASSEE *'
         print *,'*******************************************************'
         call pgsmabt
      endif

      if (argdims(1).gt.nmaxlist2) then
         print *,'*******************************************************'
         print *,'* LA LIMITE DE 16 NOMS DE VARIABLES A ETE DEPASSEE    *'
         print *,'*******************************************************'
         call pgsmabt
      endif

      if (argdims(2).gt.nmaxlist2) then
         print *,'*******************************************************'
         print *,'* LA LIMITE DE 16 NIVEAUX VERTICAUX A ETE DEPASSEE    *'
         print *,'*******************************************************'
         call pgsmabt
      endif

      nitems1(ntitems) = argdims(1)
      nitems2(ntitems) = argdims(2)
      do i=1,argdims(1)
         write(listnom(ntitems,i),'(A2)') listn(i)
      enddo

      do i=1,argdims(2)
         listniv(ntitems,i) = listip1(i)
      enddo

      if (waitOrGo.eq.WAIT) then
         return
      endif
      
      ier =fstrwd(lnkdiun(1))
      irec=fstsel(1,ni,nj,nk,-1,'        ',-1,-1,-1,' ','  ')
 200  irec = fstsui(1,ni,nj,nk)
      if (irec.ge.0) then
         processed = .false.
         ier = fstprm(irec, date,deet,npas,ni, nj, nk, 
     $        nbits,datyp,
     $        ip1,ip2,ip3,typvar,nomvar,etiket,
     $        cigtyp,ig1,ig2,ig3,ig4,
     $        swa, lng, dltf, ubc, extra1, extra2, extra3)

*         print *,nomvar,typvar,ip1,ip2,ip3,etiket,date
         heureok = .false.
         if (heures(1).eq.-1) then
            heureok=.true.
         else
            do k=1,nhur
               if (ip2.eq.heures(k)) then
                  heureok = .true.
               endif
            enddo
         endif

 100     if (heureok.and..not.processed) then
            do i=1,ntitems
               if (.not.processed) then
                  do j=1,nitems1(i)
                     if (listnom(i,j).eq.nomvar.or.listnom(i,j).eq.' '.and..not.processed) then
                        do k=1,nitems2(i)
                           if (listniv(i,k).eq.ip1.or.listniv(i,k).eq.-1.and..not.processed) then
                              call hpalloc(tmpif1p,ni*nj*nk,ier,1 )
                              call hpalloc(tmpif2p,li*lj,ier,1 )
                              ier=pgsmluk(tmpif1,irec,ni,nj,nk,nomvar,cigtyp)
*     
                              if (nk .gt. 1) then
                                 write(6,*)'***********************************************'
                                 write(6,*)'         PGSM N ACCEPTE PAS UN          '
                                 write(6,*)' CHAMP DE 3 DIMENSIONS NK>1 ?? (CHMPDIF)'
                                 write(6,*)'***********************************************'
                                 call pgsmabt
                              endif
                              
                              gdin = ezqkdef(ni, nj, cigtyp, ig1, ig2, ig3, ig4, iunit, fbidon, fbidon)
                              ier = ezdefset(gdout, gdin)
                              ier = ezsint(tmpif2, tmpif1)
                              
                              call ecritur(tmpif2,npack,date,deet,npas,
     $                             li,lj,1,ip1,ip2,ip3,
     $                             typvar,nomvar,etiket,cgrtyp,lg1,lg2,lg3,lg4)
*     
                              call hpdeallc(tmpif2p,ier,1)
                              call hpdeallc(tmpif1p,ier,1)
                              processed=.true.
                           endif
                        enddo
                     endif
                  enddo
               endif
            enddo
         endif
         goto 200
      endif
      
***  l'interpolation est terminee - On a pass a travers le fichier

      do i=1,ntitems
         do j=1,nitems2(i)
            listnom(i,j) = '  '
            listniv(i,j) = -1
         enddo
         nitems2(i)=0
      enddo
      ntitems=0

      return 
      end
      
*
***s/p epaisur  difference entre 2 champs de hauteur
*
      subroutine epaisur(iheur, npar, niveau)
#include "impnone.cdk"
      external ecritur,fstinf,pgsmlir,memoir,fstprm,pgsmabt,
     $     fstcvt,symetri, imprime,loupsou,fstopc,messags,
     $     liraxez
      integer fstinf,pgsmlir,fstprm,fstopc,fstcvt 
      integer ezsint, ezqkdef, ezdefset
*
*auteur  p.sarrazin janvier 82  drpn dorval p.q. canada
*revision 4.0.2
*
*   conversion des variables hollerith en caracteres
*   y. chartier -aout 90- drpn dorval quebec.
*
*langage ratfor
*
*objet(epaisur)
*          lire sur fichier standard 2 champs de hauteur
*          prendre la difference entre les 2 champs ecrire le
*          resultat sur fichier approprie(standard,ms,seq)
*
*librairies
*         -source  armnsrc,drpn
*         -objet   pgsmlib,id=armnpjs.
*
*arguments
*   in    iheur   heure des champs (gz) 
*   in    npar    nombre de niveaux ( 2)
*   in    niveau  table(2) contenant les 2 niveaux
*
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*messages 
*     record n existe pas sur fichier d entre (epaisur)
*
*modules  fstinf,fstprm,pgsmlir,rgscint,ecritur
*
*appel   via champ
*        call epaisur(iheur,npar,niveau)
*
* - - - -  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
#include "llccmm.cdk"
*
*
#include "voir.cdk"
*
*
#include "accum.cdk"
*
*
#include "param.cdk"
*
*
#include "indptr.cdk"
*
*
#include "grilles.cdk"
*
*
#include "lires.cdk"
*
*
#include "ecrires.cdk"
*
*
#include "dates.cdk"
*
*
#include "packin.cdk"
*
*
#include "gdz.cdk"
*

      character *12 cetiket
      character *4 cnomvar
      character *2 ctypvar
      character*1 cigtyp
      
      real fbidon
      integer iunit
      
      integer i, niveau(2),iheur,npar,ni,nj,nk,jp1,jp2,jp3,ig1,iopc,
     $     ig2,ig3,ig4,irec1,irec2,num1,num2,nn,cnbits,cdatyp,cswa,clng,
     $     cdltf,cubc,extra1,extra2,extra3
      
      
      logical sym,symetri
      iunit = 1
*     
*     heure ou iheur dans cette routine ne peut-etre -1 heure(tout) pas valide
*     
      if (iheur.eq.-1) then
         write(6,*)
     $        'HEURE NE PEUT-ETRE -1(TOUT/ALL) AVEC DIRECTIVE EPAIS'
         call pgsmabt
      endif
*
*  identifier le numero de chaque record avec fstinf
*
         if (date .eq. 1) then
            if (date3.eq.-1) then
               date=date2
            else
               call newdate(date, date2, date3, 3)
            endif
         endif


*
*  modification de hollerith a caractere
*
      if (etikent(1) .ne. -1) then
         write(cetiket,'(2A4)') (etikent(i), i=1,nwetike)
      else 
         cetiket = '        '
      endif
      
      if (typeent .ne. -1) then
         write(ctypvar, '(A1)') typeent
      else 
         ctypvar = ' '
      endif
      
      
      cigtyp = ' '
      
*     
      irec1=fstinf(1,ni,nj,nk,date,cetiket,niveau(1),iheur,ip3ent,
     $     ctypvar,'GZ')
      irec2=fstinf(1,ni,nj,nk,date,cetiket,niveau(2),iheur,ip3ent,
     $     ctypvar,'GZ')
      if (irec2 .lt. 0 .or. irec1 .lt. 0) then
         write(6,*)'RECORD N EXISTE PAS SUR FICHIER D ENTRE (EPAISEUR)'
         return
      endif
      
      if (nk.gt.1) then
         write(6,*)'**************************************************'
         write(6,*)'         PGSM N ACCEPTE PAS UN          '
         write(6,*)' CHAMP DE 3 DIMENSIONS NK>1 ?? (EPAISUR)'
         write(6,*)'**************************************************'
         call pgsmabt
      endif
*     
*     identifier parametres pour champ 1
*     
      ier = fstprm( irec1, dat,deet,npas,ni, nj, nk, cnbits,cdatyp,
     $     jp1,jp2, jp3,ctypvar,cnomvar,cetiket,cigtyp,
     $     ig1,ig2,ig3,ig4,cswa, clng, cdltf, cubc, 
     $     extra1, extra2, extra3)

      if (ier .lt. 0) then
         write(6,*)' IER = FSTPRM NEGATIF VOIR EPAISUR'
      endif
*     
*     verifier si grille gaussienne ni doit etre pair
*     
      if (cigtyp.eq.'G'.and.mod(ni,2).ne.0) then
         call messags(ni)
      endif
      
*     
*     
*     lire champ no 1
*     
      call hpalloc(tmpif1p,ni*nj,ier,1)
      if (.not.message) then
         iopc= fstopc('TOLRNC','DEBUGS',.true.) 
      endif

      if (date .eq. 1) then
         if (date3.eq.-1) then
            date=date2
         else
            call newdate(date, date2, date3, 3)
         endif
      endif
*     
      num1 = pgsmlir(tmpif1,1,ni,nj,nk,date,cetiket,jp1,jp2,jp3,
     $     ctypvar, 'GZ', cigtyp) 
*
      if (printen) then
         call imprime(cnomvar,tmpif1,ni,nj)
      endif
*
*     identifier parametres pour champ 2
*     
      ier = fstprm( irec2, dat,deet,npas,ni, nj, nk, cnbits,cdatyp,
     $     jp1,jp2, jp3,ctypvar,cnomvar,cetiket,cigtyp, 
     $     ig1,ig2,ig3,ig4, cswa,clng,cdltf,cubc,extra1,extra2,extra3)
      if (ier .lt. 0) then
         write(6,*)' IER = FSTPRM NEGATIF VOIR EPAISUR'
      endif
*     
*     verifier si grille gaussienne ni doit etre pair
*     
      if (cigtyp.eq.'G'.and.mod(ni,2).ne.0)  then
         call messags(ni)
      endif
*     
*     lire champ 2
*     
      call hpalloc(tmpif2p,max0(li*lj,ni*nj),ier,1)
      if (.not.message)  then
         iopc= fstopc('TOLRNC','DEBUGS',.true.) 
      endif

      if (date .eq. 1) then
         if (date3.eq.-1) then
            date=date2
         else
            call newdate(date, date2, date3, 3)
         endif
      endif

      num2 = pgsmlir(tmpif2,1,ni,nj,nk,date,cetiket,jp1,jp2,jp3,
     $     ctypvar, 'GZ', cigtyp)
      if (printen)  call imprime(cnomvar,tmpif1,ni,nj)
*
*  difference entre les deux champs
*
      nn = ni*nj
      call loupsou(tmpif1,tmpif2,nn) 
*
*     interpolation horizontale
*     
      if (ig1.ne.0) sym=symetri(cnomvar)

      if (cgrtyp.eq.'*') then
         call chkenrpos(1,2,ig1,ig2,ig3)
         call ecritur(tmpif1,npack,dat,deet,npas,ni,nj,1,
     $        niveau(1),niveau(2),iheur,
     $        ctypvar,'DZ',cetiket,cigtyp,ig1,ig2,ig3,ig4)
      else
         gdin = ezqkdef(ni, nj, cigtyp, ig1, ig2, ig3, ig4, iunit)
         ier = ezdefset(gdout, gdin)
         ier = ezsint(tmpif2, tmpif1)
*     
*     
         jp1 = niveau(1)
         jp2 = niveau(2)
         jp3 = iheur   
*     
*     ecrire sur fichier standard,ms,sequentiel
*     
         call ecritur(tmpif2,npack,dat,deet,npas,li,lj,1,jp1,jp2,jp3,
     $        ctypvar,'DZ',cetiket,cgrtyp,lg1,lg2,lg3,lg4)

      endif
*     function qui identifie si la variable est symetrique( h.n. - h.s.)
*     le test n'est pas applicable pour une situation  globale
*     
      call hpdeallc(tmpif1p,ier,1)
      call hpdeallc(tmpif2p,ier,1)
*     
      return 
      end
      
*
      subroutine loupmir(sortie,entre,nombre)
#include "impnone.cdk"
*
*AUTEUR P. SARRAZIN DORVAL QUEBEC CANADA (DRPN)
*
*OBJET(LOUPMIR)
*         LOUPMIR - TRANSFER LA MOITIE DU CHAMP DEFINI DANS L'AUTRE
*                   MOITIE RENVERSER COMME UN MIROIR
*
*         LOUPTRA - TRANSFER UN CHAMP DANS UN AUTRE
*
*         LOUPIN1 - INITIALISE UN CHAMP AVEC LA VALEUR 1
*
*         LOUPSOU - SOUSTRAIRE DEUX CHAMPS
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*ARGUMENTS
*   OUT   SORTIE - RESULTAT DE L'OPERATION SUR CHAMP(NOMBRE)
*   IN    ENTRE  - CHAMP QUI PEUT SERVIR AU CALCUL
*   IN    NOMBRE - NOMBRE DE POINTS DANS LE CHAMP EXCEPTE LOUPTRA OU
*                  NOMBRE EST (MAXIMUM) LA MOITIE DU NOMBRE DES POINTS
*
*APPEL
*     - VIA GRILLE,COUPZM,LIREN,EPAISUR 
*     - CALL LOUPMIR(SORTIE,ENTRE,NOMBRE)
*     - CALL LOUPTRA(SORTIE,ENTRE,NOMBRE)
*     - CALL LOUPIN1(SORTIE,ENTRE,NOMBRE)
*     - CALL LOUPSOU(SORTIE,ENTRE,NOMBRE)
*
*--------------------------------------------------------------------------
*
#include "voir.cdk"
*
*
*
      real sortie(1),entre(1)
      integer nombre,nombpl1,i
*     
*            TRANSFER LA MOITIE DU CHAMP DANS L'AUTRE
*
*
      nombpl1=nombre + 1
*
      do i=1,nombre
         sortie(i + nombre) = entre(nombpl1 - i)
      enddo
*     
      return
*     
*------------------------------------------------------------
*
      entry louptra(sortie,entre,nombre)
*
*
*              TRANSFER CHAMP 
*
      do i=1,nombre
         sortie(i)=entre(i)
      enddo
*     
      return
*-------------------------------------------------------------
*
       entry loupin1(sortie,entre,nombre)
*
*
*           INITIALISE LE CHAMP SORTIE AVEC 1.0
*
       do i=1,nombre
          sortie(i)=1.0
       enddo
*     
       return
*-----------------------------------------------------------
*
       entry loupsou(sortie,entre,nombre)
*
*
*           SOUSTRAIT DEUX CHAMPS
*
       do i=1,nombre
          sortie(i)=entre(i) - sortie(i)
       enddo
*     
       return
       end
***S/P PGSMLIR
*     
      integer function pgsmlir(fld,iun,ni,nj,nk,datev,etiket,
     $     ip1,ip2,ip3,typvar,nomvar,grtyp)
#include "impnone.cdk"
      integer iun,ni,nj,nk,ip1,ip2,ip3,datev,ig1,ig2,ig3,ig4
      real fld(ni,nj,nk)
      character*12 etiket
      character*4 nomvar
      character*2 typvar
      character*1 grtyp
      external fstlir
      integer fstlir


      integer ier,i
      
      ier = fstlir(fld,iun,ni,nj,nk,datev,etiket,ip1,ip2,ip3,typvar,nomvar)

      if (ier.lt.0) then
        pgsmlir=ier
        return
      endif

      call prefiltre(fld,ni,nj,nomvar,grtyp)
      pgsmlir=ier
      return 
      end
      
***s/p qqqintx  choisir le degre de l'interpolation
      subroutine qqqintx(ordre)
      integer ordre
*
*auteur  Y.Chartier Dec 91
*    Utilise le nouveau dispatcher de fscint.f pour ajuster
*    le degre d'interpolation
*
*
*  e      ordre     ordre de l'interpolation 0,1, ou 3
*
*implicites
**
      character*8 op 
      

      if (.not.(ordre .eq. 100 .or.ordre .eq. 1.or.ordre .eq. 3)) then
         print *,
     $      '<QQQINTX>: MAUVAISE VALEUR - VALEUR DEVRAIT ETRE 0, 1 OU 3'
	 print *, '<QQQINTX>: ORDRE D''INTERPOLATION INITIALISE A 3'
         call ezsetopt('interp_degree','cubic')
      else
	 if (ordre .eq. 100) then
            call ezsetopt('interp_degree', 'nearest')
	 else if (ordre. eq. 1) then
            call ezsetopt('interp_degree', 'linear')
         else
            call ezsetopt('interp_degree', 'cubic')
         endif
      endif
      
      return
      end
      
      
      integer function chkenrpos(luin, luout, ip1, ip2, ip3)
      implicit none
      
#include "indptr.cdk"

      real ax, ay
	
      pointer (axp, ax(*))
      pointer (ayp, ay(*))

      integer luin, luout, ip1, ip2, ip3
      integer lip1, lip2, lip3
      
      integer fstinf, fstluk, fstecr, fstprm
      external fstinf, fstluk, fstecr, fstprm
      
      integer ni1, nj1, nk1, ni2, nj2, nk2
      integer ier,ier1, ier2
      
      character*2 typvarx, typvary, grtyp, grref
      character*12 etikx, etiky
      character*4 nomx, nomy
      character*24 chaine
      integer  cdatyp
      integer dateo, deet, npas, nbits,datyp, ig1, ig2, ig3,
     $     ig1ref, ig2ref, ig3ref, ig4ref, 
     $     swa, lng, dltf, ubc, extra1, extra2, extra3, npak

      
      if (mode.eq.1) then
         ier1 = fstinf(luout, ni1, nj1, nk1, -1, '            ', ip1, ip2, ip3, ' ', '>>  ')
         ier2 = fstinf(luout, ni1, nj1, nk1, -1, '            ', ip1, ip2, ip3, ' ', '^^  ')
         
         if (ier1.ge.0.and.ier2.ge.0) then
            chkenrpos = 0
            return
         endif
         
      endif
      
      ier1 = fstinf(luin, ni1, nj1, nk1, -1, '            ', ip1, ip2, ip3, '  ', '>>  ')
      ier2 = fstinf(luin, ni1, nj1, nk1, -1, '            ', ip1, ip2, ip3, '  ', '^^  ')
      
      if (ier1.lt.0.or.ier2.lt.0) then
         chkenrpos = -1
         return
      endif
      
      ier = fstprm(ier1, dateo, deet, npas, ni1, nj1, nk1, nbits,
     $     datyp, lip1, lip2, lip3, typvarx, nomx, etikx,
     $     grref, ig1ref, ig2ref, ig3ref, ig4ref, 
     $     swa, lng, dltf, ubc, extra1, extra2, extra3)
      
      ier = fstprm(ier2, dateo, deet, npas, ni2, nj2, nk2, nbits,
     $     datyp, lip1, lip2, lip3, typvary, nomy, etiky,
     $     grref, ig1ref, ig2ref, ig3ref, ig4ref, 
     $     swa, lng, dltf, ubc, extra1, extra2, extra3)
      
      call hpalloc(axp,ni1*nj1*nk1,ier,1)
      call hpalloc(ayp,ni2*nj2*nk2,ier,1)
      
      ier = fstluk(ax, ier1, ni1, nj1, nk1)
      ier = fstluk(ay, ier2, ni2, nj2, nk2)
      
      call ecritur(ax,-nbits,dateo,deet,npas,ni1,nj1,nk1,
     $     lip1,lip2,lip3, 
     $     typvarx,nomx,etikx,grref,ig1ref,ig2ref,ig3ref,ig4ref)
      
      call ecritur(ay,-nbits,dateo,deet,npas,ni2,nj2,nk2,
     $     lip1,lip2,lip3, 
     $     typvary,nomy,etiky,grref,ig1ref,ig2ref,ig3ref,ig4ref)
      

      call hpdeallc(axp, ier, 1)
      call hpdeallc(ayp, ier, 1)
      
      chkenrpos = 0

      return
      end
      subroutine chk_hy(lu_in, lu_out)
      implicit none
      
      integer lu_in, lu_out
      external fstinl,fstprm, fstecr, fstluk
      integer fstinl, fstprm, fstecr, fstluk
      integer liste(256)
      logical rewrit
      
      character *12 cetiket
      character *4 cnomvar,cnomx
      character *2 ctypvar
      character *1 cigtyp
      
      integer dateo,i
      integer deet,ig1,ig2,ig3,ig4
      integer irec,ip1,ip2,ip3,ni,nj,nk,nrecs,ier,npas
      integer nbits,cdatyp,cswa,clng,cdltf,cubc,extra1,extra2,extra3
      real hydata(4096)

      irec=fstinl(lu_in,ni,nj,nk,-1,'            ',-1,-1,-1,'  ','HY  ', liste, nrecs, 256)

      rewrit = .true.
      do i=1,nrecs
         irec = liste(i)
         ier=fstprm(irec, dateo,deet,npas,ni, nj, nk, nbits,cdatyp,
     $        ip1,ip2,ip3,ctypvar,cnomvar,cetiket,
     $        cigtyp,ig1,ig2, ig3, ig4, cswa, clng, cdltf, cubc, 
     $        extra1, extra2, extra3)
         ier=fstluk(hydata, irec, ni, nj, nk)
         ier = fstecr(hydata,hydata,-nbits,lu_out,dateo,deet,npas,
     $           ni,nj,nk,ip1,ip2,ip3,ctypvar,cnomvar,cetiket,
     $           cigtyp,ig1,ig2,ig3,ig4,cdatyp,rewrit )

      enddo
         

      return
      end
      subroutine fillcoord(lat,lon,coord,ncoords)
#include "impnone.cdk"
      real lat(*),lon(*),coord(512,2)
      integer ncoords
      
      integer i

      do i=1,ncoords
         lat(i) = coord(i,1)
         lon(i) = coord(i,2)
         enddo
      return
      end
*
***S/P GRLALON   CALCUL LATITUDE LONGITUDE DE CHAQUE PT D'UNE GRILLE LATLON
*
      subroutine grlalon(nni,nnj,p1,p2,p3,p4)
#include "impnone.cdk"
*
*AUTEUR   - P. SARRAZIN JANVIER 87 DRPN DORVAL P.Q. CANADA
*
*LANGAGE - RATFOR
*
*OBJET(GRLALON)
*          CALCULER LA LATITUDE ET LA LONGITUDE DE TOUS LES POINTS
*          DE LA GRILLE DE SORTIE LATLON INTERVAL REGULIER TYPE "L"
*
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*------------------------------------------------------
       external memoir,pgsmabt,grll,cigaxg,cxgaig,messags
*
*
#include "lires.cdk"
*
*
#include "ecrires.cdk"
*
*
#include "llccmm.cdk"
*
*
#include "packin.cdk"
*
*
#include "charac.cdk"
*
*
#include "indptr.cdk"
*
*
#include "grilles.cdk"
*
*
#include "voir.cdk"
*
       external ezqkdef
       integer ezqkdef

       integer nni,nnj,ier
       real p1,p2,p3,p4,pp1,pp2,pp3,pp4 
*     
       li=nni 
       lj=nnj 
*
*   RESERVER MEMOIR POUR LATITUDE ET LONGITUDE ET CALL ECRIRE (IWRK)
*
       call hpalloc(tmplatp,nni*nnj,ier,1)
       call hpalloc(tmplonp,nni*nnj,ier,1)
*
*
*   RECALCUL  LAT,LONG,DELTA LAT,DELTA LONG
*   MEME VALEUR A L'ENTRE COMME A LA SORTIE
*
*
       cgrtyp='L'
       call cxgaig(cgrtyp,lg1,lg2,lg3,lg4,p1,p2,p3,p4)
       call cigaxg(cgrtyp,pp1,pp2,pp3,pp4,lg1,lg2,lg3,lg4)
*     
       gdout = ezqkdef(li,lj,cgrtyp,lg1,lg2,lg3,lg4,0)
       return
       end 
*
***S/P    CHAQUE PT D'UN CHAMP LU EST MI AU CARRE DANS ACCUMULATEUR
*
      subroutine lrsmde(nom, type, idat, niv, ihr, ip3, etiqet)
#include "impnone.cdk"
*
*AUTEUR   P. SARRAZIN  DORVAL QUEBEC CANADA (DRPN)
*
*LANGAGE RATFOR
*
*OBJET(LRSMDE)
*         LIRE UN CHAMP SUR FICHIER D'ENTRE OU DE SORTI ET SAUVE DANS 
*         L'ACCUMULATEUR CHAQUE PT AU CARRE ET LES DIRECTIVES SUIVANTES
*         LIRMODE OU LIRMODS AJOUTERONT CHAQUE CHAMP(PT AU CARRE) A
*         L'ACCUMULATEUR LA SOMME DES CHAMPS EST GARDER DANS L'ACCUMULATEUR
*         ET PEUT ETRE SAUVE PAR LA DIRECTIVE ECRITS.
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*ARGUMENTS
*   IN   NOM     NOM DU CHAMP "GZ","TT"...LCAR(GZ)
*   IN   TYPE    TYPE DE CHAMP  "P"=PREVISION   "A"=ANALYSE 
*   IN   NIV     NIVEAU DU CHAMP 500MB....
*   IN   IHR     HEURE DU CHAMP  (IP2)
*   IN   IP3     LIBRE A L'USAGER ET COMPTEUR POUR MOYENNE UTILISER PAR ECRITS
*   IN   ETIQET  ETIQETTE 10 CARACTERES
*
*
*MESSAGES 
*         RECORD N'EXISTE PAS SUR FICHIER (FSTINF DANS LRSMDE-LRSMDS) 
*         RECORD N'EXISTE PAS (LIRE DANS ROUTINE LRSMDE-LRSMDS)
*
*MODULES
*        FSTINF,PGSMABT,FSTPRM,MEMOIR,PGSMLIR
*
*APPEL   VIA DIRECTIVE
*        LIRMDE(NOM, TYPE, IDAT, NIV, IHR, IP3, ETIQET)
*        LIRMDS(NOM, TYPE, IDAT, NIV, IHR, IP3, ETIQET)
*
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
#include "llccmm.cdk"
#include "voir.cdk"
#include "accum.cdk"
#include "chck.cdk"
#include "lires.cdk"
#include "ecrires.cdk"
#include "indptr.cdk"
*
      external fstinf,pgsmlir,memoir,fstprm,pgsmabt,imprime,
     $     fstopc,messags,fstcvt
      integer fstinf,pgsmlir,fstprm,fstopc,fstcvt
*     
      character *12 cetiket
      character *4 cnomvar
      character *2 ctypvar
      character *1 cigtyp
      integer etiqet(2),idat,ihr,iip3,ip3,irec1,
     $     iunit,niv,nom,num1,type 
      integer inomb,i,iopc 
      integer cnbits,cdatyp,cswa, clng,cdltf,cubc,extra1,extra2,extra3
      integer argdims, letiket(3)
      external argdims
*     
      iunit=1
      iip3=ip3
      if (ip3.eq.4095) iip3=-1
*     
*     MODIFICATION DE HOLLERITH A CARACTERE
*     
      cnomvar = '    '
      ctypvar = '  '
      cetiket = '            '
      cigtyp  = ' '

      letiket(1) = etiqet(1)
      letiket(2) = "    "
      letiket(3) = "    "
      if (argdims(7).gt.1) then 
         letiket(2) = etiqet(2)
      endif
      if (argdims(7).gt.2) then 
         letiket(3) = etiqet(3)
      endif

 100  ier = fstcvt(    nom,   type, letiket ,    -1, 
     $             cnomvar,ctypvar, cetiket, cigtyp,     .true.) 
      irec1=fstinf(iunit,nni,nnj,nnk,idat,cetiket,niv,ihr,iip3,
     $     ctypvar,cnomvar)
      if (irec1 .lt. 0)   then
         write(6,*)' RECORD N EXISTE PAS (FSTINF LIRMDE-LIRMDS)'
         call pgsmabt
      endif

*      if (nnk.gt.1)   then
*         write(6,*)'***************************************************'
*         write(6,*)'         PGSM N ACCEPTE PAS UN          '
*         write(6,*)' CHAMP DE 3 DIMENSIONS NK>1 ?? (LIRMDE-LIRMDS)'
*         write(6,*)'***************************************************'
*         call pgsmabt
*      endif
*     
      ichck=1
*     
*     
      ier = fstprm( irec1,idatt,ideet,npas,nni,nnj,nnk,
     $     cnbits,cdatyp,
     $     jpp1,jpp2,jpp3,ctypvar,cnomvar,cetiket,cigtyp,igg1,igg2,
     $     igg3,igg4,cswa, clng, cdltf, cubc, extra1, extra2, extra3)
      if (ier .lt. 0) write(6,*)' IER = FSTPRM NEGATIF VOIR LIRMDE'
*     
*     MODIFICATION DE CARACTERE A HOLLERITH
*     
      cnumv = cnomvar
      ctypv = ctypvar
      cetik = cetiket
      cigty = cigtyp
*     
*     VERIFIER SI GRILLE GAUSSIENNE NI DOIT ETRE PAIR
*     
      if (cigtyp.eq.'G'.and.mod(nni,2).ne.0)  call messags(nni)
*     
*     
      inomb=nni*nnj*nnk
*     
      if (.not.message) iopc= fstopc('TOLRNC','DEBUGS',.true.) 
*     
*     
*      if (if9.eq.1)  then
*         num1=pgsmlir(tmpif0,iunit,nni,nnj,nnk,idat,cetiket,jpp1,
*     $        jpp2,jpp3,ctypvar,cnomvar,cigtyp)
*         if (num1 .lt.0) then
*            write(6,*) 'RECORD N EXISTE PAS LIRE (LIRMDE-LIRMDS)' 
*            call pgsmabt
*         endif
*         
*         if (printen)  call imprime(cnomvar,tmpift,nni,nnj)
*         do i=1,inomb
*            tmpif0(i)=(tmpift(i))**2 + tmpif0(i)
*         enddo
*     
*         if (printsr)  then
*            call imprime(cnomvar,tmpif0,nni,nnj)
*         endif
*         icnt = icnt + 1
*      endif
*     
*      if (if9.eq.0) then
*     
*     ALLOCATION DE LA MEMOIRE
*     
         call hpalloc(tmpif0p,nni*nnj*nnk,ier,1)
*         call hpalloc(tmpiftp,nni*nnj*nnk,ier,1)
*     
*     SI COMPTEUR .NE. 4095 ICNT=1
*     
         icnt=1
         if (iunit.eq.1.and.ip3.eq.4095)  icnt=jpp3
*     
         if (iunit.eq.2.and.ip3.eq.4095)  icnt=jpp3
*     
         num1 = pgsmlir(tmpif0,iunit,nni,nnj,nnk,idat,cetiket,jpp1, 
     $        jpp2,jpp3,ctypvar,cnomvar,cigtyp)
         if (num1 .lt. 0)  then
            write(6,*) 'RECORD N EXISTE PAS LIRE (LIRSMDE-LIRSMDS)'
            call pgsmabt
         endif
         if (printen)  call imprime(cnomvar,tmpif0,nni,nnj)
*     
*         if9=1
         do i=1,inomb
            tmpif0(i)=tmpif0(i)*tmpif0(i)
         enddo
*      endif
*     
*     
      return 
*     
      entry lrsmds(nom, type, idat, niv, ihr, ip3, etiqet)
*     
      iunit=2
      iip3=ip3
      if (ip3.eq.4095) iip3=-1
*     
      go to 100
*     
      end
      
***S/P PGSMLUK 
*     
      integer function pgsmluk(fld,key,ni,nj,nk,nomvar,grtyp)
#include "impnone.cdk"
      integer key,ni,nj,nk
      real fld(ni,nj,nk)
      character*4 nomvar
      character*1 grtyp
      external fstluk
      integer fstluk


      integer ier,i
      
      ier = fstluk(fld,key,ni,nj,nk)

      if (ier.lt.0) then
        pgsmluk=ier
        return
      endif

      call prefiltre(fld,ni,nj,nomvar,grtyp)
      pgsmluk=ier
      return 
      end
      
      subroutine setxtrap(val)
#include "impnone.cdk"

      integer val
      
      integer voisin, oui, abort, valeur, maximum, minimum
      parameter (voisin  =   100)
      parameter (oui     =   1)
      parameter (maximum =   4)
      parameter (minimum =   5)
      parameter (valeur  =   6)
      parameter (abort   =  13)
      
      integer n, i, j
      integer ival
      real    rval
      
      character*8 op,v
      
      equivalence (ival, rval)
      
      ival = val
      
      op = 'EXTRAP'
      
      if (val .ne. voisin .and. val .ne. minimum .and. val .ne. maximum 
     $     .and. val .ne. abort .and. val .ne. oui) then
         v = 'VALEUR'
         call ezsetval('extrap_value', rval)
         call ezsetopt('extrap_degree', 'value')
      else
         if (val .eq. 100) then
            call ezsetopt('extrap_degree', 'NEAREST')
            v = '0'
         else if (val .eq. 1) then
            call ezsetopt('extrap_degree', 'LINEAR')
            v = '1'
         else if (val .eq. 3)  then
            call ezsetopt('extrap_degree', 'CUBIC')
            v = '3'
         else if (val .eq. minimum) then
            v = 'MINIMUM'
            call ezsetopt('extrap_degree', v)
         else if (val .eq. maximum) then
            v = 'MAXIMUM'
            call ezsetopt('extrap_degree', v)
         else 
            v = 'ABORT'
            call ezsetopt('extrap_degree', v)
         endif
      endif
      
      
      return
      end

*
***s/p chmpdif  interpole difference entre deux champs
*
#include "defin.cdk"
      subroutine chmpdif (noment,nomsrt,ip1tab,ip2tab,ip3tab,ip1s, ip2s, ip3s)
#include "impnone.cdk"
      external ecritur,fstinf,pgsmlir,memoir,fstprm,symetri
      external loupneg,loupsou,fstopc,argdims,pgsmabt,imprims,grille2 
      external imprime,messags,fstcvt
      external liraxez
      integer  fstinf,pgsmlir,fstprm,fstopc,fstcvt
      integer ezqkdef, ezsint, ezdefset
      integer ip1s, ip2s, ip3s
*
*auteur  p.sarrazin juillet 86  drpn dorval p.q. canada
*revision 
*    4.0.2 conversion des variables hollerith en caracteres 
*          y. chartier aout 90 drpn dorval quebec 
*    5.2   Support des grilles sources Z
*    5.7.7 npas et deet prennent la valeur du premier champ
*
*langage ratfor
*
*objet(chmpdif)
*          extraire la difference entre deux champs par rapport
*          a ip1, ip2, ou ip3 determine par l'usager: 
*          chmpdif ("gz","dz",[500,1000],6,0) liste sur ip1 
*          chmpdif ("pr","pr",0,[0,12],0) liste sur ip2
*          chmpdif ("tz","zt",0,12,[1,2,3,4] liste sur ip3
*          on peut changer le nom du resultat sur le fichier
*          de sortie apres interpolation de la difference
*          avec routine fstinf on extrait le record necessaire pour
*          routine fstprm qui identifie les parametres utilises
*          par routine lire
*          on reserve la memoire pour les deux champs de travail
*          routine ecritur identifit la sorte de fichier utilise
*          pour ecrire
*
*librairies
*         -source  armnsrc,drpn
*         -objet   pgsmlib,id=armnpjs.
*
*arguments
*  in    noment  nom du champ sur fichier d'entre 
*  out   nomsrt  nom du champ sur fichier de sorti defaut=-1
*                nomsrt=noment
*  in    ip1tab  peut etre une liste nombre pair ou le niveau du
*                champ d'entre
*  in    ip2tab  peut etre une liste nombre pair ou l'heure du
*                champ d'entre
*  in    ip3tab  peut etre une liste nombre pair valeur determinee
*                par l'usager sur le champ d'entre
*
*
*implicites
*
*messages 
*          'mauvais appel a champdif il devrait y avoir 5 arguments'
*          'record n existe pas sur fichier d entre (chmpdif)'
*
*modules  fstinf,memoir,fstprm,pgsmlir,symetry,rgscint,ecritur,argdims
*         imprime,loupsou,pgsmabt
*
*appel     via directive chmpdif (noment,nomsrt,ip1tab,ip2tab,ip3tab) 
*
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
#include "voir.cdk"
#include "llccmm.cdk"
#include "accum.cdk"
#include "champs.cdk"
#include "indptr.cdk"
#include "grilles.cdk"
#include "lires.cdk"
#include "ecrires.cdk"
#include "dates.cdk"
#include "packin.cdk"
#include "dummys.cdk"
#include "gdz.cdk"
*
      character*12 cetiket
      character*4 cnoment, cnomsrt
      character*2 ctypvar
      character*1 cigtyp
      
      integer ig1,ig2,ig3,ig4,irec1,irec2
      integer jp1,jp2,jp3,jp01,jp02,jp03,jp11,jp12,jp13,ni,nj,nk,nn
      integer lesips(3),jp(3)
      integer ip1tab(40),ip2tab(40),ip3tab(40),noment,nomsrt
      integer num1,num2,num3,nloop,dat1,dat2,deet1,deet2,npas1,npas2 
      integer datsrt,deetsrt,npassrt,i,j,k,ii,jj,kk,iloop,n
      integer ni1,ni2,nj1,nj2,nk1,nk2,cnbits,cdatyp,
     $     cswa, clng, cdltf, cubc, extra1, extra2, extra3
      integer argdims
      logical symetri,sym
      integer iunit
      real fbidon

*     
      iunit = 1
      if (npar.lt. 5) then
         if (message) then
            write(6,*)
     $     'DIRECTIVE CHMPDIF IL DEVRAIT Y AVOIR AU MOINS 5 ARGUMENTS (CHMPDIF)'
         endif
         return
      endif
  
      if (tmplatp.eq.0.and.cgrtyp.ne.'*') then
         if (message) then
            write(6,*)'GRILLE NON DEFINIE ..GRILLE DE DEFAUT P.S.(2805)'
         endif
         ngr=8
         call grille2(3,51,55,26.,28.,381000.,350.,1) 
      endif
*
*   trouver nombre d'arguments dans une liste (ip1,ip2,ip3) 
*     
      num1=argdims(3)
      num2=argdims(4)
      num3=argdims(5)
*     
      nloop=0
*     
      if (num1.gt.1) nloop=num1 
      if (num2.gt.1) nloop=num2 
      if (num3.gt.1) nloop=num3 
*     
      if (nloop.eq.0) then
         write(6,*)
     $        ' AUCUNE LISTE [IP1], [IP2], [IP3] DIRECTIVE CHMPDIF'
         return
      endif
*
*     verifier si il ,y a plus d'une liste 
*     
      if (num1.gt.1.and.num2.gt.1) then
         write(6,*)' IP1 ET IP2 CONTIENNENT UNE LISTE DE VARIABLES'
         write(6,*)' VERIFIER DIRECTIVE CHMPDIF'
         return
      endif
  
      if (num1.gt.1.and.num3.gt.1) then
         write(6,*)' IP1 ET IP3 CONTIENNENT UNE LISTE DE VARIABLES'
         write(6,*)' VERIFIER DIRECTIVE CHMPDIF'
         return
      endif

      if (num2.gt.1.and.num3.gt.1) then
         write(6,*)' IP2 ET IP3 CONTIENNENT UNE LISTE DE VARIABLES'
         write(6,*)' VERIFIER DIRECTIVE CHMPDIF'
         return
      endif

*     execution de chaque paire dans la liste
*     
      do iloop=1,nloop,2
         if (num1.gt.1) then
            i=iloop
            ii=iloop+1 
            j=1
            jj=1
            k=1
            kk=1
         endif
*     
         if (num2.gt.1) then
            j=iloop
            jj=iloop+1 
            i=1
            ii=1
            k=1
            kk=1
         endif
*     
         if (num3.gt.1) then
            k=iloop
            kk=iloop+1 
            j=1
            jj=1
            i=1
            ii=1
         endif
*     
         if (date .eq. 1) then
            if (date3.eq.-1) then
               date=date2
            else
               call newdate(date, date2, date3, 3)
            endif
         endif

*     
*     identifier le numero de chaque record avec fstinf
*     
*     modification de hollerith a caractere
*     
         write(cnoment,'(A2)') noment
         write(cnomsrt,'(A2)') nomsrt
         
         if (etikent(1) .ne. -1) then
            write(cetiket,'(2A4)') (etikent(n), n=1,nwetike)
         else 
            cetiket = '        '
         endif
         
         if (typeent .ne. -1) then
            write(ctypvar, '(A1)') typeent
         else 
            ctypvar = ' '
         endif
         
         
         irec1=fstinf(1,ni1,nj1,nk1,date,cetiket,ip1tab(i),ip2tab(j),
     $        ip3tab(k),ctypvar,cnoment)
         irec2=fstinf(1,ni2,nj2,nk2,date,cetiket,ip1tab(ii),ip2tab(jj),
     $        ip3tab(kk),ctypvar,cnoment)
         if (irec2 .lt. 0 .or.irec1 .lt. 0) then
          write(6,*)'RECORD N EXISTE PAS SUR FICHIER D ENTRE (CHMPDIF)'
          write(6,*)' VERIFIER NOM,IP1,IP2,IP3 SUR DIRECTIVE CHMPDIF'
         return
         endif
*     
*     
*     
         if (nk2 .gt. 1 .or. nk1.gt.1  ) then
            write(6,*)'***********************************************'
            write(6,*)'         PGSM N ACCEPTE PAS UN          '
            write(6,*)' CHAMP DE 3 DIMENSIONS NK>1 ?? (CHMPDIF)'
            write(6,*)'***********************************************'
            call pgsmabt
         endif
*     
*     verifier dimension des deux champs d'entre
*     
         if (ni1.ne.ni2.or.nj1.ne.nj2.or.nk1.ne.nk2) then
            write(6,*)' DIMENSION DES DEUX CHAMPS DE CHMPDIF DIFFERENT'
            write(6,*)' VERIFIER FICHIER D ENTREE NI, NJ, NK'
            return
         endif
*     
*     
*     
*     identifier parametres pour champ 1
*     
         ier = fstprm( irec1, dat1,deet1,npas1,
     $        ni, nj, nk, cnbits,cdatyp,
     $        jp01,jp02, jp03,ctypvar,cnoment,cetiket,
     $        cigtyp, ig1,ig2,ig3,ig4, 
     $        cswa, clng, cdltf, cubc, extra1, extra2, extra3)
         if (ier .lt. 0) then
            write(6,*)' IER = FSTPRM NEGATIF VOIR CHMPDIF'
         endif
*     
*     verifier si grille gaussienne ni doit etre pair
*     
         if (cigtyp.eq.'G'.and.mod(ni,2).ne.0)  then
            call messags(ni)
         endif
*     
*     
*     lire champ no 1
*     
         call hpalloc(tmpif1p,ni*nj,ier,1 )
         if (.not.message) ier = fstopc('TOLRNC','DEBUGS',.true.) 
         if (date .eq. 1) then
            if (date3.eq.-1) then
               date=date2
            else
               call newdate(date, date2, date3, 3)
            endif
         endif
*     
         irec1=pgsmlir(tmpif1,1,ni,nj,nk,date,cetiket,ip1tab(i),
     $        ip2tab(j), ip3tab(k),ctypvar,cnoment,cigtyp)
*     
         if (printen)  call imprime(cnoment,tmpif1,ni,nj)
*     
*     identifier parametres pour champ 2
*     
         ier = fstprm( irec2, dat2,deet2,npas2,ni, nj, nk, 
     $        cnbits,cdatyp,
     $        jp11,jp12,jp13,ctypvar,cnoment,cetiket,
     $        cigtyp,ig1,ig2,ig3,ig4,
     $        cswa, clng, cdltf, cubc, extra1, extra2, extra3)
         if (ier .lt. 0) write(6,*)' IER = FSTPRM NEGATIF VOIR CHMPDIF'
*     
*     
*     verifier si grille gaussienne ni doit etre pair
*     
         if (cigtyp.eq.'G'.and.mod(ni,2).ne.0)  call messags(ni)
*     
*     
*     si les deux variables identiques on la transferre 
*     dans le fichier sorti
*     
         datsrt=dat1
*         if (dat1.eq.dat2) datsrt=dat1
         deetsrt=deet1
*         if (deet1.eq.deet2) deetsrt=deet1
         npassrt=npas1
*         if (npas1.eq.npas2) npassrt=npas1
*     
*     lire champ 2
*     

         call hpalloc(tmpif2p,max0(li*lj,ni*nj),ier,1 )
         if (.not.message) ier = fstopc('TOLRNC','DEBUGS',.true.) 
         if (date .eq. 1) then
            if (date3.eq.-1) then
               date=date2
            else
               call newdate(date, date2, date3, 3)
            endif
         endif
*     
         irec2=pgsmlir(tmpif2,1,ni,nj,nk,date,cetiket,ip1tab(ii),
     $        ip2tab(jj), ip3tab(kk),ctypvar,cnoment)
*     
*     
         if (printen)  call imprime(cnoment,tmpif2,ni,nj)
*     
*     difference entre les deux champs
*     
         nn = ni*nj
         call loupsou(tmpif1,tmpif2,nn) 
*     
*     interpolation horizontale
*     
         if (cgrtyp.eq.'*') then
            call chkenrpos(1,2,ig1,ig2,ig3)
         else
*     #  variable symetrique oui=.true. 
            
            gdin = ezqkdef(ni, nj, cigtyp, ig1, ig2, ig3, ig4, iunit)
            ier = ezdefset(gdout, gdin)
            ier = ezsint(tmpif2, tmpif1)
         endif
*     
*     ecrire le ip1,ip2,ip3 correspondant aux definitions
*     
         if (num1.gt.1) then
            jp(1)=ip1tab(i) 
            jp(2)=ip1tab(ii)
            jp(3)=ip2tab(j) 
         endif
*     
         if (num2.gt.1) then
            jp(1)=ip1tab(i) 
            jp(2)=ip2tab(j) 
            jp(3)=ip2tab(jj)
         endif
*     
         if (num3.gt.1) then
            jp(1)=ip1tab(i) 
            jp(2)=ip3tab(k) 
            jp(3)=ip3tab(kk)
         endif
         
         if (cnomsrt.eq.' ') then
            cnomsrt=cnoment
         endif

         lesips(1) = ip1s
         lesips(2) = ip2s
         lesips(3) = ip3s

         do i=1,3
            if (lesips(i).eq.65001) then
               jp(i) = jp01
            endif
            
            if (lesips(i).eq.65002) then
               jp(i) = jp11
            endif
            
            if (lesips(i).eq.65003) then
               jp(i) = jp02
            endif
            
            if (lesips(i).eq.65004) then
               jp(i) = jp12
            endif
            
            if (lesips(i).eq.65005) then
               jp(i) = jp03
            endif
            
            if (lesips(i).eq.65006) then
               jp(i) = jp13
            endif
         enddo


*     
*     
*     ecrire sur fichier standard,ms,sequentiel
*     
*     
      if (cgrtyp.eq.'*') then
         call ecritur(tmpif1,npack,datsrt,deetsrt,npassrt,ni,nj,1,
     $        jp(1),jp(2),jp(3),
     $        ctypvar,cnomsrt,cetiket,cigtyp,ig1,ig2,ig3,ig4)
      else
         call ecritur(tmpif2,npack,datsrt,deetsrt,npassrt,
     $        li,lj,1,jp(1),jp(2),jp(3),
     $        ctypvar,cnomsrt,cetiket,cgrtyp,lg1,lg2,lg3,lg4)
      endif

*     
*     remetre espace des champs de travail
*     
         call hpdeallc(tmpif2p,ier,1)
         call hpdeallc(tmpif1p,ier,1)
*     
      enddo
*     
      return 
      end
      
      
*
***S/P HEURE INITIALISER TABLE HEURE
*
      subroutine heure(ih1,ih2,ih3,ih4,ih5,ih6,ih7,ih8,ih9,ih10,
     $     ih11,ih12,ih13,ih14,ih15,ih16,ih17,ih18,ih19,ih20,
     $     ih21,ih22,ih23,ih24,ih25,ih26,ih27,ih28,ih29, 
     $     ih30,ih31,ih32,ih33,ih34,ih35,ih36,ih37,ih38,ih39,ih40) 
#include "impnone.cdk"
      external pgsmabt,messags
*
*AUTEUR P. SARRAZIN JANVIER 82 DRPN DORVAL P.Q. CANADA
*
*REVISION 
*        P. SARRAZIN JAN 85 POUR AUGMENTER DE 20 A 40 HEURES
*
*LANGAGE RATFOR
*
*OBJET(HEURE)
*         EXTRAIRE LES HEURES DEMANDER PAR L'USAGER ECRIRE DANS
*         LA TABLE HEURE
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*ARGUMENTS
*  IN     IH1.....IH40  HEURE DEMANDER PAR L'USAGER (READLX)
*
*MESSAGES 
*         MAUVAISE DIRECTIVE HEURE NHEURE=
*
*MODULES
*         PGSMABT
*
*APPEL   VIA DIRECTIVE
*         HEURE(IH1,IH2,IH3.....................IH40)
*
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#include "defin.cdk"
#include "heures.cdk"
#include "voir.cdk"
#include "accum.cdk"
*
      integer ih1,ih2,ih3,ih4,ih5,ih6,ih7,ih8,ih9,ih10,ih11,ih12,ih13
      integer ih14,ih15,ih16,ih17,ih18,ih19,ih20,ih21,ih22,ih23,ih24
      integer ih25,ih26,ih27,ih28,ih29,ih30,ih31,ih32,ih33,ih34,ih35
      integer ih36,ih37,ih38,ih39,ih40
*     
*     
      nheure = min0(MXHEURE,nheure)
*     
*     
*     
      go to (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,
     $     23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40)nheure
 40   heures(40) = ih40
 39   heures(39) = ih39
 38   heures(38) = ih38
 37   heures(37) = ih37
 36   heures(36) = ih36
 35   heures(35) = ih35
 34   heures(34) = ih34
 33   heures(33) = ih33
 32   heures(32) = ih32
 31   heures(31) = ih31
 30   heures(30) = ih30
 29   heures(29) = ih29
 28   heures(28) = ih28
 27   heures(27) = ih27
 26   heures(26) = ih26
 25   heures(25) = ih25
 24   heures(24) = ih24
 23   heures(23) = ih23
 22   heures(22) = ih22
 21   heures(21) = ih21
 20   heures(20) = ih20
 19   heures(19) = ih19
 18   heures(18) = ih18
 17   heures(17) = ih17
 16   heures(16) = ih16
 15   heures(15) = ih15
 14   heures(14) = ih14
 13   heures(13) = ih13
 12   heures(12) = ih12
 11   heures(11) = ih11
 10   heures(10) = ih10
 9    heures(9)  = ih9
 8    heures(8)  = ih8
 7    heures(7)  = ih7
 6    heures(6)  = ih6
 5    heures(5)  = ih5
 4    heures(4)  = ih4
 3    heures(3)  = ih3
 2    heures(2)  = ih2
 1    heures(1)  = ih1
*     
*     
*     #  change de location a cause de readlx
      nhur = nheure  
      return 
      end
*
***s/p macpcp interpole ajustement convectif ou precipitation
*
      subroutine macpcp(cnom,npar,itime)
#include "impnone.cdk"
*     
*auteur  p.sarrazin fevrier 82  drpn dorval p.q. canada
*     
*revision 4.0.2
*     conversion variables type hollerith -> type caractere
*   y. chartier -aout 90- drpn dorval quebec
*
*revision 5.2
*   support des grilles sources de type Z
*
*langage ratfor
*
*objet(macpcp)
*          extraire la difference entre deux champs dont les
*          heures  sont differents
*          avec routine fstinf on extrait le record necessaire pour
*          routine fstprm qui identifit les parametres utilises
*          par routine lire
*          on reserve la memoire pour les deux champs de travail
*          routine ecritur identifit la sorte de fichier utilisee
*          pour ecrire
*
*librairies
*         -source  armnsrc,drpn
*         -objet   pgsmlib,id=armnpjs.
*
*arguments
*  in    nom    nom du champ
*  in    npar    nombre de locations utilisees dans itime
*  in    itime   table contenant 2 heures ou niveaux
*
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*messages 
*          'mauvais appel a champ il devrait y avoir 3 arguments'
*           record n'existe pas sur fichier d'entre (macpcp)
*
*modules
      external ecritur,fstinf,pgsmlir,memoir,fstprm,symetri
      external loupneg,loupsou,fstopc,pgsmabt,imprime,messags,fstcvt
      external liraxez
      integer fstprm,fstinf,pgsmlir,fstopc,fstcvt
*     
*appel     via champ
*         call macpcp(nom,npar,itime)
*
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
#include "voir.cdk"
#include "dummys.cdk"
#include "llccmm.cdk"
#include "accum.cdk"
#include "param.cdk"
#include "indptr.cdk"
#include "grilles.cdk"
#include "lires.cdk"
#include "ecrires.cdk"
#include "dates.cdk"
#include "packin.cdk"
#include "gdz.cdk"
*     
      character *12 cetike,cetiket
      character *4 cnomvar, cnom 
      character *1 cigtyp
      character *2 ctypvar
      
      real valeur
      real fbidon
      
      integer i, itime(2),ig1,ig2,ig3,ig4,ip1,irec1,irec2
      integer jp1,jp2,jp3,lilj,ni,nj,nk,nn,npar,num1,num2,iopc 
      integer cdatyp,cnbits
      integer cswa, clng, cdltf, cubc, extra1, extra2, extra3
      integer ezqkdef, ezdefset, ezsint
      integer iunit
      logical symetri,sym
      
      iunit = 1
*     
      if (npar.ne.2) then
         if (message) then
            write(6,*)'MAUVAIS APPEL DOIT AVOIR 3 ARGUMENTS  (MACPCP)'
         endif
         return
      endif
*     
*     identifier le numero de chaque record avec fstinf
*     
*     # doit etre egal a zero dans fichier d'ENTRE
      ip1=0  
         if (date .eq. 1) then
            if (date3.eq.-1) then
               date=date2
            else
               call newdate(date, date2, date3, 3)
            endif
         endif

*     
*     modification de hollerith a caractere
*     
      cnomvar = cnom
      if (etikent(1) .ne. -1) then
         write(cetiket,'(2A4)') (etikent(i), i=1,nwetike)
      else 
         cetiket = '        '
      endif
      
      if (typeent .ne. -1) then
         write(ctypvar, '(A1)') typeent
      else 
         ctypvar = ' '
      endif
      
      
      irec1=fstinf(1,ni,nj,nk,date,cetiket,ip1,
     $     itime(1),ip3ent,ctypvar,cnomvar)
      irec2=fstinf(1,ni,nj,nk,date,cetiket,ip1,
     $     itime(2),ip3ent,ctypvar,cnomvar)
      
*     #  record n'EXISTE PAS
      if (irec2 .lt. 0 .or.irec1 .lt. 0) then
         write(6,*)'RECORD N EXISTE PAS SUR FICHIER D ENTRE (MACPCP)'
         write(6,*)' VERIFIER IP2-IP3ENT  IP1=0 SUR FICHIER D ENTRE'
         return
      endif
      
      if (nk.gt.1) then
         write(6,*)'************************************************'
         write(6,*)'         PGSM N ACCEPTE PAS UN          '
         write(6,*)' CHAMP DE 3 DIMENSIONS NK>1 ?? (MACPCP)'
         write(6,*)'************************************************'
         call pgsmabt
      endif
*     
*     
*     identifier parametres pour champ 1
*     
      ier = fstprm( irec1, dat,deet,npas,ni, nj, nk, cnbits,cdatyp,
     $     jp1,jp2, jp3,ctypvar,cnomvar,cetike,cigtyp, 
     $     ig1,ig2,ig3,ig4,
     $     cswa, clng, cdltf, cubc, extra1, extra2, extra3)
      if (ier .lt. 0) write(6,*)' IER = FSTPRM NEGATIF VOIR MACPCP'
*     
*     verifier si grille gaussienne ni doit etre pair
*     
      if (cigtyp.eq.'G'.and.mod(ni,2).ne.0)  call messags(ni)
*     
*     
*     lire champ no 1
*     
      call hpalloc(tmpif1p,ni*nj,ier,1)
      if (.not.message) iopc= fstopc('TOLRNC','DEBUGS',.true.) 
      if (date .eq. 0 .or. date .eq. 1) date=date2
      
      num1 = pgsmlir(tmpif1,1,ni,nj,nk,date,cetiket,jp1,jp2,jp3,
     $     ctypvar,cnomvar,cigtyp)
      
      if (printen)  call imprime(cnomvar,tmpif1,ni,nj)
*     
*     identifier parametres pour champ 2
*     
      ier = fstprm(irec2, dat,deet,npas,ni, nj, nk, cnbits,cdatyp,
     $     jp1,jp2, jp3,ctypvar,cnomvar,cetike,cigtyp,
     $     ig1,ig2,ig3,ig4,
     $     cswa, clng, cdltf, cubc, extra1, extra2, extra3)
      if (ier .lt. 0) write(6,*)' IER = FSTPRM NEGATIF VOIR MACPCP'
*     
*     verifier si grille gaussienne ni doit etre pair
*     
      if (cigtyp.eq.'G'.and.mod(ni,2).ne.0)  call messags(ni)
*     
*     lire champ 2
*     
      call hpalloc(tmpif2p,max0(li*lj,ni*nj),ier,1)
      if (.not.message) iopc= fstopc('TOLRNC','DEBUGS',.true.) 
      if (date .eq. 0 .or. date .eq. 1) date=date2
      num2 = pgsmlir(tmpif2,1,ni,nj,nk,date,cetiket,jp1,jp2,jp3,
     $     ctypvar,cnomvar,cigtyp)
      if (printen)  call imprime(cnomvar,tmpif2,ni,nj)
*     
*     difference entre les deux champs
*     
      nn = ni*nj
      call loupsou(tmpif1,tmpif2,nn) 
*     
*     
*     interpolation horizontale
*     
      if (cgrtyp.eq.'*') then
         call chkenrpos(1,2,ig1,ig2,ig3)
      else
*     #  variable symetrique oui=.true. 
         if (ig1.ne.0) sym = symetri(cnomvar) 
         gdin = ezqkdef(ni, nj, cigtyp, ig1, ig2, ig3, ig4, iunit)
         ier = ezdefset(gdout, gdin)
         ier = ezsint(tmpif2, tmpif1)
      endif
*     
*     #   jp1 - contient heure du premier champ
*     #   jp2 - contient heure du deuxieme champ
      jp1 = itime(1)   
      jp2 = itime(2)
      jp3 = 0
*     
*     deet et npas contiennent les dernieres valeurs lues dans le dernier record
*     
*     eliminer toutes les valeurs du champ negative precip
*     et acumulateur d'ajustement ne peuvent etre negatif
*     
      lilj=li*lj
      valeur=0.0
      call loupneg(tmpif2,valeur,1,lilj,1)
*     
*     ecrire sur fichier standard,ms,sequentiel
*     
      if (cgrtyp.eq.'*') then
         call ecritur(tmpif1,npack,dat,deet,npas,ni,nj,1,
     $        jp1,jp2,jp3,
     $        ctypvar,cnomvar,cetike,cigtyp,ig1,ig2,ig3,ig4)
      else
         call ecritur(tmpif2,npack,dat,deet,npas,li,lj,1,jp1,jp2,jp3,
     $        ctypvar,cnomvar,cetike,cgrtyp,lg1,lg2,lg3,lg4)
      endif
*     
*     remetre espace des champs de travail
*     
      call hpdeallc(tmpif1p,ier,1)
      call hpdeallc(tmpif2p,ier,1)
*     
      return
      end
      
      
*
***S/P  ADDITIONNE SOUSTRAIT MULTIPLIT MODULE 2 CHAMPS
*
      subroutine plmnmod(nom,type,idat,niv,ihr,ip3,etiqet) 
#include "impnone.cdk"
*
      external fstinf,fstsui,fstprm,pgsmabt,imprime
      external lopascm,messags,memoir,pgsmluk,fstcvt
      integer fstinf,fstsui,fstprm,pgsmluk,fstcvt 
*
*AUTEUR P. SARRAZIN AOUT 82 DRPN DORVAL P.Q. CANADA
*
*LANGAGE RATFOR
*
*OBJET(PLMNMOD)
*         LIRE UN CHAMP SUR FICHIER 1 OU 2 DE MEME NATURE ET DIMENSIONS
*         CELUI DANS L ACCUMULATEUR ET QUE L ON AJOUTE , SOUSTRAIT , MULTIPLIT
*         OU FAIT LA SOMME DE CHAQUE POINT DES DEUX CHAMPS AU CARRE.
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*ARGUMENTS
*   IN   NOM    NOM DU CHAMP  LCAR(GZ),"TT"....
*   IN   TYPE   TYPE DE CHAMP P=PREVISION  A=ANALYSE
*   IN   NIV    NIVEAU DU CHAMP
*   IN   IDAT   DATE DU CHAMP CMC STAMP 
*   IN   IHR    HEURE DU CHAMP
*   IN   IP3    LIBRE (USAGER)
*   IN   ETIQET ETIQUETTE DU CHAMP 10 CARACTERES
*
*- - -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*MESSAGES 
*         RECORD N EXISTE PAS SUR FICHIER
*         DIRECTIVE LIREE OU LIRES DOIT-ETRE APPELE AVANT
*                 'NI   ENTRE =',NIE,'NI LIREE\LIRES=',NNI, 
*                 'NJ   ENTRE =',NJE,'NJ LIREE\LIRES=',NNJ, 
*                 'NK   ENTRE =',NKE,'NK LIREE\LIRES=',NNK, 
*                 'DIMENSION DU CHAMP   MAUVAISE' 
*                 TYPE DE GRILLE DIFFERENT FATAL CHAMP=
*                 MAUVAISE HEMISPHERE CHAMP ...DOIT-ETRE=
*                 ERREUR  2 CHAMPS DIFFERENTS
*                 GRILLE INCONU DIRECTIVE  PLUS-MOIN-MODULE 
*
*APPEL VIA DIRECTIVE
*       PLUSE(NOM,TYPE,IDAT,NIV,IHR,IP3,ETIQET) FICHIER D'ENTRE
*       PLUSS(NOM,TYPE,IDAT,NIV,IHR,IP3,ETIQET)  FICHIER DE SORTIE
*       MOINSE(NOM,TYPE,IDAT,NIV,IHR,IP3,ETIQET) FICHIER D'ENTRE
*       MOINSS(NOM,TYPE,IDAT,NIV,IHR,IP3,ETIQET)  FICHIER DE SORTIE
*       MODUL2E(NOM,TYPE,IDAT,NIV,IHR,IP3,ETIQET) FICHIER D'ENTRE
*       MODUL2S(NOM,TYPE,IDAT,NIV,IHR,IP3,ETIQET)  FICHIER DE SORTIE
*       FOISE(NOM,TYPE,IDAT,NIV,IHR,IP3,ETIQET) FICHIER D'ENTRE
*       FOISS(NOM,TYPE,IDAT,NIV,IHR,IP3,ETIQET)  FICHIER DE SORTIE
*
*MODULES  FSTINF,FSTSUI,PGSMABT,FSTPRM,MEMOIR
*
*---------------------------------------------------------------------- 
*
*
#include "lires.cdk"
#include "voir.cdk"
#include "ecrires.cdk"
#include "chck.cdk"
#include "accum.cdk"
#include "llccmm.cdk"
*
      character*12 cetike,cetiket
      character*4 cnomvar, cnumve
      character*2 ctypvar,ctypve
      character*1 cigtyp,cigtye
*
      integer type,etiqet(3),nom,aa,letiqet(3)
      integer idat,idate,ideete,if1,ig1e,ig2e,ig3e,ig4e
      integer ihr,ip3,irec,itot,iunit,jp1e,jp2e,jp3e,nie
      integer niv,nje,nke,npase
      integer cnbits,cdatyp,cswa,clng,cdltf,cubc,extra1,extra2,extra3
      integer argdims,letiket(3)
      external argdims
*     
*    AA  MULTIPLICATEUR POUR AJOUTER OU SOUSTRAIRE
*
      aa=1
      iunit=1
*
*    VERIFIER SI DIRECTIVE LIREN OU LIRSR A ETE APPELE
*
 100  if (ichck.eq.0)  then
*     erreur faut appeler liren ou lirsr
         write(6,*)'DIRECTIVE LIREE OU LIRES DOIT-ETRE APPELE AVANT ' 
         call pgsmabt
      endif
*
*   MODIFICATION DE HOLLERITH A CARACTERE
*
      cnomvar = '    '
      ctypvar = '  '
      cetiket = '            '
      cigtyp  = ' '

      letiket(1) = etiqet(1)
      letiket(2) = "    "
      letiket(3) = "    "
      if (argdims(7).gt.1) then 
         letiket(2) = etiqet(2)
      endif
      if (argdims(7).gt.2) then 
         letiket(3) = etiqet(3)
      endif

      ier = fstcvt(    nom,    type,  letiket,     -1,
     $     cnomvar, ctypvar, cetiket, cigtyp,     .true.) 
*     
      irec=fstinf(iunit,nie,nje,nke,idat,cetiket,niv,ihr,ip3,
     $     ctypvar, cnomvar)
      

      if (irec.lt.0)  then
*     arret record n'EXISTE PAS
         write(6,*)
     $        ' VERIFIER PLUSE/S - MOINSE/S - MODUL2E/S - FOIS(E\S)'
         write(6,*)' FSTINF A PAS RECONNU RECORD MAL DEFINI'
         call pgsmabt
      endif


 10   if (irec.gt.-1) then
*
*
         ier = fstprm(irec,idate,ideete,npase,nie,nje,nke, 
     $        cnbits,cdatyp,
     $        jp1e,jp2e,jp3e,ctypve,cnumve,cetike,cigtye,
     $        ig1e,ig2e,ig3e,ig4e,
     $        cswa, clng, cdltf, cubc, extra1, extra2, extra3)
         if (ier.lt.0) then
            write(6,*)' IER = FSTPRM NEGATIF VOIR PLUSE/MOIN.....'
         endif
*     
*     VERIFIER SI GRILLE GAUSSIENNE NI DOIT ETRE PAIR
*     
         if (cigtye.eq.'G'.and.mod(nie,2).ne.0)  call messags(nie)
*     
*     
         if (nie.ne.nni.or.nje.ne.nnj.or.nke.ne.nnk) then
            write(6,600)nie,nni 
            write(6,610)nje,nnj 
            write(6,620)nke,nnk 
            write(6,*)'DIMENSION DU CHAMP MAUVAISE VERIFIER   '
            write(6,*)'PLUS(E\S) - MOINS(E\S) - MODUL2(E\S) - FOIS(E\S)'
            call pgsmabt
         endif
*
         if (cigty.ne.cigtye) then
            write(6,660)cigtye,cigty
            write(6,*)
     $           ' VERIFIER PLUS(E\S)-MOINS(E\S)-MODUL2(E\S)-FOIS(E\S)'
            call pgsmabt
         endif
*     
         if (cigty.eq.'G'.or.cigty.eq.'A'.or.cigty.eq.'B') then
            if (ig1e.ne.igg1) then
               write(6,*)'MAUVAISE HEMISPHERE CHAMP DE =',ig1e 
               write(6,*)'DOIT-ETRE=',igg1 
               write(6,*)
     $            ' VERIFIER PLUS(E\S)-MOINS(E\S)-MODUL2(E\S)-FOIS(E\S)'
               call pgsmabt
            endif
         else
            if (cigty.eq.'N'.or.cigty.eq.'S'.or.cigty.eq.'L') then
               if (ig1e.ne.igg1.or.ig2e.ne.igg2.or.
     $              ig3e.ne.igg3.or.ig4e.ne.igg4) then
                  write(6,*)'ERREUR  2 CHAMPS DIFFERENTS'
                  write(6,*)
     $           ' VERIFIER PLUS(E\S)-MOINS(E\S)-MODUL2(E\S)-FOIS(E\S)' 
                  call pgsmabt
               endif
            endif
         endif
*
*
*    ALLOCATION DE LA MEMOIRE 
*
         call hpalloc(tmpif1p,nni*nnj*nnk,ier,1)
*
         ier = pgsmluk(tmpif1, irec, nni, nnj, nnk,cnomvar,cigty)
         if (ier.lt.0)  then
            write(6,*)' IER=PGSMLUK(..... NEGATIF VOIR PLUS/MOIN.....'
            return
         endif
         
         
         if (printen)  call imprime(cnumve,tmpif1,nni,nnj)
*     
*     
*     AJOUTE 1 AU COMPTEUR ICNT DANS COMMON ACCUM INITIALISER
*     A 1 DANS MAIN PROGRAM
*     
         icnt = icnt + 1
*     
*     
*     ADDITIONNE-SOUSTRAIT-MODULE-MULTIPLIT CHAQUE PTS DES DEUX CHAMPS 
*     
         itot=nni*nnj*nnk
         call lopascm(tmpif0,tmpif1,aa,itot)
*     
*
         call hpdeallc(tmpif1p,ier,1)
*     
         if (aa.ne.1.or.unefois.or.once) goto 11
         irec = fstsui(iunit,nie,nje,nke)
*     
         goto 10
      endif
 11   continue
*     
      return
      entry pluss(nom,type,idat,niv,ihr,ip3,etiqet)
*
*   AA=MULTIPLICATEUR POUR AJOUTER
*     
      aa=1
      iunit = 2
      go to 100
*     
      entry moinse(nom,type,idat,niv,ihr,ip3,etiqet)
*     
*     AA=MULTIPLICATEUR POUR  SOUSTRAIRE 
*     
      aa=-1
      iunit = 1
      go to 100
*     
      entry moinss(nom,type,idat,niv,ihr,ip3,etiqet)
*     
*     AA=MULTIPLICATEUR POUR  SOUSTRAIRE 
*     
      aa=-1
      iunit = 2
      go to 100
*     
      entry modul2e(nom,type,idat,niv,ihr,ip3,etiqet)
*     
*     2   AA=2 ADDITIONNER LES DEUX CHAMPS AU CARRE
*     
      aa=2
      iunit = 1
      go to 100
*     
      entry modul2s(nom,type,idat,niv,ihr,ip3,etiqet)
*     
*     AA=2 ADDITIONNER LES DEUX CHAMPS AU CARRE
*     
      aa=2
      iunit = 2
      go to 100
*     
      entry foise(nom,type,idat,niv,ihr,ip3,etiqet)
*     
*     AA=3 MULTIPLIER CHAQUE PT DES DEUX CHAMPS
*     
      aa=3
      iunit = 1
      go to 100
*     
      entry foiss(nom,type,idat,niv,ihr,ip3,etiqet)
*     
*     AA=3 MULTIPLIER CHAQUE PT DES DEUX CHAMPS
*     
      aa=3
      iunit = 2
      go to 100
*     
      entry divisee(nom,type,idat,niv,ihr,ip3,etiqet)
*     
*     AA=4 MULTIPLIER CHAQUE PT DES DEUX CHAMPS
*     
      aa=4
      iunit = 1
      go to 100
*     
      entry divises(nom,type,idat,niv,ihr,ip3,etiqet)
*     
*     AA=4 MULTIPLIER CHAQUE PT DES DEUX CHAMPS
*     
      aa=4
      iunit = 2
      go to 100
*     
 600  format(2x,'NI  ENTRE =',i10,'NI ACCUMULATEUR=',i10)
 610  format(2x,'NJ  ENTRE =',i10,'NJ ACCUMULATEUR=',i10)
 620  format(2x,'NK  ENTRE =',i10,'NK ACCUMULATEUR=',i10)
 660  format(2x,'MAUVAISE GRILLE ENTRE=',a1,'ACCUMULATEUR=',a1)
*     
      end 
      
      
*
***S/P SORTI   IDENTIFICATION DU FICHIER..OUVRIR FICHIER...RESERVER MEMOIRE
*
      subroutine sorti( modx, norecs, jwrit)


      implicit none


      external fnom,memoir,fstnbr,fsteof,fstouv,pgsmabt,fstvoi,fstapp,messags
      external fstabt, fstlnk, exfin, pgsmof
      integer  fnom,fstnbr,fsteof,fstouv,fstvoi,fstapp,exfin,pgsmof
*
*AUTEUR P. SARRAZIN DEC 81 DRPN DORVAL P.Q. CANADA
*
*LANGAGE RATFOR
*
*OBJET(SORTI)
*          VERIFIER LA VALEUR DE MODX  RESERVER MEMOIRE, OUVRIR FICHIER
*            MODX=1 FICHIER STANDARD
*                 2 FICHIER ACCES DIRECT (READMS) 
*                 3 FICHIER SEQUENTIEL
*                 4 FICHIER SEQUENTIEL AVEC PARAMETRES DE FSTECR
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*ARGUMENTS
*  IN      MODX      1=FICHIER STANDARD 
*                    2=FICHIER DIRECT (READMS)
*                    3=FICHIER SEQUENTIEL
*
*  IN     NOENRG     NOMBRE D'ENREGISTREMENT DANS FICHIER
*  IN      JWRIT     -1=REECRIRE SUR FICHIER OU ECRIRE A LA FIN(MS) SORTI(MS,500,A)
*                    -1=ECRIRE SUR FICHIER UN RECORD SANS DETRUIRE UN 
*                       RECORD PAREIL   SORTI(STD,500,A)
*                    +1=REECRIRE SUR FICHIER FATAL SI RECORD PAS LA.   SORTI(MS,500,R)
*                    +1=REMPLACE UN RECORD SI DEJA EXISTANT DETRUIT   SORTI(STD,500,R)
*
*IMPLICITES
*
*MESSAGES 
*         DEUXIEME APPEL A LA DIRECTIVE SORTIE APPEL IGNORE 
*         MAUVAIS APPEL A DIRECTIVE SORTIE FICHIER STD
*         MAUVAISE DIRECTIVE (SORTIE) FICHIER MS
*         DIRECTIVE ENREG=0, INITIALISER A 1
*         MAUVAIS APPEL A SORTIE FICHIER SEQ
*         TYPE DE FICHIER INCONNU
*         MAUVAISE DIRECTIVE MODE DIFFERENT DE (STD,MS,SEQ) 
*
*
*----------------------------------------------------------------------
*
*
#include "lnkflds.cdk"
#include "llccmm.cdk"
#include "accum.cdk"
#include "charac.cdk"
#include "dates.cdk"
#include "indptr.cdk"
#include "enrege.cdk"
#include "voir.cdk"
*
      integer i,jwrit,modx,norecs
      common/relu/dejalue
      logical dejalue
      data dejalue/.false./
*     
*   DATE DE LA RUN OPERATIONNELLE UTILISEE PAR L'USAGER DIRECTIVE OPDAT=OUI
*     
      if (lfn(6).ne. 'NON') then
         if (seldat) date = jdate
         if (seldat) write(6,*)' DATE ORIGINE = DATE VALIDE DATE=',date
      endif
*     
      if (dejalue)  then
         if (message) then
            write(6,*)
     $           'DEUXIEME APPEL A LA DIRECTIVE SORTIE APPEL IGNORE'
            return
         endif
      endif
      dejalue=.true.
*     
      mode = modx
      noenrg = norecs
*     
*     NBR1 = MAX0(2,FSTNBR(1))
*     
*      ier = fstnbr(1)
*      if (ier .lt. 0) call fstabt
*
*   LE FICHIER D ENTRE NE PEUT ETRE  FICHIER STANDARD SEQUENTIEL
*
      iset = 0  
*
*  RESERVER MEMOIR POUR FICHIER D ENTRE 
*
*     
      if (mode.eq.1)  then
         if (noenrg.eq.1) then
            ier=fnom(2,lfn(41),'STD+SEQ+FTN',0)
         else if (noenrg.eq.0) then
            ier=fnom(2,lfn(41),'STD+SEQ',0)
         else
            ier = fnom(2,lfn(41),'STD+RND',0)

            if (nsort.eq.2) then
               iwrit=+1 
            else if (nsort.eq.3) then
               iwrit=jwrit
            else 
               write(6,*)
     $              'MAUVAIS APPEL A DIRECTIVE SORTIE FICHIER STD'
               call pgsmabt
            endif
         endif
      else if (mode.eq.2) then
         write(6,*)
     $        ' LES FICHIERS "MS" NE SONT PAS SUPPORTES DANS CETTE'
         write(6,*)         ' VERSION DE PGSM'
         call pgsmabt 
      else if (mode.eq.3.or.mode.eq.4) then
         ier = fnom(2,lfn(41),'SEQ+FTN+UNF',0)
         
         if (nsort.ne.1)  then
            write(6,*)'MAUVAIS APPEL A SORTIE FICHIER SEQ'
            call pgsmabt
         endif
      else if (mode.eq.5) then
         if (jwrit.eq.-1) then
            ier = pgsmof(2,lfn(41))
*            ier = fnom(2,lfn(41),'SEQ+FMT+APPEND',0)
         else
            ier = pgsmof(2,lfn(41))
            ier = fnom(2,lfn(41),'SEQ+FMT+R/W',0)
         endif
      else  
         if (message) write(6,*)'TYPE DE FICHIER INCONNU'
         if (message) write(6,*)
     $        ' MAUVAISE DIRECTIVE MODE DIFFERENT DE (STD,MS,SEQ)'
         return
      endif
*     
*
      if (mode.eq.2) then
         write(6,*)
     $  'LES FICHIERS "MS" NE SONT PLUS SUPPORTES SUR LES CYBER-910-920'
         call pgsmabt
      endif

      if (mode.eq.1)  then
         if (noenrg.eq.1)  then
            ier = fstouv(2, 'SEQ+FTN')
         else if (noenrg.eq.0) then
            ier = fstouv(2, 'SEQ')
            if (jwrit.eq.-1) then
               ier = fstapp(2,' ')
               ier = fsteof(2)
               print *, 'fsteof retourne', ier
            endif
         else
            ier = fstouv(2, 'RND') 
         endif
      endif
*
*   OUVRIR FICHIER D'ENTREE STANDARD

      if (inputmod.eq.SEQUENTIEL) then
         ier = fstouv(lnkdiun(1), 'SEQ')
      else
      do i=1,niun
         ier = fstouv(lnkdiun(i), 'RND+R/O+OLD')
         if (ier .lt. 0) then
            print *, '************************************************'
            print *, 
     $           '* LE FICHIER #',lfn(i), 'N''EST PAS STANDARD RANDOM'
            print *, '*************************************************'
            jdate= exfin('  PGSM  ', 'ABORT' , 'NON')
            call qqexit(13)
         endif
      enddo
      
      call fstlnk(lnkdiun,niun)
      endif

      if (voire) then
         if (message) then
            do i=1,niun
               ier = fstvoi(lnkdiun(i), 'RND')
            enddo
         endif
      endif
*
      return 
      end
*
***S/P   COMME   LIRE UN CHAMP DANS ACCUMULATEUR
*
      subroutine comme(iunit, nom, type, idat, niv, ihr, ip3, etiqet) 
#include "impnone.cdk"
      external fstinf,pgsmlir,memoir,fstprm,pgsmabt,imprime 
      external fstopc,messags,fstcvt
      integer fstinf,pgsmlir,fstprm,fstopc,fstcvt 
*
*AUTEUR P. SARRAZIN  AOUT 82 DRPN DORVAL P.Q. CANADA
*
*LANGAGE RATFOR
*
*OBJET(COMME)
*         LIRE UN CHAMP SUR FICHIER 1 OU 2 ET SAUVE DANS UN ACCUMULATEUR
*         POUR ETRE UTILISER PAR LES DIRECTIVES PLUSE-PLUSS 
*         MOINSE-MOINSS-PFOIS-MOYENE-RACINE-MODUL2E-MODUL2S 
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*ARGUMENTS
*   IN   NOM     NOM DU CHAMP LCAR(GZ),"TT"...... 
*   IN   TYPE    TYPE DE CHAMP "P"=PREVISION  "A" ANALYSE
*   IN   NIV     NIVEAU DU CHAMP
*   IN   IHR     HEURE DU CHAMP
*   IN   IP3     LIBRE(USAGER) COMPTEUR POUR MOYENE UTILISER PAR ECRITS
*   IN   ETIQET  ETIQUETTE 10 CARACTERES
*
*IMPLICITES
*MESSAGES 
*         RECORD N EXISTE PAS SUR FICHIER (FSTINF DANS COMME)
*         RECORD N EXISTE PAS (PGSMLIR DANS ROUTINE COMME)
*
*MODULES  FSTINF,PGSMABT,FSTPRM,MEMOIR,PGSMLIR
*
*APPEL     VIA DIRECTIVE
*         LIREE(NOM, TYPE, IDAT, NIV, IHR, IP3, ETIQUET)
*         LIRES(NOM, TYPE, IDAT, NIV, IHR, IP3, ETIQUET)
*
* -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
#include "accum.cdk"
#include "chck.cdk"
#include "voir.cdk"
#include "llccmm.cdk"
#include "indptr.cdk"
#include "lires.cdk"
#include "dummys.cdk"
#include "grilles.cdk"
#include "gdz.cdk"
*
*
      character *12 cetiqet
      character *4 cnomvar
      character *2 ctypvar
      character *1 cigtyp
      character *4 cbidon
      integer etiqet(3),idat,ihr, ip3,irec1,iunit,niv,nom,num1,type
      integer cnbits,cdatyp,extra1,extra2,extra3,cubc,cdltf,clng,cswa 
      integer iopc, bidon

      integer ezqkdef, ezgxprm,gdll, argdims, letiket(3)
      external  ezqkdef, ezgxprm, gdll, argdims
*     
*     
*     MODIFICATION DE HOLLERITH A CARACTERE
*     
      bidon = 0
      cnomvar = '    '
      ctypvar = '  '
      cetiqet = '            '
      cigtyp  = ' '

      letiket(1) = etiqet(1)
      letiket(2) = "    "
      letiket(3) = "    "
      if (argdims(8).gt.1) then 
         letiket(2) = etiqet(2)
      endif
      if (argdims(8).gt.2) then 
         letiket(3) = etiqet(3)
      endif

 100  ier = fstcvt(    nom,   type, letiket,    bidon,
     $             cnomvar,ctypvar,cetiqet,cbidon,.true.)
      if (cnomvar.eq.'  '.and.ctypvar.eq.' '.and.cetiqet.eq.'        '.
     $     and.niv.eq.-1.and.ihr.eq.-1.and.
     $     ip3.eq.-1.and.idat.eq.-1) then
         print *, '****************************************************'
         print *, '*             Un chausson avec ca?                 *'
         print *, '****************************************************'
         call pgsmabt
      endif

      irec1=fstinf(iunit,nni,nnj,nnk,idat,cetiqet,niv,ihr,ip3,
     $     ctypvar,cnomvar)
      if (irec1 .lt. 0)   then
         write(6,*)
     $        'RECORD N EXISTE PAS SUR FICHIER (FSTINF LIREE-LIRES)'
         call pgsmabt
      endif
*     
      if (nnk.gt.1)   then
         write(6,*)'*************************************************'
         write(6,*)'         PGSM N ACCEPTE PAS UN          '
         write(6,*)' CHAMP DE 3 DIMENSIONS NK>1 ?? (LIREE-LIRES)'
         write(6,*)'*************************************************'
         call pgsmabt
      endif
*     
*     
*  #  clef pour directive pluse,moinse,ecrits....
*     
*     
      ier = fstprm(irec1,idatt,ideet,npas,nni,nnj,nnk, cnbits,cdatyp,
     $     jpp1,jpp2,jpp3,ctypvar,cnomvar,cetiqet,cigtyp,igg1,igg2,igg3,
     $     igg4,cswa, clng, cdltf, cubc, extra1, extra2, extra3)
      
      
      if (ier .lt. 0) then
         write(6,*)'RECORD N EXISTE PAS (comme)'
         call pgsmabt
      endif

*    ALLOCATION DE LA MEMOIRE 
*
      if (cigtyp.ne.'Z'.and.cigtyp.ne.'Y') then
         gdout = ezqkdef(nni,nnj, cigtyp,igg1,igg2,igg3,igg4,iunit)
         ier = ezgxprm(gdout,li,lj,cgrtyp,
     $        lg1,lg2,lg3,lg4,cgtypxy,ig1ref,ig2ref,ig3ref,ig4ref)
         call hpalloc(tmplonp,li*lj,ier,1)
         call hpalloc(tmplatp,li*lj,ier,1)
      else
         call gritp12(7,igg1,igg2,igg3)
      endif

*
      if (.not.message) iopc= fstopc('TOLRNC','DEBUGS',.true.)

      return
*     
      end 
      
*
***S/P GRIGAUS   CALCUL LAT LONG DE CHAQUE PT D'UNE GRILLE GAUSSIENNE 
*
      subroutine grigaus(nni,nnj,nhem)
#include "impnone.cdk"
*
*AUTEUR   - P. SARRAZIN JANVIER 87 DRPN DORVAL P.Q. CANADA
*
*LANGAGE - RATFOR
*
*OBJET(GRIGAUS)
*          CALCULER LA LATITUDE ET LA LONGITUDE DE TOUS LES POINTS
*          DE LA GRILLE DE SORTIE GAUSSIENNE LONGITUDE EQUIDISTANTE
*          LATITUDE GAUSSIENNE
*
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*------------------------------------------------------
*
      external memoir,pgsmabt,grgg,messags
      external ezqkdef
      integer ezqkdef
*
#include "grilles.cdk"
*
*
#include "llccmm.cdk"
*
*
*
      integer nni,nnj,nhem,ier,nroot
*
*   RESERVER MEMOIR POUR LATITUDE ET LONGITUDE
*
      call hpalloc(tmplatp,nni*nnj,ier,1)
      call hpalloc(tmplonp,nni*nnj,ier,1)
*     
      lg1=nhem
*
      li=nni
      lj=nnj
*     
      if (lg1.lt.0 .or.lg1.gt.2) then
         write(6,*)'LG1 DOIT ETRE  GLOBAL,NORD,SUD   GRILLE(GAUSS.....'
         call pgsmabt
      endif
*     
      cgrtyp='G'
      lg2=0
      lg3=0
      lg4=0
*     
      if (lg1.eq.0) then
         nroot=nnj
      else
         nroot=nnj*2
      endif

*     BUFL(IROOT)  -TABLE DE RACINES DES POLYNOMES DE LEGENDRE
*     UTILISER PAR GRIGAUS POUR LE CALCUL DES LATITUDES
*     LONGITUDES DANS GRGG ROUTINE
*     
      call hpalloc(tmprootp,nroot,ier,1)
      
      tmproot(1)= 100.0
      gdout = ezqkdef(li,lj,cgrtyp,lg1,lg2,lg3,lg4,0)
      
*     
      call hpdeallc(tmprootp,ier,1)
*     
      return
      end 
*
***S/P  IMPRIME CHAMP LUT SUR FICHIER D ENTRE OU DE SORTI
*
      subroutine imprime(cnom,champ,ni,nj)
#include "impnone.cdk"
*
*AUTEUR P. SARRAZIN JUIN 85 DRPN DORVAL P.Q. CANADA
*
*REVISION 4.0.2
*   MODIF. ARGUMENT NOM (ENTIER -> CHARACTER*2)
*   Y. CHARTIER DRPN DORVAL QUEBEC
*
*LANGAGE RATFOR
*
*OBJET(IMPRIME)
*        IMPRIME AVEC LA DIRECTIVE PRINTEN RECORD LUT SUR FICHIER D ENTRE
*        OU IMPRIME AVEC LA DIRECTIVE PRINTSR RECORD QUE L ON VA ECRIRE
*        L USAGER CONTROL LE NOMBRE DE LOCATIONS A IMPRIMER 
*        FENETRE DU CHAMP A IMPRIMER DEFINIT PAR L'USAGER
*        DANS LA DIRECTIVE PRINTEN/PRINTSR MODIFIE LE COMMON
*        LIRES OU ECRIRES PRINTEN=OUI,NIS,NJS,NIF,NJF,NINC,NJNC
*        NIS = POINT DE DEPART DANS LA DIRECTION I (EST-OUEST)
*        NJS = POINT DE DEPART DANS LA DIRECTION J (NORD-SUD)
*        NIF = DERNIER POINT DANS LA DIRECTION I (EST-OUEST)
*        NJF = DERNIER POINT DANS LA DIRECTION J (NORD-SUD) 
*        NINC= INTERVAL DANS LA DIRECTION I
*        NJNC= INTERVAL DANS LA DIRECTION J
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*ARGUMENTS
*  IN     NOM   -NOM DU CHAMP QUE L ON VEUT IMPRIMER 2 CARACTERES
*  IN     CHAMP -CONTIENT LE CHAMP QUE L ON VEUT IMPRIMER
*  IN     NI    -DIMENSION DU CHAMP EST=OUEST
*  IN     NJ    -DIMENSION DU CHAMP NORD-SUD
*
*
*MESSAGES 
*
*MODULES
*         PGSMABT
*
*APPEL   VIA DIRECTIVE
*         PRINTEN(OUI,NIS,NJS,NIF,NJF,NINC,NJNC)
*         PRINTSR(OUI,NIS,NJS,NIF,NJF,NINC,NJNC)
*
* - -  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
#include "voir.cdk"
#include "lires.cdk"
#include "ecrires.cdk"
*
      integer i,j,ni,nj,njff,niff,niifs,njjfs
      character*4 cnom
      real champ(ni,nj)

      niff=nif
      njff=njf
      if (nif.gt.ni)  niff=ni
      if (njf.gt.nj)  njff=nj
*     
      write(6,600) cnom,nis,njs,niff,njff,ninc,njnc
 600  format(' PRINT CHAMP(LU) NOM=',a2,'  NIS=',i3,'  NJS=',i3,
     $     '  NIFF=',i3,
     $     '  NJFF=',i3,'  NINC=',i3,'  NJNC=',i3)
 620  format(' PRINT CHAMP(ECRIT) NOM=',a2,'  NIS=',i3,'  NJS=',i3,
     $     '  NIFF=',i3,
     $     '  NJFF=',i3,'  NINC=',i3,'  NJNC=',i3)
*     
      do j=njs,njff,njnc
         write(6,630) j
         write(6,610) (champ(i,j),i=nis,niff,ninc)
      enddo
*     
      if (niff.lt.nis)  then
         write(6,*)
     $   ' NIS.lt.NIF DIRECTIVE PRINTEN=OUI,NIS,NJS,NIF,NJF,NINC,NJNC'
      endif

      if (njff.lt.njs)  then
         write(6,*)
     $     ' NJS.lt.NJF DIRECTIVE PRINTEN=OUI,NIS,NJS,NIF,NJF,NINC,NJNC'
      endif
 610  format(1h ,10e13.5)
 630  format('  RANGEE NO ',i3)
      return 
      entry imprims(cnom,champ,ni,nj)
*     
      niifs=niif
      njjfs=njjf
      if (niif.gt.ni)  niifs=ni
      if (njjf.gt.nj)  njjfs=nj
*     
      write(6,620) cnom,niis,njjs,niifs,njjfs,niinc,njjnc
*     
      do j=njjs,njjfs,njjnc 
         write(6,630) j
         write(6,610) (champ(i,j),i=niis,niifs,niinc)
      enddo
*     
      if (niifs.lt.niis)  then
         write(6,*)
     $     ' NIS.lt.NIF DIRECTIVE PRINTSR=OUI,NIS,NJS,NIF,NJF,NINC,NJNC'
      endif
      if (njjfs.lt.njjs)  then
         write(6,*)
     $     ' NJS.lt.NJF DIRECTIVE PRINTSR=OUI,NIS,NJS,NIF,NJF,NINC,NJNC'
      endif
      return 
      end
      
*
***S/P MESSAGS  IMPRIME MESSAGE SUR UNE PAGE COMPLETE
      subroutine messags(ni) 
#include "impnone.cdk"
*
*LANGAGE RATFOR
*
*OBJET(MESSAGS)
*          IMPRIME UN MESSAGE A CHAQUE FOIS UNE GRILLE GAUSSIENNE
*          N'A PAS UN NOMBRE DE LONGITUDE PAIRES
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*ARGUMENTS
*  IN     NI  - NOMBRE DE LONGITUDES DANS LE RECORD DU FICHIER D'ENTRE
*     
      integer ni
      write(6,600) 
 600  format(1h1)
      write(6,*)'**************************************************' 
      write(6,*)'*                                                '
      write(6,*)'*                    ATTENTION                   '
      write(6,*)'*                                                '
      write(6,*)'*          NOMBRE DE LONGITUDES                  '
      write(6,*)'*          DOIT-ETRE PAIR                        '
      write(6,*)'*          POUR UNE GRILLE GAUSSIENNE   # LONG=',ni 
      write(6,*)'*                                                '
      write(6,*)'*          GARBAGE IN   GARBAGE OUT     OUCH  ?? '
      write(6,*)'*                                                '
      write(6,*)'**************************************************' 
      write(6,600) 
*     
      return
      end
      
      subroutine prefiltre(fld,ni,nj,nomvar,grtyp)
#include "impnone.cdk"
      integer ni,nj
      real fld(ni,nj)
      character*4 nomvar
      character*1 grtyp

#include "qqqfilt.cdk"

      if (fltoggle(1)) then
        if (grtyp.eq.'Y') then
          write (6, *)
     &         ' (PREFILTRE) Impossible de filtrer des champs sur grille Y'
        else
          write (6, *) ' CHAMP FILTRE A LA LECTURE'
*          call statfld4 (fld,nomvar,0,'AVANFFLT',ni,nj,1,ni,nj,1,0,0
*     &         ,0)
          call filtre (fld, NI, NJ, 0, fltntimes(1), fltlist(1,1), fltwgtlng(1))
*          call statfld4 (fld,nomvar,1,'APRESFLT',ni,nj,1,ni,nj,1,0,0
*     &         ,0)
        endif
      endif
      
      return
      end
*
***FONCTION SYMETRI FUNCTION QUI RECONNAIT SI LA VARIABLE EST SYMETRIQUE
*
      logical function symetri(cnom)
#include "impnone.cdk"
      external cmetsym  
#include "defin.cdk"
*
*AUTEUR  P.SARRAZIN  FEVRIER  DRPN  DORVAL  P.Q.  CANADA
*
*REVISION 4.0.2
*   MODIFICATION ARGUMENT D'ENTREE "NOM"
*      DE "INTEGER" A "CHARACTER*2"
*   Y. CHARTIER DRPN DORVAL QUEBEC
*LANGAGE RATFOR
*
*OBJET(SYMETRI)
*         VERIFIER SI UNE VARIABLE EST SYMETRIQUE .TRUE.=SYMETRIQUE
*         MESSAGE SI VARIABLE N EST PAS RECONNUE DEFAULT SYMETRIQUE
*          SI UNE VARIABLE N EST PAS RECONNUE ELLE EST CONSIDEREE
*          COMME SYMETRIQUE
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*ARGUMENTS
*   IN    NOM    NOM DE LA VARIABLE
*
*
*APPEL    VIA MACPCP,EPAISUR
*         SYMETRI(NOMBRE)
*
*MESSAGES 
*         LA SYMETRIE DE LA VARIABLE  EST INCONNUE
*         ON LA SUPPOSE SYMETRIQUE
*
*MODULES
*
* - - - - - - - - - - -  - - - - - - - - - - - - - - - - - - - - - - -*
*
#include "voir.cdk"
*
*
#include "symnom.cdk"
*
*
      integer  i
      character*4 cnom
*     
      symetri = .true.
*     
      
      do i = 1,nnoms
         if (cnom.eq.noms(i)) then
            symetri = ssym(i) 
            return
         endif
      enddo
*
      if (message) write(6,101)cnom
 101  format(//2x,' **** LA SYMETRIE DE LA VARIABLE- ', 
     $     a2,' - EST INCONNUE',
     $     ' ON LA SUPPOSE SYMETRIQUE *****'//)
*
      call cmetsym(cnom, .true.)
      return
      end 
*
***S/P CONLALO   CALCUL LAT LONG DE CHAQUE PT D'UNE GRILLE TYPE "Y" OU "Z"
*
      subroutine conlalo(lat,lon,ni,nj,grtyp,grtypxy,ig1,ig2,ig3,ig4)
#include "impnone.cdk"
      
      
      external conlal2
      
      
      integer lat,lon,ni,nj,grtyp,grtypxy,ig1,ig2,ig3,ig4
      character*1 cgrtyp, cgtypxy
      
      
      write(cgrtyp    , '(A1)') grtyp
      write(cgtypxy, '(A1)') grtypxy
      write(6,101) cgrtyp, cgtypxy
 101  format(' CONLALO:','CGRTYP: ',a1, 'CGTYPXY: ', a1)
      
      
      call conlal2(lat,lon,ni,nj,cgrtyp,cgtypxy,ig1,ig2,ig3,ig4)
      
      
      return
      end
      subroutine conlal2(lat,lon,ni,nj,cgrtyp,cgtypxy,ig1,ig2,ig3,ig4)
*     
#include "impnone.cdk"
*     
*AUTEUR   - P. SARRAZIN JANVIER 87 DRPN DORVAL P.Q. CANADA
*
*LANGAGE - RATFOR
*
*OBJET(CONLALO)
*          CALCULER LA LATITUDE ET LA LONGITUDE DE TOUS LES POINTS
*          DE LA GRILLE DE SORTIE DE TYPE "Y" OU "Z"
*
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*------------------------------------------------------
      external cigaxg,llfxy,pgsmabt,messags
*     
      integer ni,nj,ig1,ig2,ig3,ig4,i,j,hem
      real lat(ni,nj),lon(ni,nj),dlat,lat0,dlon,lon0
      real pii,pjj,d60,dgrw,buflat,buflon,dla,dlo 
      real xlat1,xlon1,xlat2,xlon2
*     
      character*1 cgrtyp, cgtypxy
      
*     
      if (cgrtyp.eq.'Z') then
*
*   ATTENTION BOUCLE SUIVANTE NJ PERMET D'AVOIR DES NI>NJ SANS PROBLEME
*
         do j=nj,1,-1
            lat(1,j)=lat(j,1)
         enddo
*     
         do i=1,ni
            do j=1,nj 
               lat(i,j)=lat(1,j)
               lon(i,j)=lon(i,1)
            enddo
         enddo
      endif
*     
      hem=1
      if (cgtypxy.eq.'S') hem=2 
*     
      if (cgtypxy.eq.'N'.or.cgtypxy.eq.'S')  then
         call cigaxg(cgtypxy,pii,pjj,d60,dgrw,ig1,ig2,ig3,ig4)
*     
         do i=1,ni
            do j=1,nj
               buflat=lat(i,j) - pjj
               buflon=lon(i,j) - pii
               call llfxy(dla,dlo,buflon,buflat,d60,dgrw,hem)
               if (dlo.le.0.0) dlo=dlo + 360.0
               lat(i,j)=dla
               lon(i,j)=dlo
            enddo
         enddo
      else if (cgtypxy.eq.'L') then
         call cigaxg(cgtypxy,lat0,lon0,dlat,dlon,ig1,ig2,ig3,ig4)
*     
         do i=1,ni
            do j=1,nj
               lat(i,j) = lat(i,j)*dlat + lat0 
               lon(i,j) = lon(i,j)*dlon + lon0 
            enddo
         enddo
      else
         write(6,*)' TYPE DE GRILLE PAS "N","S","L" '
         write(6,*) 'DIRECTIVE GRILLE(TAPE1/TAPE2.....OUCH???'
         call pgsmabt
      endif
*     
      return
      end
      subroutine conlale(lat,lon,latg,long,ni,nj,
     $                   cgrtyp,cgtypxy,ig1,ig2,ig3,ig4)
*     
#include "impnone.cdk"
*
*AUTEUR   - Y. Chartier DRPN Dorval Avril 94
*
*LANGAGE - RATFOR
*
*OBJET(CONLALO)
*          CALCULER LA LATITUDE ET LA LONGITUDE DE TOUS LES POINTS
*          DE LA GRILLE DE SORTIE DE TYPE "Y" OU "Z"
*
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*------------------------------------------------------
      external cigaxg,llfxy,pgsmabt,messags
*
      integer ni,nj,ig1,ig2,ig3,ig4,i,j,hem
      real lat(ni,nj),lon(ni,nj),latg(ni,nj),long(ni,nj),dlat,
     $     lat0,dlon,lon0
      real pii,pjj,d60,dgrw,buflat,buflon,dla,dlo 
      real xlat1,xlon1,xlat2,xlon2
*     
      character*1 cgrtyp, cgtypxy
  
*
      if (cgrtyp.eq.'Z') then
         do j=nj,1,-1
            lat(1,j)=lat(j,1)
         enddo

         do i=1,ni 
            do j=1,nj  
               latg(i,j)=lat(1,j)
               long(i,j)=lon(i,1)
            enddo
         enddo
*
         call cigaxg(cgtypxy,xlat1,xlon1,xlat2,xlon2,ig1,ig2,ig3,ig4)
         call ez_gfllfxy(lon,lat,long,latg,ni*nj,xlat1,xlon1,xlat2,xlon2)
      else 
         write(6,*)' TYPE DE GRILLE PAS "E"'
         write(6,*) 'DIRECTIVE GRILLE(TAPE1/TAPE2.....OUCH???'
         call pgsmabt
      endif
*     
      return
      end
      

*
***S/P GRIGEF   CALCUL LAT LONG DE CHAQUE PT D'UNE GRILLE "E"
*
      subroutine grigef(it,nni,nnj,xlat1,xlon1,xlat2,xlon2)
#include "impnone.cdk"
*
*AUTEUR   - y. chartier april 94
*
*LANGAGE - RATFOR
*     
*     OBJET(GRISTDB)
*     CALCULER LA LATITUDE ET LA LONGITUDE DE TOUS LES POINTS
*     DE LA GRILLE DE SORTIE STANDARD 'e' LAT ET LONG EQUIDISTANT
*     LONGITUDE ZERO ET 360 PRESENT.
*     
*     
*------------------------------------------------------
      external memoir,pgsmabt,grll,lastcol,messags
      external ezqkdef
      integer ezqkdef
*     
*     
#include "llccmm.cdk"
*     
*     
#include "grilles.cdk"
*     
*     
      integer nni,nnj,it,ier
      real xlat1,xlon1,xlat2,xlon2
      real xla0,xlo0,dlat,dlon,valeur
*     
      li=nni
      lj=nnj
*
*     
*     RESERVER MEMOIR POUR LATITUDE ET LONGITUDE
*     
      call hpalloc(tmplatp,nni*nnj,ier,1)
      call hpalloc(tmplonp,nni*nnj,ier,1)
      call hpalloc(tmplatgp,nni*nnj,ier,1)
      call hpalloc(tmplongp,nni*nnj,ier,1)
*     
      cgrtyp='E'
      call cxgaig(cgrtyp,lg1,lg2,lg3,lg4,xlat1,xlon1,xlat2,xlon2)
      gdout = ezqkdef(li,lj,cgrtyp,lg1,lg2,lg3,lg4,0)
      
      return
      end 
      
      
      subroutine initid
#include "impnone.cdk"
#include "idents.cdk"

      integer i

      qposition = 0
      qcsepar = 'T'
      qcform = 'f12.5'
      qnitems = 0
      do i=1,16
         qitems(i) = 0
      enddo

      return
      end
*
***S/P CMETSYM   MISE A JOUR DES TABLES DE SYMETRIE
*
      subroutine cmetsym(cnom,sym) 
#include "impnone.cdk"
      external pgsmabt,messags
*
*AUTEUR  P.SARRAZIN  FEVRIER 82  DRPN DORVAL  P.Q. CANADA
*
*LANGAGE RATFOR
*
*OBJET(CMETSYM)
*          DEFINIR NOM D UN CHAMP AVEC .TRUE. OU .FALSE.
*          VRAI=SYMETRIQUE  FAUX ANTISYMETRIQUE
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*ARGUMENTS
*  IN   NOM    NOM DU CHAMP
*  IN   SYM    VALEUR  .TRUE. / .FALSE. 
*
*IMPLICITES
*MESSAGES 
*         PLUS DE PLACE DANS LES TABLES DE SYMETRIE
*         MAUVAISE DIRECTIVE METSYM DOIT AVOIR 2 ARGUMENTS
*
*
*APPEL    - VIA MAIN PGSM
*         CALL CMETSYM(CNOM,.TRUE./.FALSE.)
*
*
*MODULES  PGSMABT
*
*---------------------------------------------------------------------
*
#include "defin.cdk"
#include "symnom.cdk"
#include "voir.cdk"
#include "dummys.cdk"
*
  
      logical sym
      character*4 cnom 
*     
*     sauve nsym dans nsymm a cause readlx qui remet a zero      nsymm = nsym 
*
      if (nnoms.lt.maxnoms) then
         nnoms = nnoms + 1
         ssym(nnoms) = sym
         noms(nnoms) = cnom
      else
         if (message) then
            write(6,*)
     $           'PLUS DE PLACE DANS LES TABLES DE SYMETRIE(METSYM)'
         endif
      endif
      
      return 
      end
***   S/P METSYM   MISE A JOUR DES TABLES DE SYMETRIE
*     
      subroutine metsym(nom,sym) 
#include "impnone.cdk"
      external cmetsym
*
*AUTEUR  P.SARRAZIN  FEVRIER 82  DRPN DORVAL  P.Q. CANADA
*
*REVISION 4.0.2
*   SEPARATION DE METSYM EN 2 PARTIES, L'UNE AVEC LE NOM STORE DANS UN ENTIER,
*      L'AUTRE AVEC LE NOM STORE DANS UNE CHAINE DE CARACTERES
*   Y. CHARTIER DRPN DORVAL QUEBEC
*LANGAGE RATFOR
*
*OBJET(METSYM)
*          INTERFACE A LA ROUTINE "CMETSYM"
*
      integer nom
      logical sym
      character*2 cnom
      
      write(cnom, '(A2)') nom
      write(6, *) 'METSYM: NOM - ',nom,'CNOM - ', cnom 
      call cmetsym(cnom, sym)
      
      
      return
      end
      

      subroutine putfld(fld, buf, iun,ibidon,iwrit,
     $     ni,nj,nbrow,npkc,istamp)
      integer iun, bidon, iwrit, ni,nj,nbrow, npck, istamp
      real fld(ni, nj)
      real buf(ni, nj)
      
      call putfld1(fld, ni*nj, iun)
      
      return
      end
      
      subroutine putfld1(fld, ni, iun)
      integer ni, iun
      real fld(ni)
      
      write(iun) (fld(i), i=1,ni)
      
      return 
      end
      
c     ***************************************************************
c     *                        F I L T R E                          *
c     * Object :                                                    *
c     *         To filter data.                                     *
c     *                                                             *
c     * Arguments :                                                 *
c     *            IN /  ni    : x dimension of data                *
c     *            IN /  nj    : y dimension of data                *
c     *            IN /  Npass : nombre de passes pour le filtrage  * 
c     *            IN /  list  : list des nombres de filtre        *
c     *            IN /  L     : dimension de la list              *
c     *         IN/OUT/  slab  : les donnees a filtrer              *
c     *                                                             *
c     ***************************************************************
      subroutine filtre (slab, NI, NJ, nrows, Npass, list, L)
      implicit none
      
      integer NI, NJ, nrows
      integer l,list(L)
      real slab(NI ,NJ)
      real facteur(-4:4,5)
      real temp
      integer k,I,J, ier
      integer nb_elm
      integer Npass, pass
      integer nb_elem, lng_list, istart, iend
      real sum
    
      real result1(ni), result2(nj)
 
      nb_elem = (l+1)/2
      istart = -nb_elem + 1
      iend = nb_elem -1

      do j=1, nb_elem
         do I=istart,iend
           facteur(i,j) = 0.0
         enddo
      enddo

      do j=1, nb_elem-1
         sum = 0.0
         do i=-j,j
            sum = sum + list(I+nb_elem)
         enddo

         do i=-j,j
            facteur(i,nb_elem-j) = 1.0*(list(i+nb_elem)) / sum
         enddo
      enddo
      do pass=1, Npass
         do J=1, NJ
            do I=2, NI-1
               temp = 0
               nb_elm = min(I-1,NI-I,L/2)
               do k = -nb_elm, nb_elm
                  temp = temp + slab(I+k,J) *
     %                 facteur(k,(L/2+1)-nb_elm)
               enddo
               result1(I) = temp
            enddo
            do I=2, NI-1
               slab(I,J) = result1(I)
            enddo
         enddo
         
         do I=1, NI
            do J=2, NJ-1
               temp=0
               nb_elm = min(J-1,NJ-J,L/2)
               do k = -nb_elm, nb_elm
                  temp = temp + slab(I,J+k) * 
     %                 facteur(k,(L/2+1)-nb_elm)
               enddo
               result2(J) = temp
            enddo
            do J=2, NJ-1
               slab(I,J) = result2(J)
            enddo
         enddo
      enddo
      
      return
      end
      

      subroutine testseq

      integer nigem, njgem, nigauss, njgauss
      parameter (nigem = 160)
      parameter (njgem = 1)

      real champ(nigem,njgem)
      character*24 chaine
      
      character*4 nomvar, cbidon2
      character*2 typvar, bidon1, grtyp, grref, cbidon1
      character*12 etiket, cbidon8
      

      ier = fnom(iun,'bofseq','SEQ+FTN+UNF',0)

      rewind(iun)
 10   read (iun,err=13) npac,idat, ideet, npas, ni, nj, nk, 
     $              ip1, ip2o, ip3o, llg1, llg2, llg3, llg4, idatyp,
     $              chaine
      print *,  npac,idat, deet, npas, ni, nj, nk, 
     $              ip1, ip2o, ip3o, llg1, llg2, llg3, llg4, idatyp,
     $              chaine
      read (iun) champ
      print *, champ
      goto 10

 13   continue
      stop 
      end
*     
***   S/P  CONVER, PLMNMOD ECART AU CHAMP ET MULTIPLIER PAR FACTEUR
*     
*     AUTEUR P.SARRAZIN MAI 82 DRPN DORVAL QUEBEC CANADA
*     
      subroutine conver(z, ni, nj, cnom)
#include "impnone.cdk"
*     
*LANGAGE RATFOR
*
*OBJET(CONVER)
*          AUGMENTE UN CHAMP D UNE VALEUR UNIFORME (ECARTS) ET
*          MULTIPLIER PAR UN FACTEUR APPROPRIE ELIMINE LES VALEURS TROP PETITES 
*          OU TROP GRANDES PREDETERMINEES
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*ARGUMENTS
*  IN-OUT Z   - CHAMP(NI,NJ) QUI SERA MODIFIE
*  IN     NI  - NOMBRE DE PTS DANS LA DIRECTION EST-OUET
*  IN     NJ  - NOMBRE DE PTS DANS LA DIRECTION NORD-SUD
*  IN     NOM - NOM DE LA VARIABLE DU CHAMP A MODIFIER
*
*APPEL   VIA CALL
*        CALL CONVER(CHAMP,NI,NJ,NOM)  APPELLE DANS ECRITUR 
*
*  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
#include "voir.cdk"
*
*
#include "convers.cdk"
*
*
#include "dummys.cdk"
*
      integer ni,nj,i,k,j
      real z(ni,nj)
      character*4 cnom
*     
      if ( nomb .eq. 0 ) return
      
      k = 0
      do i = 1,nomb
         if (cnom .eq. nomss(i)) then
            k = i
            goto 10
         endif
      enddo
 10   continue
      
      if ( k .eq. 0 ) return
*     
      do j=1,nj
         do i=1,ni
            z(i,j) = amax1(bass(k),amin1(hauts(k),(z(i,j) + 
     $           ecarts(k))*facts(k)))
         enddo
      enddo
*     
      return 
      end
*     
***   S/P GRIGRIB  CALCUL LATITUDE LONGITUDE DE CHAQUE PT D'UNE GRILLE GRIB
*     
      subroutine grigrib(ig1,ig2,ig3,ig4)
#include "impnone.cdk"
*     
*     AUTEUR   -  Y. CHARTIER DRPN DORVAL MAI 1996
*     
*     
*     LANGAGE - RATFOR
*     
*     OBJET(GRIGRIB)
*     CALCULER LA LATITUDE ET LA LONGITUDE DE TOUS LES POINTS
*     DE LA GRILLE DE SORTIE POLAIRE STEREOGRAPHIQUE
*     
*     
*     LIBRAIRIES
*     -SOURCE  ARMNSRC,DRPN
*     -OBJET   PGSMLIB,ID=ARMNPJS.
*
*------------------------------------------------------
      external memoir,pgsmabt,grps,cigaxg,cxgaig,messags
*     
*     
#include "llccmm.cdk"
#include "grilles.cdk"
*     
      character*1 gtyout
      real xg(20)
      integer nni,nnj,ihm,hem,ier,npts
      integer ig1,ig2,ig3,ig4
      integer tmpig1, tmpig2, tmpig3, tmpig4
      real x,y
      integer ezqkdef
      external ezqkdef
      
      pointer (xp, x(*))
      pointer (yp, y(*))
*     
*     RESERVER MEMOIR POUR LATITUDE ET LONGITUDE
*     

      cgrtyp = '!'
      call igaxg95(gtyout,xg,15,cgrtyp,ig1,ig2,ig3,ig4)
      if (gtyout.eq.'H') then
         nni = nint(xg(8))
         nnj = nint(xg(9))
      endif
      
      call hpalloc(tmplatp,nni*nnj,ier,1)
      call hpalloc(tmplonp,nni*nnj,ier,1)
      call hpalloc(xp,     nni*nnj,ier,1)
      call hpalloc(yp,     nni*nnj,ier,1)
*     
*     
      li=nni
      lj=nnj
      lg1 = ig1
      lg2 = ig2
      lg3 = ig3
      lg4 = ig4
*     
*     
      npts = nni*nnj 
      call ez_llflamb(tmplat,tmplon,x,y,npts,cgrtyp,ig1,ig2,ig3,ig4)
*
*      call cxgaig('L', tmpig1, tmpig2, tmpig3, tmpig4,0.,0.,1.0,1.0)
*      gdout = ezgdef(npts,1,'Y','L', tmpig1, tmpig2, tmpig3, tmpig4,
*     $        tmplon,tmplat)

      gdout = ezqkdef(nni,nnj,cgrtyp,ig1,ig2,ig3,ig4,1)
      
      call hpdeallc(xp,ier, 1)
      call hpdeallc(yp,ier, 1)
      
      return
      end 
      

      subroutine initseq
#include "impnone.cdk"
#include "champseq.cdk"
      
*     
*     Initialisation des listes utilisees par champ_seq
*     
      integer  i,j 

      do i=1,nmaxlist1
         do j=1,nmaxlist2
            listnom(i,j) = '  '
            listniv(i,j) = -1
         enddo
         nitems1(i)=0
         nitems2(i)=0
      enddo
      ntitems = 0
      
      return
      end
      
*
***   S/P EXTRAIRE L'EXPONENTIEL DE CHAQUE POINT D UN CHAMP DANS ACCUMULATEUR
*     ET MULTIPLIER LE RESULTAT PAR LE FACT
      subroutine operat(fact,ecart,divi)
#include "impnone.cdk"
      external pgsmabt,messags
*
*AUTEUR P.SARRAZIN JUIN 83 DRPN DORVAL P.Q. CANADA
*
*LANGAGE RATFOR
*
*OBJET(OPERAT)
*         EXTRAIRE L'EXPONENTIEL OU LOGARITHME D UN CHAMP DANS
*         L'ACCUMULATEUR DEJA LUT PAR LA DIRECTIVE LIREE OU LIRES
*         ET MULTIPLIER LE RESULTAT PAR FACT
*         CALCUL LA MOYENNE DE CHAQUE POINT DU CHAMP DANS ACCUMULATEUR
*         PFOIS ADDITIONNER OU SOUSTRAIRE UNE CONSTANTE DU CHAMP DANS 
*         L'ACCUMULATEUR ET MULTIPLIER OU DIVISER LE RESULTAT
*         EXTRAIRE LA RACINE CARRE DE CHAQUE POINT DU CHAMP DANS ACCUMULATEUR
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*ARGUMENTS
*  IN    FACT    -FACTEUR DE CONVERSION 
*  IN    ECART    - UTILISER PAR PFOIS CONSTANTE AJOUTER A CHAQUE POINT
*  IN    DIVI     - UTILISER PAR PFOIS DIVISE CHAQUE POINT DU CHAMP
*
*
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*MESSAGES 
*        'DIRECTIVE LIREE OU LIRES DOIT ETRE APPELE '
*        'VERIFIER EXPON-PFOIS-MOYENE-RACINE-ALOGN'
*
*MODULES
*         PGSMABT
*
*APPEL    VIA DIRECTIVE
*          PFOIS(FACT,ECART,DIVI) - EXPON(FACT)- MOYENE(FACT) - ALOGN(FACT)
*          RACINE(FACT)
*
*---------------------------------------------------------------
*
*
#include "voir.cdk"
#include "chck.cdk"
#include "accum.cdk"
#include "llccmm.cdk"
*
* -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
      integer i,it,itot
      real divi,ec,ecart,fact
*     
*     VERIFIER SI DIRECTIVE LIREE OU LIRES A ETE APPELE
*     
*     pfois(+ecart*fact/divi)
      it=1
*
*   A CAUSE DE LA DOCUMENTATION ECART DEVIENT FACT POUR PFOIS
*
      ec=fact
      fact=ecart
      ecart=ec
*     erreur faut appeler liree ou lires
 1000 if (ichck.eq.0)   then
         write(6,*)' LIREE LIRES DOIT ETRE APPELE AVANT ' 
         write(6,*)' EXPON-PFOIS-MOYENE-RACINE-ALOGN'
         call pgsmabt
      endif
*     
*     IT=2 EXTRAIT L'EXPONENTIEL DE CHAQUE POINT ET MULTIPLIT PAR FACT
*     IT=0 EXTRAIT LE LOGARITHME DE CHAQUE POINT ET MULTIPLIT PAR FACT
*     IT=1 PFOIS AJOUTE ECART  MULTIPLIT PAR FACT ET DIVISE PAR DIVI
*     
*     IT=3 MOYENE CAL CUL LA MOYENNE DE CHAQUE POINT (ICNT)
*     IT=4 EXTRAIRE LA RACINE CARRE DE CHAQUE PT DU CHAMP 
*     
      if (it.eq.1) then
         if (message) write(6,*)' PFOIS(ECART,FACTEUR,DIVISEUR)'
      endif
*     $(  # exponentiel
      if (it.eq.2) then
         if (message) write(6,*)' EXPON(FACTEUR)'
      endif
*     $(  # moyenne
      if (it.eq.3) then
         if (message) write(6,*)' MOYENE(FACTEUR)'
      endif
      
*     $(  # racine 
      if (it.eq.4) then
         if (message) write(6,*)' RACINE(FACTEUR)'
      endif
*     $(  # logarithme
      if (it.eq.0)  then
         if (message) write(6,*)' ALOGN(FACTEUR)'
      endif
*     
      itot = nni*nnj
      if (it.eq.0) then
         do i=1,itot 
            tmpif0(i)= (alog(tmpif0(i))*fact)
         enddo
      endif

       if (it.eq.1) then
          do i=1,itot 
             tmpif0(i)= (tmpif0(i)+ecart)*fact/divi
          enddo
       endif

       if (it.eq.2) then
          do i=1,itot 
             tmpif0(i)= (exp(tmpif0(i))*fact)
          enddo
       endif
       
       if (it.eq.3) then
          do i=1,itot 
             tmpif0(i)=(tmpif0(i)/icnt)*fact
          enddo
       endif

       if (it.eq.4) then
          do i=1,itot 
             tmpif0(i)= (sqrt(tmpif0(i))*fact)
          enddo
       endif
       
       return
*     
       entry alogn(fact)
*
*    IT=0 ON CALCUL LE LOGARITE DE CHAQUE PT
*
       it=0
       go to 1000
*     
*     
*     EXPONENTIEL DE CHAQUE POINT DU CHAMP
*
       entry expon(fact)
       it=2
       go to 1000
*     
*     
*     PRENDRE LA MOYENNE DE CHAQUE PTS DES CHAMPS ACCUMULES
*     DANS L'ACCUMULATEUR ET MULTIPLIER PAR FACT 
*     
       entry moyene(fact)
       it=3
*     
*     VERIFIER SI COMPTEUR EST PLUS GRAND QUE 1
*     
*     # erreur
       if (icnt.le.1) then
          if (message) then
             write(6,*)'ON DIVISE PAR UNE VALEUR < OU = A 1 ICNT=',icnt
             if (message) then
                write(6,*)
     $          '   ******  ATTENTION A LA DIRECTIVE MOYENE  ******'
             endif
          endif
       endif
*     
       go to 1000
*     
*     PRENDRE LA RACINE CARRE DE CHAQUE POINT DANS LE CHAMP ACCUMULA
*     ET MULTIPLIER CHAQUE POINT PAR FACT
*     
       entry racine(fact)
       it=4
       go to 1000
       end
      
      
*     
***S/P QAAQR   CALCUL TOURBILLON RELATIF
*
      subroutine qaaqr(qaqr, li, lj, xlat) 
#include "impnone.cdk"
*
*AUTEUR  P. SARRAZIN DORVAL QUEBEC JUIN 83 DRPN
*
*LANGAGE RATFOR
*
*OBJET(QAAQR)
*            CALCUL LE CORIOLIS PARAMETER POUR CHAQUE POINT DE LA GRILLE
*            SOUSTRAIRE CE CHAMP DU CHAMP DU TOURBILLON ABSOLU ON GENERE
*            UN TOURBILONN RELATIF
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*ARGUMENTS
*  IN OUT QAQR  CHAMP CONTENANT TOURBILLON ABSOLU 
*  IN     LI    NOMBRE DE POINTS SUR UNE RANGEE DU CHAMP QAQR
*  IN     LJ    NOMBRE DE POINTS DANS UNE COLONNE DU CHAMP QAQR
*  IN     XLAT  LATITUDE POUR CHAQUE POINT DU CHAMP QAQR
*
*APPEL
*         -VIA ROUTINE SCALAIR
*         CALL QAAQR(QAQR, LI, LJ, XLAT)
*
*MESSAGES 
*          -AUCUN
*
*IMPLICITES
*         - AUCUN
*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*
*
      integer i,j,li,lj
      real xlat(li,lj),qaqr(li,lj),degarad,omega2
*
*
*  rotation de la terre 7.292*1.e-5

      degarad = 3.1415926535/180.
      omega2= 2*7.292*1.e-5  
*
*
      do j= 1,lj
         do i = 1,li
            qaqr(i,j) = qaqr(i,j) - omega2*sin(xlat(i,j)*degarad)
         enddo
      enddo
*
      return 
      end
      
*
***s/p uvectur interpolation des vecteurs u-v (horizontalement)
*
      subroutine uvectur (cnom1, cnom2, cnom3,iheur, npar, itabuv)
#include "impnone.cdk"
      external ecritur,cigaxg,fstinf,fstinl,pgsmlic,pgsmlir,memoir,
     $     fstcvt,fstprm,pgsmabt,imprime,vdauv,
     $     incdat,fstopc,messags
      external liraxez,  cxgaig
      integer fstinf,fstinl,pgsmlir,fstprm,fstopc,fstcvt,pgsmlic
      integer ezqkdef, ezwdint, ezuvint, ezdefset
      real fbidon
#include "defin.cdk"
*     
*auteur  p.sarrazin fevrier 82 drpn  dorval p.q. canada
*revision 4.0.2
*   conversion des variables hollerith en caracteres
*   y. chartier -aout 90- drpn dorval quebec
*
*langage ratfor
*
*objet(uvectur)
*         interpolation des vecteurs u et v
*
*librairies
*         -source  armnsrc,drpn
*         -objet   pgsmlib,id=armnpjs.
*
*arguments
*  in    nom1   nom du premier vecteur  ex:"uu","us"...
*  in    nom2   nom du deuxieme vecteur ex:"vv","vs"...
*  in    nom3   nom du champ a ecrire apres interpolation du vent ex:"uv"
*  in    iheur   heure de la variable
*  in    npar    nombre de locations dnas itabuv
*  in    itabuv table contenant les noms (niveau) 
*
*appel
*         -via routine champ
*         call uvectur(iheur, npar, itabuv)
*
*
*modules  fstinf,pgsmabt,memoir,fstprm,pgsmlir,cuvint,cigaxg,cspauv,ecritur
*
*messages 
*         mauvaise directive champ (uvectur)
*         record n'existe pas sur fichier d'entre (u,v) (uvectur)
*         aucune interpolation horizontale u v
*
*----------------------------------------------------------------------
*
#include "llccmm.cdk"
#include "accum.cdk"
#include "lires.cdk"
#include "pairs.cdk"
#include "dummys.cdk"
#include "ecrires.cdk"
#include "indptr.cdk"
#include "dates.cdk"
#include "grilles.cdk"
#include "voir.cdk"
#include "enrege.cdk"
#include "packin.cdk"
#include "chck.cdk"
#include "gdz.cdk"
#include "tp12ig.cdk"
*
*---------------------------------------------------------------

      character*12 cetiket,cetike 
      character*4 cnomvar,cnom1,cnom2, cnom3
      character*1 cigtyp
      character*2 ctypvar
      
      integer i
      integer jp1,jp2,jp3,liljt,ni,nj,nk,npar
      integer itabuv(npar) ,listniv(24000),deet,ig1,ig2,ig3,ig4
      integer iheur,ilop,iprs,irecu,irecv,iopc
      integer numu,numv,infon,dat,datdv
      integer cnbits,cdatyp,cswa,clng,cdltf,cubc,extra1,extra2,extra3
      integer nom2
      integer ig1zz, ig2zz, ig3zz, ig4zz
      real    d60dum, pidum, pjdum
      real xlat1,xlon1,xlat2,xlon2
      real dgtord,dumfld,xg1,xg2,xg3,xg4
      integer iunit
      logical ssw

      real*8 delta_t
      
      iunit = 1
*     
*
      do 23000 iprs = 1,npar 
*     
*     trouver record pour u,v  ou us,vs .....
*     
         if (date .eq. 1) then
            if (date3.eq.-1) then
               date=date2
            else
               call newdate(date, date2, date3, 3)
            endif
         endif

*     
*     modification de hollerith a caractere
*     
         if (etikent(1) .ne. -1) then
            write(cetiket,'(2A4)') (etikent(i), i=1,nwetike)
         else 
            cetiket = '        '
         endif
         
         if (typeent .ne. -1) then
            write(ctypvar, '(A1)') typeent
         else 
            ctypvar = ' ' 
         endif
         
         
         ier = fstinl(1,ni,nj,nk,date,cetiket,itabuv(iprs),
     $        iheur,ip3ent,ctypvar,cnom1,listniv,infon,24000)
         if (ier .lt. 0 .or. infon.eq.0) then
            write(6,610) cnom1
 610        format(' AUCUN RECORD SUR FICHIER (FSTINL-UVECTUR) NOM=',a2)
            goto 23000
         endif
         
         if (nk.gt.1) then
            write(6,*)'***********************************************'
            write(6,*)'         PGSM N ACCEPTE PAS UN          '
            write(6,*)' CHAMP DE 3 DIMENSIONS NK>1 ?? (UVECTUR)'
            write(6,*)'***********************************************'
            call pgsmabt
         endif
*     
*     
         do ilop=1,infon
*     
            irecu=listniv(ilop)
*     
*     identifier parametres champ nom1
*     
            cetike = '        '
            ier = fstprm( irecu, dat,deet,npas,ni, nj, nk, 
     $           cnbits,cdatyp,jp1,jp2, jp3,ctypvar,
     $           cnomvar,cetike,cigtyp, ig1,ig2,ig3,ig4,
     $           cswa, clng, cdltf, cubc, extra1, extra2, extra3)
            if (ier .lt. 0) then
               write(6,*)' IER = FSTPRM NEGATIF VOIR UVECTUR'
            endif
*     
*     verifier si grille gaussienne ni doit etre pair
*     
 675        format(' ITYP=',a1,'   CIGTYP DE FSTPRM= ',a1)
            
            if (cigtyp.eq.'G'.and.mod(ni,2).ne.0)  call messags(ni)
*     
*     calcul la date pour le record de la variable nom2
*     
            delta_t = deet*npas/3600.0
            call incdatr(datdv,dat,delta_t)
            irecv = fstinf(1,ni,nj,nk,datdv,cetike,jp1,jp2,jp3,
     $           ctypvar,cnom2)
            if (irecv .lt. 0) then
               write(6,610) nom2 
               call pgsmabt
            endif
            
            if (nk.gt.1) then
             write(6,*)'********************************************'
             write(6,*)'         PGSM N ACCEPTE PAS UN          '
             write(6,*)' CHAMP DE 3 DIMENSIONS NK>1 ?? (UVECTUR)'
             write(6,*)'********************************************'
             call pgsmabt
          endif
          
*     allouer memoire
          
          call hpalloc(tmpif1p,ni*nj,ier,1)
          call hpalloc(tmpif2p,ni*nj,ier,1)
          call hpalloc(tmpif3p,li*lj,ier,1)
          call hpalloc(tmpif4p,li*lj,ier,1)
          
*     
*     lire champ nom1
*     
          if (.not.message) iopc= fstopc('TOLRNC','DEBUGS',.true.)
          numu =pgsmlir(tmpif1,1,ni,nj,nk,datdv,cetike,jp1,jp2,jp3,
     $         ctypvar,cnom1,cigtyp)
          
          if (printen)  call imprime(cnom1,tmpif1,ni,nj)
          if (.not.message) iopc= fstopc('TOLRNC','DEBUGS',.true.)
          numv = pgsmlic(tmpif2,1,ni,nj,nk,datdv,cetike,jp1,jp2,jp3, 
     $         ctypvar,cnom2,ig1,ig2,ig3,ig4,cigtyp)
          if (cigtyp.eq.'G'.and.mod(ni,2).ne.0)  call messags(ni)
*     
          if (printen)  call imprime(cnom2,tmpif2,ni,nj)
*****************************************************************
*     si vvent=.true. on calcule la vitesse du vent
          
          gdin = ezqkdef(ni, nj, cigtyp, ig1, ig2, ig3, ig4, iunit)
          ier = ezdefset(gdout, gdin)
          
          if (vvent) then
             ssw=.false. 
             if (wdvent) then
                ssw = .true.
             endif
             
             ier = ezwdint(tmpif3, tmpif4, tmpif1, tmpif2)
             
*     if (cigtyp .eq. 'Z') then
*     call liraxez(1, ni,nj,1,ig1,ig2,ig3,ig4)
*     call iguvint(tmpif3,tmpif4,li,lj,tmplat,tmplon,
*     $              tmpif1,tmpif2,ni,nj,cigtyp,
*     $              grref,ig1ref,ig2ref,ig3ref,ig4ref,ssw,
*     $              axex(iaxex), axey(iaxey))
*     else
*     call rguvint(tmpif3,tmpif4,li,lj,tmplat,tmplon,
*     $              tmpif1,tmpif2,ni,nj,cigtyp,
*     $              ig1,ig2,ig3,ig4,ssw)
*     
*     ecrire vitesse de vent
*     
             call  ecritur(tmpif3,npack,dat,deet,npas,li,lj,1,
     $            jp1,jp2,jp3,ctypvar,cnom3,cetike,cgrtyp,
     $            lg1,lg2,lg3,lg4)
             
             if (wdvent) then
                do i=1,li*lj
                   if (tmpif4(i).lt.0.0) then
                      tmpif4(i) = tmpif4(i) + 360.0
                   endif
                enddo
                call ecritur(tmpif4,npack,dat,deet,npas,li,lj,1,
     $               jp1,jp2,jp3,ctypvar,'WD',cetike,cgrtyp,
     $               lg1,lg2,lg3,lg4)
             endif
             
*     
*****************************************************************
*     
          else 
*     
*     on ne fait pas d'interpolation si igtyp=grtyp  ig1=lg1  ig2=lg2
*     ig3=lg3  ig4=lg4
*     
             if (cigtyp.ne.cgrtyp.or.ig1.ne.lg1.or.ig2.ne.lg2.or.
     $            ig3.ne.lg3.or.ig4.ne.lg4.or.
     $            li.ne.ni.or.lj.ne.nj) then
*     
*     interpolation u,v vecteur a vitesse et direction du vent
*     
*     si ssw = vrai interpoler vitesse et direction
*     faux interpoler seulement vitesse
*     
                ssw = .true.
*     
                ier = ezuvint(tmpif3, tmpif4, tmpif1, tmpif2)
*     
*     apres interpolation horizontale passer de vitesse et direction
*     aux composantes u et v
*     
*     si type de grille "x",    u-v interpolation n\s - e\o
*     
                
             else
               call hpdeallc(tmpif3p,ier,1)
               call hpdeallc(tmpif4p,ier,1)
               tmpif3p = tmpif1p
               tmpif4p = tmpif2p
               if (message) then
                  write(6,*)'AUCUNE INTERPOLATION HORIZONTALE '
               endif
            endif
*     
*     ecrire vecteur u
*     
            call ecritur(tmpif3,npack,dat,deet,npas,li,lj,1,
     $           jp1,jp2,jp3,ctypvar,cnom1,cetike,cgrtyp,
     $           lg1,lg2,lg3,lg4)
*     
*     
*     ecrire vecteur v
*     
            call ecritur(tmpif4,npack,dat,deet,npas,li,lj,1,
     $           jp1,jp2,jp3,ctypvar,cnom2,cetike,cgrtyp,
     $           lg1,lg2,lg3,lg4)
*     
*     fin du calcul des composantes
*     
*     
         endif
         
         call hpdeallc(tmpif1p,ier,1)
         call hpdeallc(tmpif2p,ier,1)
         
         if (tmpif3p .ne. tmpif1p) call hpdeallc(tmpif3p,ier,1)
         if (tmpif4p .ne. tmpif2p)  call hpdeallc(tmpif4p,ier,1)
      enddo
*     
*     
*     reinitialiser clef de controle
*     
23000 enddo
      vvent=.false. 
*     
*     
      return 
      end
      
      
*
***   s/p convs, batir une table avec noms,ecart,facteur,bas,haut
*     
      subroutine convs(nom,  ecart,  facteur, bas, haut)
#include "impnone.cdk"
*     
*auteur p. sarrazin mai 82 drpn dorval quebec canada
*     
*     langage ratfor
*     
*     objet(convs)
*     la directive convs assigne a chaque table la valeur appropriee
*     les tables augmentent a chaque appel convs
*     
*arguments
*     in    nom    nom du champ que l on veut modifier
*     in    ecart  valeur plmnmodr au champ
*     in    facteur valeur utiliser pour multiplication
*     champ(i,j)=(champ(i,j) + ecart)*facteur
*     in    bas    valeur < bas auront la valeur de bas
*     in    haut   valeur du champ > haut auront la valeur de haut
*     
*implicites
*     appel   via directive
*     conv(nom,ecart,facteur,bas,haut)
*     
*     messages 
*     plus de 40 changements d'echelle routine convs
*
*   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
#include "voir.cdk"
#include "convers.cdk"
#include "dummys.cdk"
*
*     trouver si le nom existe
*     oui- remplacer
*     non- plmnmodr
*     
      external fstcvt
      integer  nom,i,ier, fstcvt
      character*4 cnom, cnoma
      real bas,ecart,facteur,haut
*     
      write(cnom,'(A2)') nom	
      
      cnoma = cnom 
      i = 1
 10   if (i.le.nomb) then
         if (cnoma.ne.nomss(i)) then
            i = i + 1 
            goto 10
         endif
      endif
*     
*     definir nomb danger si plus grand que 40
*     
      nomb = max0(nomb,i)
      if (nomb.lt.40) then
         hauts(i)=1.e+30
         bass(i)= -hauts(i)
         ecarts(i) = ecart
         facts(i) = facteur
         nomss(i) = cnoma
         if (ncon.ge.4) bass(i)=bas
         if (ncon.eq.5) hauts(i)=haut
      else
         if (message) then
            write(6,*)'PLUS DE 40 DIRECTIVES "CONVS" --- RESTE IGNORE'
         endif
      endif
      return
      end
      
*
***S/P GRILLE   DETERMINE LA SORTE DE GRILLE DEMANDE PAR USAGER
*
      subroutine grille2(it,p1,p2,p3,p4,p5,p6,p7,p8)
#include "impnone.cdk"
*
*AUTEUR   - P. SARRAZIN JANVIER 82 DRPN DORVAL P.Q. CANADA
*           MODIFIER JANVIER 87 P.SARRAZIN DORVAL P.Q. CANADA
*           MODIFIER MAI 87 P. SARRAZIN DORVAL P.Q. CANADA
*
*LANGAGE - RATFOR
*
*OBJET(GRILLE)
*          VERIFI  LE NOMBRE D ARGUMENTS LA VALEUR DU PREMIER ARGUMENT
*          DETERMINE LE TYPE DE GRILLE DE SORTIE, RETOURNE LA MEMOIRE 
*          POUR IXLAT INITIALISE A ZERO DANS LE MAIN PGSM.
*
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*ARGUMENTS
*   IN   IT    - 1= GRILLE STANDARD
*                2= GRILLE LAT-LON
*                3= GRILLE P.S. POLAIRE STEREOGRAPHIQUE
*                4= TAPE4 FICHIER CONTENANT LATITUDES LONGITUDES
*                 OU COORDONNEES EST-OUEST OU NORD-SUD
*                5- STDB GRILLE STANDARD 'B'
*                6= GRILLE GAUSSIENNE
*                7= GRILLE TAPE1 1 REC LAT,Y  1 REC LON,X
*                8= GRILLE TAPE2 ECRIT 1 REC LAT,Y 1 REC LON,X SUR TAPE2
*                9= GRILLE GEF
*               10= GRILLE GRIB
*               11= COORDONNEES LOCALES
*
*MESSAGES 
*         DIRECTIVE SORTIE DOIT-ETRE APPELE AVANT DIRECTIVE GRILLE
*         GRILLE INCONUE(GRILLE)
*
*MODULES PGSMABT,GRILSTD,GRLALON,GRILLPS,GRILTP4,GRIGAUS,GRISTDB
*MODULES GRITP12,MEMOIR,LLFXY 
*------------------------------------------------------
*
#include "llccmm.cdk"
#include "indptr.cdk"
#include "grilles.cdk"
*
      external pgsmabt,grilstd,grlalon,grillps,griltp4,grigaus,gristdb,messags
      external gritp12,memoir
*     external verlalo, chklalo               
*
      integer ier,it,p1,p2,p3,p4,p5,p6,p7,p8
*     
*     
      if (iset.eq.-2) then
         write(6,*)
     $      'DIRECTIVE SORTIE DOIT-ETRE APPELEE AVANT DIRECTIVE GRILLE'
         call pgsmabt
      endif
*     
      cgtypxy='L'
*
      if (tmplatp .ne.0)  call hpdeallc(tmplatp,ier,1)
      tmplatp=0
      if (tmplonp .ne.0)  call hpdeallc(tmplonp,ier,1)
      tmplonp=0
      
      if (tmplatgp .ne.0)  call hpdeallc(tmplatgp,ier,1)
      tmplatgp=0
      if (tmplongp .ne.0)  call hpdeallc(tmplongp,ier,1)
      tmplongp=0
      
*     
      if (it.lt.0 .or. it.gt.14) then
         write(6,*)'GRILLE INCONNUE (GRILLE)'
         call pgsmabt
      endif
*     
      if (it.eq.gr_a) then
*     
*     
*     CALCUL GRILLE STD
*     ----------
*     
         if (ngr.eq.4) then
            call grilstd(p1,p2,p3)
*     
*     NI =P1  NOMBRE DE POINTS EST-OUEST
*     NJ =P2  NOMBRE DE POINTS NORD SUD 
*     LG1=P3  0=GLOBAL;  1=H. NORD;  2=H. SUD
*     
         else
            write(6,*) ' MAUVAIS APPEL GRILLE(STD,NI,NJ,NORD/SUD/GLOBAL)'
            call pgsmabt
         endif
*...................................................................
*     
*     CALCUL GRILLE LATLON
*     -------------
         
      elseif (it.eq.gr_latlon) then
         if (ngr.eq.7) then
            
            call grlalon(p1,p2,p3,p4,p5,p6)
*     
*     NI=P1      NOMBRE DE POINTS EST-OUEST
*     NJ=P2      NOMBRE DE POINTS NORD-SUD
*     XLAT0=P3   1 IERE LAT EN BAS A GAUCHE
*     XLON0=P4   1 IERE LONG EN BAS A GAUCHE 
*     DLAT=P5    ESPACEMENT ENTRE CHAQUE LATITUDE
*     DLON=P6    ESPACEMENT ENTRE CHAQUE LONGITUDE
*     
         else
            write(6,*)
     $           'MAUVAIS APPEL GRILLE(LATLON,NI,NJ,XLAT0,XLON0,DLAT,DLON)'
            call pgsmabt
         endif
*     
*...................................................................
      elseif (it.eq.gr_ps) then
*     CALCUL GRILLE PS
*     ---------
*     
         if (ngr.eq.7) then
            call grillps(p1,p2,p3,p4,p5,p6,1)
         else if (ngr.eq.8) then
            call grillps(p1,p2,p3,p4,p5,p6,p7)
*     
*     NI=P1.........NOMBRE DE POINTS DANS DIRECTION EST-OUEST
*     NJ=P2.........NOMBRE DE POINTS DANS DIRECTION NORD-SUD
*     PI=P3.........POSITION DU POLE DIRECTION EST-OUEST (GRID POINT)
*     PJ=P4.........POSITION DU POLE DIRECTION NORD SUD (GRID POINT)
*     D60=P5........DISTANCE ENTRE 2 GRID POINTS EN METRES
*     DGRW=P6.......ORIENTATION DE LA GRILLE PAR RAPPORT A GREENWICH
*     NORD/SUD=P7...HEMISPHERE NORD/SUD
*     
         else
            write(6,*)
     $           'MAUVAIS APPEL GRILLE(PS,NI,NJ,PI,PJ,D60,DGRW,NORD/SUD)'
            call pgsmabt
         endif
*
*...................................................................
*
*   CALCUL GRILLE TAPE4
*          ------------
      elseif (it.eq.gr_tape4) then
         if (ngr.eq.6) then
            call griltp4(p1,p2,p3,p4,p5)
         else if (ngr.eq.3) then
            call griltp4(p1,p2,-1,-1,-1)
*     
*     NI=P1.....NOMBRE DE POINTS EST-OUEST
*     NJ=P2.....NOMBRE DE POINTS NORD-SUD
*     IP1=P3....VALEUR DE IP1 TRANSFER DANS IG1 POUR TAPE2
*     IP2=P4....VALEUR DE IP2 TRANSFER DANS IG2 POUR TAPE2
*     IP3=P5....VALEUR DE IP3 TRANSFER DANS IG3 POUR TAPE2
*     
         else 
            write(6,*) 'MAUVAIS APPEL  GRILLE(TAPE4,NI,NJ [,IP1,IP2,IP3] )'
         write(6,*)' CETTE DIRECTIVE CONTIENT 3 OU 6 ARGUMENTS'
         call pgsmabt
      endif
*     
      elseif (it.eq.gr_g) then
*...................................................................
*     
*     CALCUL GRILLE GAUSSIENNE
*     -----------------
*     
         if (ngr.eq.4) then
            if (mod(p1,2).ne.0) then
               write(6,*)' ON NE PEUT PRODUIRE UN CHAMP GAUSSIEN'
               write(6,*)'  AVEC UN NOMBRE DE LONGITUDES IMPAIRS'
               call pgsmabt
            endif
            call grigaus(p1,p2,p3)
*     
*     NI =P1  NOMBRE DE POINTS EST-OUEST
*     NJ =P2  NOMBRE DE POINTS NORD SUD 
*     LG1=P3  0=GLOBAL;  1=H. NORD;  2=H. SUD
*     
         else
            write(6,*)
     $           'MAUVAIS APPEL GRILLE(GAUSS,NI,NJ,NORD/SUD/GLOBAL)'
            call pgsmabt
         endif
      elseif (it.eq.gr_b) then
*......................................................................
*     
*     CALCUL GRILLE STDB
*     -----------
*     
         if (ngr.eq.4) then
            call gristdb(p1,p2,p3)
*     
*     NI =P1  NOMBRE DE POINTS EST-OUEST
*     NJ =P2  NOMBRE DE POINTS NORD SUD 
*     LG1=P3  0=GLOBAL;  1=H. NORD;  2=H. SUD
*     
         else 
            write(6,*)' MAUVAIS APPEL GRILLE(STDB,NI,NJ,NORD/SUD/GLOBAL) '
            call pgsmabt
         endif
      elseif (it.eq.gr_tape1.or.it.eq.gr_tape2.or.it.eq.gr_stations) then
*...................................................................
*     
*     CALCUL GRILLE TAPE1/TAPE2 LAT-LON OU X-Y
*     
*     SI IT=7 TAPE1 ENTRE
*     SI IT=8 TAPE2 SORTI
*     
         if (ngr.eq.4) then
            call gritp12(it,p1,p2,p3)
*     
*     IT=7......LIRE TAPE 1 ECRIT SUR TAPE2
*     IT=8......LIRE TAPE 2 ECRIT SUR TAPE2
*     IP1=P1....IDENTIFICATION DU RECORD VALEUR MAX=2047
*     IP2=P2....IDENTIFICATION DU RECORD VALEUR MAX=2047
*     IP3=P3....IDENTIFICATION DU RECORD VALEUR MAX=2047
*     
         else
            write(6,*)'MAUVAIS APPEL GRILLE(TAPE1/TAPE2,IP1,IP2,IP3)'
            call pgsmabt
         endif
*
      elseif (it.eq.gr_comme) then
         if (ngr.eq.9) then
            call comme(p1,p2,p3,p4,p5,p6,p7,p8)
         else
            write(6,*)
     $           'MAUVAIS APPEL GRILLE(COMME,FENTREE/FSORTIE,NOMVAR,TYPVAR,DATEV,IP1,IP2,IP3,ETIKET)'
            call pgsmabt
         endif
         
      elseif (it.eq.gr_grib) then
         if (ngr.eq.5) then
            call grigrib(p1,p2,p3,p4)
         else
            write(6,*)
     $           'MAUVAIS APPEL GRILLE(GRIB,IG1,iG2,IG3,IG4)'
            call pgsmabt
         endif
         
      elseif (it.eq.15) then
         if (ngr.eq.7) then
            call grigef(it,p1,p2,p3,p4,p5,p6)
*     
*     IT=7......LIRE TAPE 1 ECRIT SUR TAPE2
*     IT=8......LIRE TAPE 2 ECRIT SUR TAPE2
*     IP1=P1....IDENTIFICATION DU RECORD VALEUR MAX=2047
*     IP2=P2....IDENTIFICATION DU RECORD VALEUR MAX=2047
*     IP3=P3....IDENTIFICATION DU RECORD VALEUR MAX=2047
*     
         else
            write(6,*)
     $           'MAUVAIS APPEL GRILLE(E,NI,NJ,XLAT1,XLON1,XLAT2,XLON2)'
            call pgsmabt
         endif
         
      elseif (it.eq.gr_stereo) then
         if(ngr.eq.7) then
            call gristereo(p1,p2,p3,p4,p5,p6)
         else
            write(6,*)
     $           'MAUVAIS APPEL GRILLE(STEREO,NI,NJ,D60,DGRW,CLAT,CLON)'
            call pgsmabt
         endif
      endif
      
      
      return 
      end
***   S/P ITROUVE VERIFIER DANS LA LISTE(NOMBRE) SI IVARIA EXISTE
*     
      integer function itrouve(liste,nombre,ivaria)
  
*AUTEUR P. SARRAZIN RPN DORVAL FEV 81
*
*LANGAGE RATFOR
*
*OBJET(ITROUVE)
*         VERIFIER SI IVARIA EXISTE DANS LISTE SI OUI ITROUVE >0
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*ARGUMENTS
*  IN     LISTE =TABLE DE DONNEES
*  IN     NOMBRE=NOMBRE DE DONNEES DANS LISTE
*  IN     IVARIA=ITEM A VERIFIER DANS LISTE
*
* --------------------------------------------------------------------
*
  
#include "impnone.cdk"
*
*
      integer liste(1),nombre,ivaria,ntr
      
      itrouve=0  
*  #  defense contre index de zero 
      if (nombre.le.0)  return  
      
      do ntr=1,nombre
         if (ivaria.eq.liste(ntr)) itrouve=ntr
      enddo
      
      return 
      end
      
*
***S/P ECRIRE SUR TAPE2 1 REC LATITUDES ET 1 REC LONGITUDES 
*
      subroutine outlalo(ip1,ip2,ip3)
#include "impnone.cdk"
      integer ip1,ip2,ip3
*     
*AUTEUR P. SARRAZIN AOUT 84 DRPN DORVAL P.Q. CANADA
*
*LANGAGE RATFOR
*
*OBJET(OUTLALO)
*        EXTRAIRE DANS LA MEMOIRE LES LATITUDES ET LES LONGITUDES
*        ET CALCUL TOUS LES PARAMETRES NECESSAIRES POUR CALL ECRIRE
*        SUR UN FICHIER STANDARD TAPE2
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*ARGUMENTS
*  IN    IP1     OPTIONEL POUR USAGER DEFAUT=0
*  IN    IP2     OPTIONEL POUR USAGER DEFAUT=0
*  IN    IP3     OPTIONEL POUR USAGER DEFAUT=0
*
*IMPLICITES
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*   DEFINITION DES MACROS DE PGSM
* 

**********************************************************************
*
      external pgsmabt,ecritur,grille2,messags
*
*
#define  between(a,b,c) MIN(c,MAX(b,a))
#include "llccmm.cdk"
#include "dates.cdk"
#include "charac.cdk"
#include "indptr.cdk"
#include "grilles.cdk"
#include "voir.cdk"
#include "packin.cdk"
*
*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
      integer jjp1,jjp2,jjp3,jp1,jp2,jp3,k,ier
      integer gdll
*
*
*
      if (tmplatp.eq.0) then
         if (message)write(6,*)'GRILLE NON DEFINIE ..GRILLE P.S.(2805)'
         ngr=8
         call grille2(3,51,55,26.,28.,381000.,350.,1) 
      endif
*
*
      if (nlalo.gt.3) then
         write(6,*) ' PLUS DE 3 ARGUMENTS DANS OUTLALO'
         write(6,*) ' SEULEMENT LES 3 PREMIERS SERONT UTILISES'
      endif
*
*    INITIALISER ARGUMENTS POUR ECRITUR 
*
*  lat lon 2 dimension seulement
      k=1  

*
      jp1=ip1
      jp2=ip2
      jp3=ip3
*
*     ip2,ip3=0
      if (nlalo.eq.1) then
         jp2=0
         jp3=0
      endif
*
      if (nlalo.eq.2) jp3=0
*
*
*      if (mode.ne.1) then
*         if (message) then
*            write(6,*)' OUTLALO NE PEUT ECRIRE SUR FICHIER NON STD'
*         endif
*         return
*      endif
*     
      jjp1=between(0,jp1,32767)
      jjp2=between(0,jp2,32767)
      jjp3=between(0,jp3,4095)
*     
      ier = gdll(gdout, tmplat, tmplon)

      call ecritur(tmplat,npack,jdate,0,0,li,lj,k,jjp1,jjp2,jjp3,
     $     'C ','LA  ','LATITUDES   ',cgrtyp,lg1,lg2,lg3,lg4) 
*     
*     INITIALISER POUR LONGITUDES
*     
      call ecritur(tmplon,npack,jdate,0,0,li,lj,k,jjp1,jjp2,jjp3,
     $     'C ','LO  ','LONGITUDES  ',cgrtyp,lg1,lg2,lg3,lg4) 
*     
*     
      return 
      end
      subroutine qqqecho(chaine)
#include "impnone.cdk"

      external argdims
      integer argdims

      integer chaine(20)
      integer i,j,longueur,iun

      character*80 message
      character*16 form

      longueur = argdims(1)
*      write(form,'(a1,i2.2,a3)') '(',longueur,'a4)'
*      write(message,form) chaine

      message(1:80) = ' '

      do i=1,longueur
         j = 4*(i-1)+1
         write(message(j:j+3),'(a4)') chaine(i)
      enddo
      
      iun = 2
      call pgsmecho(iun, message,longueur*4)

      return
      end
*
***S/P VDAUV  U ET V DE DIRECTION ET VITESSE DU VENT
*
      subroutine vdauv(srtentu,srtentv,clong,dgtord,nombre)
#include "impnone.cdk"
      integer nombre
      real srtentu(nombre),srtentv(nombre),clong(nombre),dgtord
*
*AUTEUR P. SARRAZIN DORVAL QUEBEC CANADA (DRPN)
*
*OBJET(VDAUV)
*         AVEC LA DIRECTION ET LA VITESSE DU VENT CALCUL LES VECTEURS 
*         U ET V. UTILISATION DE LA LONGITUDE
*
*ARGUMENTS
* IN-OUT   SRTENTU - ENTRE DIRECTION   SORTI VECTEUR U
* IN-OUT   SRTENTV - ENTRE VITESSE  SORTI VECTEUR V
*   IN     CLONG   - CHAMP DE LONGITUDES EN DEGRE 0-360
*   IN     DGTORD  - FACTEUR DE CONVERSION DE DEGREE A RADIAN
*   IN     NOMBRE  - NOMBRE DE POINTS DANS LES DEUX CHAMPS
*
*APPEL
*     - VIA UVECTUR 
*     - CALL VDAUV(SRTENTU,SRTENTV,CLONG,DGTORD,NOMBRE)
*
#include "grilles.cdk"
*
*
*----------------------------------------------------------------------
*
      external pgsmabt,messags
*
      real angle,u,v
      integer i
*
*    SI LE TYPE DE GRILLE  "L"
*
      if (cgtypxy.eq.'L') then
         do i=1,nombre
            angle=dgtord*(srtentv(i) - clong(i))
            u=srtentu(i)*sin(angle)
            v=-srtentu(i)*cos(angle)
            srtentu(i)=u
            srtentv(i)=v
         enddo
*     
*     SI LE TYPE DE GRILLE GRTYPXY= "N" HEM NORD
*     
      else if (cgtypxy.eq.'N') then
         do i=1,nombre
            angle=dgtord*(dgrwxy + srtentv(i))
            u=srtentu(i)*cos(angle)
            v=srtentu(i)*sin(angle)
            srtentu(i)=u
            srtentv(i)=v
         enddo
      else
         write(6,*) ' TYPE DE GRILLE PAS "L" OU "N" '
         write(6,*) 
     $        ' DANS ROUTINE VDAUV PAS DE CODE VALID POUR TYPE "S"'
         call pgsmabt
      endif
      return
      end 
      
      subroutine coord(lescoords,mode)
#include "impnone.cdk"
      real lescoords(*)
      integer mode

#include "grilles.cdk"

      external argdims
      integer argdims
      
      integer i,localncoords


      localncoords = argdims(1)
      if (mod(localncoords,2).ne.0) then
         print *, 'Malheureux(se)! Nombre de coordonnees impaires!'
         stop
      endif

      if (mode.eq.0) then
         ncoords = 0
      endif
      
      
      do i=1,localncoords,2
         if (i.lt.512) then
            coordll(ncoords+i/2+1,1) = lescoords(i)
            coordll(ncoords+i/2+1,2) = lescoords(i+1)
         else
            print *, '(COORD) TROP DE POINTS! MAX=512!!!'
         endif
      enddo
      
      ncoords = ncoords+localncoords/2

      return
      end
         
*
***S/P GRILLPS  CALCUL LATITUDE LONGITUDE DE CHAQUE PT D'UNE GRILLE P.S.
*
      subroutine grillps(nni,nnj,pi,pj,d60,dgrw,hem) 
#include "impnone.cdk"
*
*AUTEUR   - P. SARRAZIN JANVIER 87 DRPN DORVAL P.Q. CANADA
*
*LANGAGE - RATFOR
*
*OBJET(GRILLPS)
*          CALCULER LA LATITUDE ET LA LONGITUDE DE TOUS LES POINTS
*          DE LA GRILLE DE SORTIE POLAIRE STEREOGRAPHIQUE
*
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*------------------------------------------------------
       external memoir,pgsmabt,grps,cigaxg,cxgaig,messags
*
*
#include "llccmm.cdk"
*
*
#include "grilles.cdk"
*
*
       external ezqkdef
       integer ezqkdef

       integer nni,nnj,ihm,hem,ier
       real pi,pj,d60,dgrw,pp1,pp2,pp3,pp4
*
*   RESERVER MEMOIR POUR LATITUDE ET LONGITUDE
*
       call hpalloc(tmplatp,nni*nnj,ier,1)
       call hpalloc(tmplonp,nni*nnj,ier,1)
*
*
       li=nni
       lj=nnj
*
*
       ihm=hem
       if (ihm.eq.1) then
          cgrtyp='N' 
       else
          cgrtyp='S' 
       endif
  
       call cxgaig(cgrtyp,lg1,lg2,lg3,lg4,pi,pj,d60,dgrw)
       call cigaxg(cgrtyp,pp1,pp2,pp3,pp4,lg1,lg2,lg3,lg4)
       
      if (ihm.lt.1.or.ihm.gt.2) then
         write(6,*)'GRILLE P.S. CODE D HEMISPHERE DOIT-ETRE NORD OU SUD'
         call pgsmabt
      endif
*
      gdout = ezqkdef(li,lj,cgrtyp,lg1,lg2,lg3,lg4,0)
*     
*
*
      return
      end 
*
***S/P GRISTEREO  CALCUL LATITUDE LONGITUDE DE CHAQUE PT D'UNE GRILLE P.S.
*
      subroutine gristereo(nni,nnj,d60,dgrw,clat,clon) 
#include "impnone.cdk"
*
*AUTEUR   - P. SARRAZIN JANVIER 87 DRPN DORVAL P.Q. CANADA
*
*LANGAGE - RATFOR
*
*OBJET(GRISTEREO)
*          CALCULER LA LATITUDE ET LA LONGITUDE DE TOUS LES POINTS
*          DE LA GRILLE DE SORTIE STEREOGRAPHIQUE GENERALISEE
*
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*------------------------------------------------------
       external memoir,pgsmabt,grps,cigaxg,cxgaig,messags
*
*
#include "llccmm.cdk"
*
*
#include "grilles.cdk"
*
*
       external ezqkdef
       integer ezqkdef

       integer nni,nnj,ihm,hem,ier
       real pi,pj,d60,dgrw,pp1,pp2,pp3,pp4,clat,clon
*
*   RESERVER MEMOIR POUR LATITUDE ET LONGITUDE
*
       call hpalloc(tmplatp,nni*nnj,ier,1)
       call hpalloc(tmplonp,nni*nnj,ier,1)
*
*
       li=nni
       lj=nnj
*
*
       cgrtyp='T' 
       
       call cxgaig(cgrtyp,lg1,lg2,lg3,lg4,d60,dgrw,clat,clon)
       call cigaxg(cgrtyp,pp1,pp2,pp3,pp4,lg1,lg2,lg3,lg4)
       
      gdout = ezqkdef(li,lj,cgrtyp,lg1,lg2,lg3,lg4,0)
*     
*
*
      return
      end 
*
      subroutine lastcol(sortie,valeur,istart,ifini,incre) 
#include "impnone.cdk"
*
*AUTEUR P. SARRAZIN DORVAL QUEBEC CANADA (DRPN)
*
*OBJET(LASTCOL)
*         LASTCOL - LA DERNIERE COLONNE DU CHAMP PREND LA VALEUR(VALEUR)
*         LOUPNEG - ELIMINE VALEUR NEGATIVE DANS LE CHAMP SI VALEUR=0.0
*
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*ARGUMENTS
*   OUT   SORTIE - RESULTAT DE L'OPERATION SUR CHAMP(NOMBRE)
*   IN    VALEUR - VALEUR DE LA DERNIERE COLONNE DU CHAMP
*                  OU VALEUR MINIMAL DU CHAMP A GARDE
*   IN    ISTART - PREMIERE INDEX DU CHAMP
*   IN    IFINI  - DERNIERE INDICE DU CHAMP
*   IN    INCRE  - NOMBRE DE PTS AUGMENTATION DE L'INDICE ISTART
*
*                  NOMBRE EST (MAXIMUM) LA MOITIE DU NOMBRE DES POINTS
*
*APPEL
*     - VIA GRILLE,MACPCP
*     - CALL LASTCOL(SORTIE,VALEUR,ISTART,IFINI,INCRE)
*     - CALL LOUPNEG(SORTIE,VALEUR,ISTART,IFINI,INCRE)
*
*--------------------------------------------------------------------------
*
#include "voir.cdk"
*
*
      real sortie(1),valeur
      integer istart,ifini,incre,i
*     
*         INITIALISE LA DERNIERE COLONNE DU CHAMP 
*
      do i=istart,ifini,incre
         sortie(i)=valeur
      enddo
      return
*
*----------------------------------------------------------------------
*
      entry loupneg(sortie,valeur,istart,ifini,incre)
*
*              ELIMINE VALEUR NEGATIVE
*
      do i=istart,ifini,incre
         sortie(i)=amax1(sortie(i),valeur)
      enddo
*     
      return
      end
      
      
*
***S/P PAIRVCT  REMPLACE OU AJOUTE NOM AU DICTIONNAIRE COMMON/PAIR/...
*
      subroutine pairvct(nomusag, varuu, varvv, varmodule, vardir) 
*
*AUTEUR P. SARRAZIN DORVAL QUE CANADA FEV 87
*
*REVISION 4.0.2
*   CONVERSION DES VARIABLES HOOLERITH EN CARACTERE
*REVISION 5.6.1
*   INCLUSION DE LA VARIABLE WD - DIRECTION DU VENT Y.Chartier - Aout 1996  
*
*LANGAGE RATFOR
*
*OBJET(PAIRVCT)
*          REMPLACE OU AJOUTE DANS LA TABLE PAIRE DU COMMON/PAIR/..
*          POUR REFERENCE PAR L'USAGER QUI PERMET CERTAINES INTERPOLATIONS
*          DE VARIABLES PAIRES. 2 SETS DE VARIABLES PAIRES INITIALISE 
*          DANS PGSM UU,VV  US,VS.
*
*LIBRAIRIES
*
*          - SOURCE  PGSM ID=ARMNSRC     MFA
*          - OBJET PGSMLIB,ID=ARMNPJS    XMP
*
*ARGUMENTS
*
*  IN    NOMUSAG  NOM DE L'USAGER DONNE PAR LA DIRECTIVE PAIRES
*  IN    VARUU  NOM DE 2 CARACTERES DE LA PREMIERE VARIABLE PAIRE
*  IN    VARUU   NOM DE 2 CARACTERES DE LA DEUXIEME VARIABLE PAIRE
*  IN    VARMODULE  SI VARMODULE .NE.0 NOM DE 2 CARACTERES IDENTIFIANT
*                 LE CHAMP DE SORTIE VITESSE DU VENT  EX:"UV"
*                 SI VARMODULE.EQ.0 INTERPOLATION DE 2 CHAMPS AVEC ORIENTATION
*                 GEOGRAPHIQUE NOM DU PREMIER CHAMP POUR LA SORTIE=VARUU
*                 NOM DU DEUXIEME CHAMP=VARVV
*
*APPEL
*         - VIA DIRECTIVE PAIRES(NOMUSAG,VARUU,VARVV,VARMODULE)
*
*MESSAGE
*         - 'VERIFIER NOMBRE D ARGUMENTS DIRECTIVE PAIRES(3 OU 4 ARGS)'
*           'PAIRES DEJA INITIALISE'
*           'PAIRES("VENT","UU","VV","UV")
*           'PAIRES("UV","UU","VV","0") 
*           'PAIRES("VENTUVS","US","VS","UV")
*           'PAIRES("UVS","UU","VV","0")
*
*IMPLICITES
*MODULES
*
*
*- - -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
#include "defin.cdk"
#include "pairs.cdk"
*
*
      integer nomusag(2),varuu,varvv,varmodule
      character*8 cnomusr
      character*4 cvaruu, cvarvv, ccontrl
      integer i, nw
      integer argdims
      
      external fstcvt
      integer  fstcvt
      
      if (npairuv.lt.3.or.npairuv.gt.5) then
         write(6,*)'  VERIFIER ARGUMENTS DIRECTIVE PAIRES(3 OU 4 ARGS)' 
         write(6,*)' PAIRES DEJA INITIALISEES'
         write(6,*)' PAIRES("VENT","UU","VV","UV")'
         write(6,*)' PAIRES("UV","UU","VV","0")'
         write(6,*)' PAIRES("VENTUVS","UU","VV","UV")'
         write(6,*)' PAIRES("VENTUVS","UU","VV","0")'
         return
      endif
*
*   VERIFI SI NOM EXISTE DANS LA TABLE SI OUI ON REMPLACE
*   SI NON ON AJOUTE SI LA TABLE N'EST PAS PLEINE 
*
      nw = min(argdims(1), 2) 
      write (cnomusr, 100) (nomusag(i), i=1,nw)
 100  format(2a4)
      
      write (cvaruu, 200) varuu
      write (cvarvv, 200) varvv
      write (ccontrl, 200) varmodule
 200  format(a4)
      
      if (varmodule.eq.0) ccontrl = '??'
      
      write (6, *) 'PAIRES: ',cnomusr, cvaruu, cvarvv, ccontrl
      
      call pairvc2(cnomusr, cvaruu, cvarvv, ccontrl)
      return
      end 
  
***S/P PAIRVC2  REMPLACE OU AJOUTE NOM AU DICTIONNAIRE COMMON/PAIR/...
      subroutine pairvc2(cnomusr,cvaruu,cvarvv,ccontrl,cvarwd)
*
*AUTEUR P. SARRAZIN DORVAL QUE CANADA FEV 87
*
*REVISION 4.0.2
*   CONVERSION DES VARIABLES HOLLERITH EN CARACTERE
*
*
*LANGAGE RATFOR
*
*     OBJET(PAIRVCT)
*          REMPLACE OU AJOUTE DANS LA TABLE PAIRE DU COMMON/PAIR/..
*          POUR REFERENCE PAR L'USAGER QUI PERMET CERTAINES INTERPOLATIONS
*          DE VARIABLES PAIRES. 2 SETS DE VARIABLES PAIRES INITIALISE 
*          DANS PGSM UU,VV  US,VS.
*
*LIBRAIRIES
*
*          - SOURCE  PGSM ID=ARMNSRC     MFA
*          - OBJET PGSMLIB,ID=ARMNPJS    XMP
*
*ARGUMENTS
*
*  IN    NOMUSAG  NOM DE L'USAGER DONNE PAR LA DIRECTIVE PAIRES
*  IN    VARUU  NOM DE 2 CARACTERES DE LA PREMIERE VARIABLE PAIRE
*  IN    VARUU   NOM DE 2 CARACTERES DE LA DEUXIEME VARIABLE PAIRE
*  IN    VARMODULE  SI VARMODULE .NE.0 NOM DE 2 CARACTERES IDENTIFIANT
*                 LE CHAMP DE SORTIE VITESSE DU VENT  EX:"UV"
*                 SI VARMODULE.EQ.0 INTERPOLATION DE 2 CHAMPS AVEC ORIENTATION
*                 GEOGRAPHIQUE NOM DU PREMIER CHAMP POUR LA SORTIE=VARUU
*                 NOM DU DEUXIEME CHAMP=VARVV
*
*APPEL
*         - VIA DIRECTIVE PAIRES(NOMUSAG,VARUU,VARVV,VARMODULE)
*
*MESSAGE
*         - 'VERIFIER NOMBRE D ARGUMENTS DIRECTIVE PAIRES(3 OU 4 ARGS)'
*           'PAIRES DEJA INITIALISE'
*           'PAIRES("VENT","UU","VV","UV")
*           'PAIRES("UV","UU","VV","0") 
*           'PAIRES("VENTUVS","US","VS","UV")
*           'PAIRES("UVS","UU","VV","0")
*
*MODULES
*
*
*-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
#include "defin.cdk"
#include "pairs.cdk"
*
      character cnomusr*8, cvaruu*4 , cvarvv*4 , ccontrl*4 , cvarwd*4 
      integer np
      logical remplac
*     
*   VERIFI SI NOM EXISTE DANS LA TABLE SI OUI ON REMPLACE
*   SI NON ON AJOUTE SI LA TABLE N'EST PAS PLEINE 
*
      remplac=.false.
      do np=1,npair
         if (cnomusr.eq.paire(np)(1:8)) then
            paire(np)( 1: 8) = cnomusr
            paire(np)( 9:12) = cvaruu
            paire(np)(13:16) = cvarvv
            paire(np)(17:20) = ccontrl
            paire(np)(21:24) = cvarwd
            remplac=.true.
            write (6, *) 'PAIRE(NP): ', paire(np)
         endif
      enddo
*     
      if (remplac)  go to 1000
*
*   SI ON N'A PAS REMPLACE DANS LA TABLE ON AJOUTE
*
      npair = npair + 1
      if (npair.gt.NPAIRMX) then
         write(6,666) npair,npairmx
 666     format(1x,' TROP DE PAIRES DANS LA TABLE NPAIR=',i5,
     $        /'   NPAIRMX=',i5)
         return
      endif
*
      paire(np)( 1: 8) = cnomusr 
      paire(np)( 9:12) = cvaruu 
      paire(np)(13:16) = cvarvv 
      paire(np)(17:20) = ccontrl 
      write (6, *) 'PAIRE(NP): ', paire(np)
      return 
*
*
 1000 write(6,*)'  2 VARIABLES PAIRES REMPLACEES '
*     
      return 
      end

      subroutine qqqfilt(inout,weightlst,ntimes,verbose)
      integer inout,weightlst(*),ntimes,verbose
      
#include "qqqfilt.cdk"

      integer i,j,l,sum
      integer nb_elem,lng_liste,istart, iend

      external argdims
      integer argdims

      data(fltoggle(i),i= 1,2)  /.false.,.false./
      data(fltntimes(i), i=1,2) /0,0/
      data(fltverb(i), i=1,2)   /0,0/


      if (inout.ne.1.and.inout.ne.2) then
        write (6,*) '(QQQFILT) On doit mentionner LECTURE ou ECRITURE'
        return
      endif

      if (argdims(2).gt.9) then
        write (6,*) '(QQQFILT) Liste de poids trop longue - Maximum=9'
        return
      endif

      
      fltoggle(inout)=.true.
      if (argdims(2).le.1) then
         fltoggle(inout)=.false.
         return
      endif
      
      fltwgtlng(inout)=argdims(2)
      fltntimes(inout)=ntimes
      fltverb(inout)=verbose

      if (mod(fltwgtlng(inout),2).ne.1) then
        write (6,*) '(QQQFILT) Liste de poids doit etre impaire'
        return
      endif

      do i=1, fltwgtlng(inout)
        fltlist(i,inout)=weightlst(i)
      enddo


      return
      end
*
***S/P  VERLALO  VERIFI LONGITUDE ET LATITUDE
*     
      subroutine verlalo(clat,clon,nombre)
#include "impnone.cdk"
      integer nombre
      real clat(nombre),clon(nombre)
*
*AUTEUR P. SARRAZIN DORVAL QUEBEC CANADA (DRPN)
*
*OBJET(VERLALO)
*         VERLALO - VERIFIER LES LATITUDES ET LONGITUDES DU CHAMP
*
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*ARGUMENTS
*   IN    CLAT   - CHAMP DE LATITUDE
*   IN    CLON   - CHAMP DE LONGITUDES
*   IN    NOMBRE - NOMBRE DE POINTS DANS LES CHAMPS CLAT/CLON
*
*-------------------------------------------------------------------- 
      external pgsmabt,messags
*
*
#include "voir.cdk"
*
*
      integer i
*
*
*   VERIFIER SI LATITUDES ET LONGITUDES SONT A L'INTERIEUR
*   DES LIMITES
*
       do i=1,nombre
          if (clon(i).lt.0.0) clon(i)=clon(i)+360.0
          if (clon(i).ge.360.0) clon(i)=clon(i) - 360.0
*
          if (clat(i).lt.-90.005.or.clat(i).gt.90.005) then
             write(6,*)' ROUTINE VERLALO MAUVAISE LATITUDE=',clat(i)
          endif
          clat(i)=max(-90.0,min(90.0,clat(i)))
       enddo
       return
       end
*
***s/p coupe, calcul coupe zonale\meridionale
*
#include "defin.cdk"
      subroutine pgcoupe(nom,lcoupe,ipr1,ipr2,ipr3,ipr4,ipr5,ipr6,
     $     ipr7,ipr8,ipr9,ipr10,ipr11,ipr12,ipr13,ipr14,ipr15,ipr16,
     $     ipr17,ipr18,ipr19,ipr20,ipr21,ipr22,ipr23,ipr24,ipr25,
     $     ipr26,ipr27,ipr28,ipr29,ipr30)
#include "impnone.cdk"
      external coupzm,messags,fstcvt,pgsmabt
      integer  fstcvt
*     
*     auteur p. sarrazin avril 85 drpn dorval p.q. canada
*     
*     revision 
*     4.0.2 - conversion en caracteres de toutes les variables
*     de type hollerith
*     y. chartier- dorval quebec juillet 90 drpn.
*
*     
*     langage ratfor
*     
*     objet(coupe)
*     lire un champ sur une grille "g","l","b","c","a"  et calcul une
*     moyenne zonale est-ouest ou meridionale nord-sud pour chaque niveau
*     max(30) de l'usager 
*     
*librairies
*     -source  armnsrc,drpn
*     -objet   pgsmlib,id=armnpjs.
*     
*     arguments
*     in    nom        nom du champ requis.....z,tt,es......
*     in    lcoupe     lcoupe=lcar(zon)  coupe zonale est-ouest
*     lcoupe=lcar(mer)  coupe meridionale nord-sud
*     in    ipr1-ipr30 niveau de l'usager optionel
*     
*     implicites
*     
*     
*modules
*     coupzm
*     
*     appel
*     via directive
*     moyent(nom,lcoup,ipr..........)
*     moysrt(nom,lcoup,ipr..........)
*     maximum de 30 ipr
*     
*     messages 
*     pas assez d'arguments directive moyent/moysrt
*
*     
*     implicites
*     
#include "voir.cdk"
*     
*     
#include "heures.cdk"
*     
*     
#include "nivos.cdk"
*     
*     
#include "accum.cdk"
*     
*     
#include "indptr.cdk"
*     
*
#include "dates.cdk"
*
*
#include "champs.cdk"
*
*
#include "cfldinf.cdk"
*
*
#include "lires.cdk"
*
*
#include "ecrires.cdk"
*
      integer nom,lcoupe,ipr1,ipr2,ipr3,ipr4,ipr5,ipr6,ipr7,ipr8
      integer ipr9,ipr10,ipr11,ipr12,ipr13,ipr14,ipr15,ipr16,ipr17
      integer ipr18,ipr19,ipr20,ipr21,ipr22,ipr23,ipr24,ipr25
      integer ipr26,ipr27,ipr28,ipr29,ipr30
      integer iunit,nparm,i
*     
      character*8 cjcoup
*     
*     initialiser nivospr
*     
      do i=1,30
         nivospr(i)=-1
      enddo
*     
*     
      iunit=1
 1000 nmoy = min0(31,nmoy)
      go to (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,
     $       21,22,23,24,25,26,27,28,29,30,31) nmoy
 31   nivospr(30) = ipr30
 30   nivospr(29) = ipr29
 29   nivospr(28) = ipr28
 28   nivospr(27) = ipr27
 27   nivospr(26) = ipr26
 26   nivospr(25) = ipr25
 25   nivospr(24) = ipr24
 24   nivospr(23) = ipr23
 23   nivospr(22) = ipr22
 22   nivospr(21) = ipr21
 21   nivospr(20) = ipr20
 20   nivospr(19) = ipr19
 19   nivospr(18) = ipr18
 18   nivospr(17) = ipr17
 17   nivospr(16) = ipr16
 16   nivospr(15) = ipr15
 15   nivospr(14) = ipr14
 14   nivospr(13) = ipr13
 13   nivospr(12) = ipr12
 12   nivospr(11) = ipr11
 11   nivospr(10) = ipr10
 10   nivospr(9) = ipr9
 9    nivospr(8) = ipr8
 8    nivospr(7) = ipr7
 7    nivospr(6) = ipr6
 6    nivospr(5) = ipr5
 5    nivospr(4) = ipr4
 4    nivospr(3) = ipr3
 3    nivospr(2) = ipr2
 2    nivospr(1) = ipr1
*     
*   1 nomvar = nom
 1    continue
*
      
*     sauve la valeur de nmoy a cause de readlx
      nmo = nmoy   
*     
      nparm = max0(1,nmo-2)
*     
*     
      write(cnomvar,'(a2)') nom
      
*     jcoup=lcoupe
      if (lcoupe.eq.1) then
         cjcoup = 'ZON'
      endif
  
      if (lcoupe.eq.2) then
         cjcoup = 'MER'
      endif

      call coupzm(iunit,cnomvar,cjcoup) 
      return
*     
*     directive moysrt lire sur fichier de sorti
*     
      entry moysrt(nom,lcoupe,ipr1,ipr2,ipr3,ipr4,ipr5,ipr6,ipr7,ipr8,
     $     ipr9,ipr10,ipr11,ipr12,ipr13,ipr14,ipr15,ipr16,
     $     ipr17,ipr18,ipr19,ipr20,ipr21,ipr22,ipr23,ipr24,ipr25,
     $     ipr26,ipr27,ipr28,ipr29,ipr30)
      iunit=2
      go to 1000
*     
      end 
      
*     
***S/P GRILSTD   CALCUL LATITUDE LONGITUDE DE CHAQUE PT D'UNE GRILLE STD
*
      subroutine grilstd(nni,nnj,hem)
#include "impnone.cdk"
*
*AUTEUR   - P. SARRAZIN JANVIER 87 DRPN DORVAL P.Q. CANADA
*
*LANGAGE - RATFOR
*
*OBJET(GRILSTD)
*          CALCULER LA LATITUDE ET LA LONGITUDE DE TOUS LES POINTS
*          DE LA GRILLE DE SORTIE STANDARD INTERVAL REGULIER MAIS DECALE
*          1/2 POINT DU POLE ET DE L'EQUATEUR
*
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*------------------------------------------------------
       external memoir,pgsmabt,grll,messags
       external ezqkdef
       integer ezqkdef
*
*
#include "llccmm.cdk"
*
*
#include "grilles.cdk"
*
*
       integer nni,nnj,hem,ier
       real xla0,xlo0,dlat,dlon
*
       li=nni
       lj=nnj
*
*
*   RESERVER MEMOIR POUR LATITUDE ET LONGITUDE
*
       call hpalloc(tmplatp,nni*nnj,ier,1)
       call hpalloc(tmplonp,nni*nnj,ier,1)
*
*

       lg1=hem
       cgrtyp='A'
       lg2=0
       lg3=0
       lg4=0

       gdout = ezqkdef(li,lj,cgrtyp,lg1,lg2,lg3,lg4,0)
*     
*     
       if (lg1.ne.0.and.lg1.ne.1.and.lg1.ne.2) then
          write(6,*)'GRILLE(STD........ DOIT ETRE NORD/SUD/GLOBAL'
          call pgsmabt
       endif
*     
       return
       end 
      
      integer function legvar(x)
      legvar=0
      return
      end
        program pgsm

        call pgsm2

        stop
        end

***programme pgsm 
*	    programme general de sortie des modeles
*               programme utilitaire d'interpolation horizontale
*               interpoler  ajustement convectif,precip,epaisseurs
*               calcul du vent sqrt(u**2 + v**2)
*               interpolation des vecteurs u et v horizontalement
*               interpolation des 3 niveaux de nuages
*               interpolation horizontale de variables scalaires
*
*auteur    - p.sarrazin octobre 1981 drpn dorval p.q.  canada
*
*revision 
*        4.0.1  - conversion au fichier standard 89  p. sarrazin
*                 modification avril 90 p. sarrazin dorval canada drpn
*
*        4.0.2  - leger nettoyage du code
*               - conversion des variables contenant des informations
*                 alphanumeriques de type hollerith a caractere
*               - elimination des macros "hcar" et "lcar"
*               - conversion appels a "lexins" par "qlxins" 
*               - conversion pour cyber-910
*                 y. chartier -juillet-aout 90- drpn dorval quebec
*
*        5.0    - utilisation des nouveaux interpolateurs
*                 y. chartier - mai 1991 - drpn dorval quebec
*
*        5.1    - utilisation de fichiers d'entree lies avec "fstlnk"
*                 y. chartier - mai 1991 - drpn dorval quebec
*
*        5.2    - support des grilles source de type z
*        5.3    - conversion de RATFOR a FORTRAN
*                 Y. Chartier - aout 1995
*        5.4    - Optimisation des interpolateurs pour l'extension
*                 selective des grilles. 
*        5.5    - Interpolation a partir de fichiers d'entree SQI
*                 Support des grilles Lambert
*                 Introduction de la librairie C gctpc
*        5.6    - Introduction des directives COORD et GRILLE(STATIONS)
*                 sortie(ASCII)
*        5.7    - Support des fichiers standards 98
*        6.0    - Introduction de ezscint comme interpolateur principal
*        6.8    - Support des grilles diese
*        6.9    - Support des grilles T (stereographiques generalisees)
*
*langage   - fortran 
*
*objet(pgsm)
*          interpolateur horizontal qui permet de faire des 
*          interpolations (cubique,lineaire,voisin) d'une grille a
*          une autre ou d'une grille a un point
*          permet de faire des operations sur deux champs
*          (gros calculateur de poche)
*          fichier d'entre doit-etre format standard random 
*          sorti standard random ou sequentiel - seq ms - random ms
*
*librairies
*		  - rmnxlib.a

*fichiers 
*         - tape1  - fichier d'entree  (standard) 
*         - tape2  - fichier de sortie standard..direct(writms)...sequentiel
*         - tape3  - fichier de records positionels ('^^','>>')
*         - tape5  - fichier d'entree(directives) 
*         - tape6  - fichier de sortie sur imprimante
*
*----------------------------------------------------------------------------
#include "defin.cdk"
	subroutine pgsm2
#include "impnone.cdk"
*
#include "lnkflds.cdk"
#include "dates.cdk"
#include "charac.cdk"
#include "pairs.cdk"
#include "accum.cdk"
#include "chck.cdk"
#include "grilles.cdk"
#include "heures.cdk"
#include "symnom.cdk"
#include "llccmm.cdk"
#include "convers.cdk"
#include "champs.cdk"
#include "lires.cdk"
#include "ecrires.cdk"
#include "enrege.cdk"
#include "packin.cdk"
#include "indptr.cdk"
#include "voir.cdk"
#include "nivos.cdk"
#include "gdz.cdk"
#include "champseq.cdk"
	
	
	character *8 qlxcon(107),qlxlcon(4)
	integer      qlxval(107)     
	integer      qlxlval(4)

	
	integer ezsetopt
	external ezsetopt, heure, champ, sorti, grille2, metsym, cmetsym, convs
	external    qqqintx, setxtrap, liren, lirsr, plmnmod, pluss
	external moinse, moinss, ecrits,moyene, operat, modul2e, modul2s
	external expon, racine,alogn, outlalo, foise, foiss, divisee, divises, pgcoupe
	external moysrt, imprims,chmpdif, pairvct, messags, champ_seq,qqqecho
	external qqqform,qqqident,coord,qqqfilt
*       
	external ccard,fnom,exdb,qlxins,qlxinx,readlx,fstfrm,fstvoi
	external fstnbr,fstunl,fstouv
	external fclos,exfin,lrsmde,lrsmds,fstopc,qlxopt
*
	integer exdb,exfin,fnom,fstfrm,fstvoi,fstnbr,fstopc,fstouv
	integer i,iopc,ipose,kend,nequiv,npex,nsetin,nsetex,nlirmds,nlirmde
	real dum

*
*
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	data listl/40*'IMENT.','OZSRT.','ISLL.','I.',    'L.',     'DATE.','MSGLVL.','ISENT','IMPOS','V'/
	data defo /40*'SCRAP', 'TAPE2', 'TAPE4','$INPUT','$OUTPUT','OPRUN','INFORMS','SCRAP','SCRAP','OUI'/
	data lfn  /40*'SCRAP', 'TAPE2', 'TAPE4','$INPUT','$OUTPUT','NON',  'INFORMS','SCRAP','SCRAP','NON'/

	data lnkdiun / 1, 11, 12, 13, 14, 15, 16, 17, 18, 19,
     $                20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
     $                30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
     $                40, 41, 42, 43, 44, 45, 46, 47, 48, 49 /
   
	data form/'(A8)'/
*
	data nheure,  heures, nnoms,  npack,  nhur, nomb, ichck 
     $       /0,  MXHEURE*-2, 0,      -16,    1,    0,    0/
*
	data nomss /40*'  '/
  
	data ecarts,     facts,     pose,     ixlat, ixlon  
     $    /40*0.0,     40*1.0,   .false.,   0,     0 /
*
   	data nchamp,  ngr,  nsort,   nchmp,   icnt, nlalo 
     $       /  1,    0,     0,        1,      0,     0 /
*
	data valid, voire,   voirs, message,seldat    
     $  /.false.,.false., .false.,.true.,.false.  /
*
	data numero,  numdel,  iset,  nbrow,  ip4   
     $    / 1,           1,    -2,      0,    0    /
*
	data paire(1) /  'VENT    UU  VV  UV      ' /
	data paire(2) /  'UV      UU  VV  ??      ' /
	data paire(3) /  'VENTUVS US  VS  UV      ' /
	data paire(4) /  'UVS     US  VS  ??      ' /
	data paire(5) /  'WDUV    UU  VV  UV  WD  ' /
	data paire(6) /  '!#@$!#@$>>  ^^  >>  ^^  ' /
*
	data unefois,once,vvent/.false.,.false.,.false./
*
	data cnomqq, cnomqr, cnommt /'QQ', 'QR', 'MT'/ 
*
	data printen,printsr,mtdone/.false.,.false.,.false./
*
 	data nis,njs,nif,njf,ninc,njnc,if9/1,1,1000,1000,10,10,0/
*
   	data niis,njjs,niif,njjf,niinc,njjnc/1,1,1000,1000,10,10/
*
   	data if7,if8,npairuv,npair/0,0,4,6/
*	
   	data clatmin,clatmax,clonmin,clonmax,ncoords/-90.0, +90.0, 0.0, 360.0, 0/

	data qlxcon( 1) /'ZON'     /  qlxval( 1) /      1 /
	data qlxcon( 2) /'MER'     /  qlxval( 2) /      2 /
	data qlxcon( 3) /'TOUT'    /  qlxval( 3) /     -1 /
	data qlxcon( 4) /'ALL'     /  qlxval( 4) /     -1 /
	data qlxcon( 5) /'COMTEUR' /  qlxval( 5) /   4095 /
	data qlxcon( 6) /'IMPRIM'  /  qlxval( 6) / 999999 /
	data qlxcon( 7) /'STD'     /  qlxval( 7) /   gr_a /
	data qlxcon( 8) /'MS'      /  qlxval( 8) /      2 /
	data qlxcon( 9) /'SEQ'     /  qlxval( 9) /      3 /
	data qlxcon(10) /'R'       /  qlxval(10) /      1 /
	data qlxcon(11) /'A'       /  qlxval(11) /     -1 /
	data qlxcon(12) /'NORD'    /  qlxval(12) /      1 /
	data qlxcon(13) /'SUD'     /  qlxval(13) /      2 /
	data qlxcon(14) /'GLOBAL'  /  qlxval(14) /      0 /
	data qlxcon(15) /'LATLON'  /  qlxval(15) / gr_latlon /
	data qlxcon(16) /'PS'      /  qlxval(16) / gr_ps   /
	data qlxcon(17) /'TAPE4'   /  qlxval(17) / gr_tape4 /
	data qlxcon(18) /'GAUSS'   /  qlxval(18) / gr_g /
	data qlxcon(19) /'STDB'    /  qlxval(19) / gr_b /
	data qlxcon(20) /'TAPE1'   /  qlxval(20) / gr_tape1 /
	data qlxcon(21) /'TAPE2'   /  qlxval(21) / gr_tape2 /
	data qlxcon(22) /'XYLIS'   /  qlxval(22) / gr_xylis /
	data qlxcon(23) /'XYDIR'   /  qlxval(23) / gr_xydir /
	data qlxcon(24) /'LLDIR'   /  qlxval(24) / gr_lldir /
	data qlxcon(25) /'LLLIST'  /  qlxval(25) / gr_lllist/
	data qlxcon(26) /'ANAL'    /  qlxval(26) / "A   "/
	data qlxcon(27) /'PREV'    /  qlxval(27) / "P   "/
	data qlxcon(28) /'Z'       /  qlxval(28) / "GZ  "/
	data qlxcon(29) /'T'       /  qlxval(29) / "TT  "/
	data qlxcon(30) /'Q'       /  qlxval(30) / "QQ  "/
	data qlxcon(31) /'QR'      /  qlxval(31) / "QR  "/
	data qlxcon(32) /'D'       /  qlxval(32) / "DD  "/
	data qlxcon(33) /'PP'      /  qlxval(33) / "PP  "/
	data qlxcon(34) /'CC'      /  qlxval(34) / "CC  "/
	data qlxcon(35) /'W'       /  qlxval(35) / "WW  "/
	data qlxcon(36) /'ES'      /  qlxval(36) / "ES  "/
	data qlxcon(37) /'EPAIS'   /  qlxval(37) / "DFGZ"/
	data qlxcon(38) /'MAC'     /  qlxval(38) / "DFST"/
	data qlxcon(39) /'PCP'     /  qlxval(39) / "DFPR"/
	data qlxcon(40) /'UV'      /  qlxval(40) / "UV  "/
	data qlxcon(41) /'VENT'    /  qlxval(41) / "VENT"/
	data qlxcon(42) /'NUAGES'  /  qlxval(42) / "NUAG"/
	data qlxcon(43) /'ECM'     /  qlxval(43) / "F2  "/
	data qlxcon(44) /'PNM'     /  qlxval(44) / "PN  "/
	data qlxcon(45) /'PSURF'   /  qlxval(45) / "P0"  /
	data qlxcon(46) /'TSRF'    /  qlxval(46) / "TS"  /
	data qlxcon(47) /'TMER'    /  qlxval(47) / "TM  "/
	data qlxcon(48) /'MT'      /  qlxval(48) / "MT  "/
	data qlxcon(49) /'VOISIN'  /  qlxval(49) /   100 /
	data qlxcon(50) /'LINEAIR' /  qlxval(50) /     1 /
	data qlxcon(51) /'CUBIQUE' /  qlxval(51) /     3 /
	data qlxcon(52) /'ABORT'   /  qlxval(52) /    13 /
	data qlxcon(53) /'MINIMUM' /  qlxval(53) /     5 /
	data qlxcon(54) /'MAXIMUM' /  qlxval(54) /     4 /
	data qlxcon(55) /'GEF'     /  qlxval(55) / gr_gem /
	data qlxcon(56) /'GEM'     /  qlxval(56) / gr_gef /
	data qlxcon(57) /'WAIT'    /  qlxval(57) /     0 /
	data qlxcon(58) /'GO'      /  qlxval(58) /     1 /
	data qlxcon(59) /'GRIB'    /  qlxval(59) / gr_grib/
	data qlxcon(60) /'FORMATEE'/  qlxval(60) /     5 /
	data qlxcon(61) /'STATIONS'/  qlxval(61) / gr_stations /
	data qlxcon(62) /'ADD'     /  qlxval(62) /     1 /
	data qlxcon(63) /'RESET'   /  qlxval(63) /     0 /
	data qlxcon(64) /'EST'     /  qlxval(64) /     3 /
	data qlxcon(65) /'OUEST'   /  qlxval(65) /     4 /
	data qlxcon(66) /'NONE'    /  qlxval(66) /     5 /
	data qlxcon(67) /'NOMVAR'  /  qlxval(67) /     1 /
	data qlxcon(68) /'TYPVAR'  /  qlxval(68) /     2 /
	data qlxcon(69) /'ETIKET'  /  qlxval(69) /     3 /
	data qlxcon(70) /'IP01'    /  qlxval(70) /     4 /
	data qlxcon(71) /'IP02'    /  qlxval(71) /     5 /
	data qlxcon(72) /'IP03'    /  qlxval(72) /     6 /
	data qlxcon(73) /'DATEO'   /  qlxval(73) /     7 /
	data qlxcon(74) /'DATEV'   /  qlxval(74) /     8 /
	data qlxcon(75) /'LAT'     /  qlxval(75) /    12 /
	data qlxcon(76) /'LON'     /  qlxval(76) /    13 /
	data qlxcon(77) /'NI'      /  qlxval(77) /     9 /
	data qlxcon(78) /'NJ'      /  qlxval(78) /    10 /
	data qlxcon(79) /'NK'      /  qlxval(79) /    11 /
	data qlxcon(80) /'WDUV'    /  qlxval(80) /"WDUV" /
	data qlxcon(81) /'ON'      /  qlxval(81) /     1 /
	data qlxcon(82) /'OFF'     /  qlxval(82) /     0 /
	data qlxcon(83) /'VERBOSE' /  qlxval(83) /     1 /
	data qlxcon(84) /'LECTURE' /  qlxval(84) /     1 /
	data qlxcon(85) /'ECRITURE'/  qlxval(85) /     2 /
	data qlxcon(86) /'SEQWPRM' /  qlxval(86) /     4 /
	data qlxcon(87) /'AUCUNE'  /  qlxval(87) /     0 /
	data qlxcon(88) /'COMME'   /  qlxval(88) / gr_comme /
	data qlxcon(89) /'LIKE'    /  qlxval(89) /    12 /
	data qlxcon(90) /'IP1A'    /  qlxval(90) / 65001 /
	data qlxcon(91) /'IP1B'    /  qlxval(91) / 65002 /
	data qlxcon(92) /'IP2A'    /  qlxval(92) / 65003 /
	data qlxcon(93) /'IP2B'    /  qlxval(93) / 65004 /
	data qlxcon(94) /'IP3A'    /  qlxval(94) / 65005 /
	data qlxcon(95) /'IP3B'    /  qlxval(95) / 65006 /
	data qlxcon(96) /'FENTREE' /  qlxval(96) /     1 /
	data qlxcon(97) /'FSORTIE' /  qlxval(97) /     2 /
	data qlxcon(98) /'LOCAL'   /  qlxval(98) /     1 /
	data qlxcon(99) /'IP1'     /  qlxval(99) /     4 /
	data qlxcon(100)/'IP3'     /  qlxval(100)/     6 /
	data qlxcon(101)/'STEREO'  /  qlxval(101)/ gr_stereo /
	data qlxcon(102)/'IPUN'    /  qlxval(102)/     4 /
	data qlxcon(103)/'IPDEUX'  /  qlxval(103)/     5 /
	data qlxcon(104)/'IPTROIS' /  qlxval(104)/     6 /
	data qlxcon(105)/'IPONE'   /  qlxval(105)/     4 /
	data qlxcon(106)/'IPTWO'   /  qlxval(106)/     5 /
	data qlxcon(107)/'IPTHREE' /  qlxval(107)/     6 /

	data(qlxlcon(i),i=1,2)/'OUI', 'NON'/
	data(qlxlval(i),i=1,2)/1,0/


* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*           listl=position  iment(tape1 standard),isll(tape4 sequentiel)
*                 ozsrt(tape2 - standard - seq file - random ms)
*           defo=liste des defauts pour iment,isll,ozsrt,i,l
*           lfn=liste que l usager propose pour remplacer
*           6=nombre de lfn
*           nequiv=nombre d'equivalence output de ccard
*
*
	nequiv=-1
	call ccard(listl,defo,lfn,49,nequiv)
	ier = fnom(5,lfn(43),'SEQ',0)
*	ier = fnom(6,lfn(44),'SEQ',0)
	
*
*          imprime boite debut du programme
*
	jdate= exdb(' PGSM  ',' V6.10.0',  lfn(45)) 

*
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
	
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	call qqqfilt(1,0,0,0)
	call qqqfilt(2,0,0,0)

	if (lfn(1).ne.'SCRAP'.and.lfn(47).ne.'SCRAP') then
	  print *,'***************************************************'
	  print *,'* ON NE PEUT MELANGER LES FICHIERS D ENTREE       *'
	  print *,'* SEQUENTIELS ET RANDOM                           *'
	  print *,'***************************************************'
	  jdate= exfin('  PGSM  ', 'ABORT', 'NON')
	  call qqexit(13)
	endif	
	
	if (lfn(47).ne.'SCRAP') then
	  inputmod = SEQUENTIEL
	else
	  inputmod = RANDOM
	endif
	
	if (lfn(48).ne.'SCRAP') then
	  ier = fnom(3,lfn(48),'RND+OLD+R/O',0)
	  ier = fstouv(3,'RND')
	endif
	
	if (lfn(49).ne.'NON') then
	  ier = ezsetopt('verbose', 'yes')
	endif
	
	
	if (inputmod.eq.RANDOM) then
	  niun = 1
 100	  if (lfn(niun) .ne.'SCRAP') then
	    niun = niun+1
	    goto 100
	  endif
	  
	  niun = niun - 1
	  if (niun .lt. 1) then
	    print *
	1	 ,'***************************************************'
	    print *, '* AUCUN FICHIER D''ENTREE DONNE EN ARGUMENT !!!'
	    print *
	1	 ,'***************************************************'
	    jdate= exfin('  PGSM  ', 'ABORT', 'NON')
	    call qqexit(13)
	  endif	
	  do i=1, niun
	    ier = fnom(lnkdiun(i),lfn(i),'RND+OLD+R/O',0)
	    if (ier .lt. 0) then	         
	      print *,'************************************************'
	      print *, '* PROBLEME D''OUVERTURE AVEC LE FICHIER ',lfn(i)
	      print *,'************************************************'
	      jdate= exfin('  PGSM  ', 'ABORT', 'NON')
	      call qqexit(13)
	    endif
	  enddo
	else
	  niun = 1
	  ier = fnom(lnkdiun(1),lfn(47),'STD+SEQ+OLD+R/O',0)
	  if (ier .lt. 0) then	         
	    print *,'************************************************'
	    print *, '* PROBLEME D''OUVERTURE AVEC LE FICHIER ',lfn(47)
	    print *,'************************************************'
	    jdate= exfin('  PGSM  ', 'ABORT', 'NON')
	    call qqexit(13)
	  endif
	endif
	
*
*
*
	mtype =   MTYP
	maxnoms = MAXNOM 
	
	call initseq
	
*       
*	
*  initialise les dictionnaires
*
	call qlxopt ('CARMOT', 4)
	call qlxinx (sorti,'SORTIE', nsort,0103,2)
*                        3 appels reconnus  1=sortie(std,noenrg) noenrg>=2
*                                           2=sortie(ms,noenrg,jwrit)
*                                           3=sortie(seq)
*
	
	call qlxinx (heure,'HEURE',nheure, 0140,2)
	call qlxinx (heure, 'IP2',nheure, 0140,2) 
*                     2 appels  1=heure(00,12,24,25.....max20) minimum 1
*                               2=champ(mac,00,06) minimum 2 pour
*                               2=champ(pcp,00,06) minimum 2 pour
*                               accumulateur d"ajustement ou precipitation
*
	call qlxinx (qqqintx,'SETINTX',nsetin, 0101,2) 
*
*                        appel - setintx(voisin) avec le plus proche
*                                setintx(lineair) interpolation lineaire
*                                setintx(cubique) interpolation cubique(defaut) 
*
	call qlxinx (setxtrap,'EXTRAP',nsetex, 0101,2) 
*
*                        appel - setintx(voisin) avec le plus proche
*                                setintx(lineair) interpolation lineaire
*                                setintx(cubique) interpolation cubique(defaut) 
*
	call qlxinx (champ,'CHAMP',nchamp, 0131,2)
*                     appel - champ(z,niveau)  niveau=1000,850,.......
*                           - champ(t,niveau)  niveau=1000,850,.......
*                           - champ(q,niveau)  niveau=1000,850,.......
*                           - champ(d,niveau)  niveau=1000,850,.......
*                           - champ(w,niveau)  niveau=1000,850,.......
*                           - champ(es,niveau)  niveau=1000,850,.......
*                           - champ(uv,niveau)  niveau=1000,850,.......
*                           - champ(uvs)  pas de niveau vent de surface
*                           - champs(ventuvs) voir directive paires(.....
*                           - champ(vent,niveau) niveau=1000,850,.......
*                           - champ(nuage)  nuage bas,moyen,haut
*                                   rec 1=bas  rec 2= moyen  rec 3=haut
*                           - champ(ecm)  epaisseur de la couche limite
*                           - champ(pnm)  pression au niveau de la mer
*                           - champ(psurf)  pression a la surface
*                           - champ(ts)  temperature a la surface
*                           - champ(epais,niveau1,niveau2) niveau2 - niveau1
*                           - champ(mac,heure1,heure2)  heure2 - heure1
*                           - champ(pcp,heure1,heure2)  heure2 - heure1
*
	call qlxinx (chmpdif,'CHMPDIF',npar,0508,2)
*
*                 appel - chmpdif (noment,nomsrt,ip1tab,ip2tab,ip3tab)
*                    ex:  chmpdif ("gz","dz",[1000,500],12,0)
*                         z500mb - z1000mb  a 12hr
*                         fichier de sorti aura ip1=1000, ip2=500,ip3=12
*                    ex:  chmpdif ("gz","dz",1000,[6,12,18,24],0)
*                         z1000mb 6hr - z1000mb  a 12hr
*                         fichier de sorti aura ip1=1000, ip2=6, ip3=12
*                    ex:  chmpdif ("gz","dz",1000,6,[1,2,3,4])
*                         z1000mb 6hr ip3=1 - z1000mb  6hr ip3=2
*                         fichier de sorti aura ip1=1000, ip2=1, ip3=2
*
	call qlxinx (champ_seq,'CHAMPSEQ',npar,0303,2)
*
*                 appel - champseq(['GZ','TT','UU'],[1000,850,500],WAIT)
*                 appel - champ_seq(' ',[1000,850,500],WAIT)
*                 appel - champ_seq(['GZ','TT','UU'],-1,GO)

	call qlxinx (convs, 'CONV',ncon, 0305,2)
*
*                 appel - conv(nom, ecart, facteur, bas, haut) directive
*                         conv("ts", -273.16, 1.0,-280.0, -250.0)
*                         routine conver dans ecriture soustrait
*                         273.16 au champ et multiplit par 1.0
*                         enleve toutes les valeurs plus petites que -280
*                         enleve toutes les valeurs plus grandes que -250
*                         avant d ecrire le champ 
	call qlxinx (grille2,'GRILLE',  ngr, 0109,2)
*          8 appels a grille    1=grille(std,nni,nnj,lg1)
*                                 std=standard lat lon
*                                 nni=nombre de pts est-ouest
*                                 nnj=nombre de pts nord-sud
*                                 lg1=0  global
*                                    =1  hem nord 
*                                    =2  hem sud
*                               2=grille(latlon,nni,nnj,lat0,lon0,dlat,dlon)
*                                 latlon=grille lat lon
*                                 nni= nombre de pts est-ouest
*                                 nnj= nombre de pts nord-sud
*                                 lat0=premiere lat du coin degree
*                                 lon0=premiere lon du coin degree
*                                 dlat=espacement entre latitude  (degree)
*                                 dlon=espacement entre longitude (degree)
*
*                               3=grille(ps,nni,nnj,pi,pj,d60,dgrw)
*                                 ps  =polaire stereographique
*                                 nni =nombre pts est-ouest (dir i)
*                                 nnj =nombre de pts nord-sud (dir j) 
*                                 pi  =position du pole nord(pi=26)
*                                 pj  = position du pole nord(pj=28)
*                                 d60 =distance en metres entre les pts
*                                      a 60 degrees nord (latitude)
*                                 drgw=angle entre l"axe x et greewich
*
*                               4=grille(tape4,nni,nnj,ip1,ip2,ip3)
*                                 tape4=fichier contenant nni*nnj(lat-lon)
*                                 nni  =nombre de pts est-ouest
*                                 nnj  =nombre de pts nord-sud
*                                 ip1  =definit par usager
*                                 ip2  =definit par usager
*                                 ip3  =definit par usager
*
*                               5=grille(stdb,nni,nnj,hem)
*                                 stdb=standard b 
*                                 nni  =nombre de pts est-ouest
*                                 nnj  =nombre de pts nord-sud
*                                 hem  =hemisphere 0=global 
*                                                  1=nord
*                                                  2=sud
*
*                               6=grille(gauss,nni,nnj,hem) 
*                                 gauss=grille gaussienne lat-lon
*                                 nni  =nombre de pts est-ouest
*                                 nnj  =nombre de pts nord-sud
*                                 hem  =hemisphere 0=global 
*                                                  1=nord
*                                                  2=sud
*
*                               7=grille(tape1,ip1,ip2,ip3,ip4,nord/sud)
*                                 tape1=lit sur fichier 1 lat-lon ou xy
*                                 ip1=valeur 0-32767
*                                 ip2=valeur 0-32767
*                                 ip3=valeur 0-4095
*                                 ip4=valeur "xydir" ou "llist"
*                                    =valeur "lldir" ou "xylis"
*
*                               8=grille(tape2,ip1,ip2,ip3,ip4,nord/sud)
*                                 tape2 lit sur fichier 2 lat-lon ou xy
*                                 ip1=valeur 0-32767
*                                 ip2=valeur 0-32767
*                                 ip3=valeur 0-4095
*                                 ip4=valeur "xydir" ou "llist"
*                                    =valeur "lldir" ou "xylis"
*
	call qlxinx (lrsmde,'LIRMODE',nlirmde,0708,2) 
	call qlxinx (lrsmds,'LIRMODS',nlirmds,0708,2) 
*
*                  lrsmde(nomvar,typvar,date,niveau,heure,ip3,etiquet)
*                  lrsmds(nomvar,typvar,date,niveau,heure,ip3,etiquet)
*
	call qlxinx (metsym,'METSYM',  nsym, 0202,2) 

*                               metsym(z,oui)
*                               z  =geopotentiel "gz"
*                               oui=symetrique
*
	call qlxinx (outlalo,'OUTLALO', nlalo, 0108,2)
*     outlalo(ip1,ip2,ip3,nomlat,nomlon,grtyp,etiklat,etiklon)
*             ip1=valeur 0-32767
*             ip2=valeur 0-32767
*             ip3=valeur 0-4095
*             nomlat=nom du champ de latitude 2 car
*             nomlon=nom du champ de longitude 2 car
*             grtyp=type de grille
*             etiklat=nom de l'etiquette latitude 
*             etiklon=nom de l'etiquette longitude
*
	call qlxinx (pairvct, "PAIRES",npairuv, 0305,2)
*      ex: paires("uv","uu","vv",0) vecteur "uu","vv" geographique
*                                     niveau donne par champ
*      ex: paires("ventuvs","us","vs","uv") vitesse du vent a la surface
*      ex: paires("uvs","us","vs",0) vecteurs du vent a la surface
*
   	call qlxinx (pgcoupe,'MOYENT', nmoy, 0232,2)
   	call qlxinx (moysrt,'MOYSRT', nmoy, 0232,2)
   	call qlxinx (liren,'LIREE', nlire, 0708,2)
	call qlxinx (lirsr,'LIRES', nlire, 0708,2)
	call qlxinx(plmnmod,'PLUSE', najou, 0707,2)
	call qlxinx (pluss,'PLUSS', najou, 0707,2) 
	call qlxinx (foise,'FOISE', multp, 0707,2) 
	call qlxinx (foiss,'FOISS', multp, 0707,2) 
	call qlxinx (divisee,'DIVE', multp, 0707,2) 
	call qlxinx (divises,'DIVS', multp, 0707,2) 
	call qlxinx (moinse,'MOINSE', nenle, 0707,2)
	call qlxinx (moinss,'MOINSS', nenle, 0707,2)
	call qlxinx (moyene,'MOYENE', nmoys, 0101,2)
   	call qlxinx (ecrits,'ECRITS',  necrt, 0814,2)  
   	call qlxinx (modul2e,'MODUL2E', nmod, 0707,2) 
   	call qlxinx (modul2s,'MODUL2S', nmod, 0707,2)
   	call qlxinx (racine,'RACINE', nraci, 0101,2)  
   	call qlxinx (operat, 'PFOIS', npfo, 0303,2) 
   	call qlxinx (expon, 'EXPON', npex, 0101,2) 
   	call qlxinx (alogn, 'ALOGN', npex, 0101,2)
*
	call qlxinx (qqqecho, 'ECHO',   dum, 0101, 2)
	call qlxinx (qqqident,'IDENT',  npar, 0103, 2)
	call qlxinx (qqqform, 'FORMAT', dum, 0101, 2)
	call qlxinx (coord,   'COORD',  dum, 0202, 2)
	call qlxinx (qqqfilt, 'FILTRE', dum, 0204, 2)
*
  	call qlxins (npack,  'COMPAC',  dum, 1, 1)
	call qlxins (message,'MESSAGE', dum, 1, 1)
	call qlxins (numdel, 'DELTA',   dum, 1, 1) 
	call qlxins (typeent,'TYPEENT', dum, 1, 1)
	call qlxins (typesrt,'TYPESRT', dum, 1, 1)
	call qlxins ( voire, 'VOIRENT', dum, 1, 1) 
	call qlxins ( voirs, 'VOIRSRT', dum, 1, 1) 
        call qlxINS ( pose,  'PAUSE',   dum, 1, 1) 
	call qlxins ( date,  'DATE',    dum, 3, 1)
	call qlxins (seldat, 'OPDAT',   dum, 1, 1)
	call qlxins (printen,'PRINTEN', dum,7, 1) 
	call qlxins (printsr,'PRINTSR', dum,7, 1)
	call qlxins (etikent,'ETIKENT', nwetike, 3, 1)
	call qlxins (etiksrt,'ETIKSRT', nwetiks, 3, 1)
	call qlxins (numero, 'ENREG',   dum, 1, 1) 
	call qlxins (ip2srt, 'IP2SRT',  dum, 1, 1) 
	call qlxins (ip3ent, 'IP3ENT',  dum, 1, 1)
	call qlxins (ip3srt, 'IP3SRT',  dum, 1, 1) 
	call qlxins (unefois,'UNEFOIS',  dum, 1, 1) 
	call qlxins (once,   'ONCE',  dum, 1, 1) 
	call qlxins (diese,  'DIESE',dum,1,1)
		
	do i=1,107
	   call qlxins(qlxval(i), qlxcon(i), dum, 1, 0)
	enddo      
	
	do i=1,2
	   call qlxins(qlxlval(i), qlxlcon(i), dum, 1, 0)  
	enddo    
*
*   defaut pour lire fichier d'entre
*
	typeent = -1
	etikent(1) = -1
	etikent(2) = -1
	
	ip3ent = -1
	date  = -1
	date2 = -1
	date3 = -1

	diese = 1
*
*   defaut pour fichier de sorti
*
	ip3srt= -1
	ip2srt=-1
	etiksrt(1) = -1
	etiksrt(2) = -1 
	etiksrt(3) = -1 
	
	typesrt= -1
*
*
*    initialiser avec .true. champ symetrique
*
	nsym = 2
	call cmetsym('GZ',.true.)
	call cmetsym('TT',.true.)
	call cmetsym('DD',.true.)
	call cmetsym('WW',.true.)
	call cmetsym('ES',.true.)
	call cmetsym('F2',.true.)
	call cmetsym('PN',.true.)
	call cmetsym('PS',.true.)
	call cmetsym('TS',.true.)
*
	call cmetsym('QQ',.false.)
*
*
*    directives de l'usager
*
	
*
*    initialisation parametres de sortie pour fichier formate

	call initid

	
	iopc= fstopc('MSGLVL',lfn(46),.false.)
	ipose= 0
	call readlx(5,kend,ipose)
*
*   initialise variable de printsr
*
	if (tmplatp .ne. 0) call hpdeallc(tmplatp,ier,1)
	if (tmplonp .ne. 0) call hpdeallc(tmplonp,ier,1)
	
	call chk_hy(1,2)
	iopc= fstopc('MSGLVL','INFORMS',.false.)
	do i=1,niun
	   ier = fstfrm(lnkdiun(i))
	   call fclos(lnkdiun(i)) 
	enddo
c	call fstunl
	
	if (mode.eq.1) then 
	   if (voirs)  then
	      if (message) then
	         ier = fstvoi(2, 'RND')
	      endif
	   endif




	   ier = fstfrm(2)
	   call fclos(2) 
	else
#if defined (unix)
         if (mode.eq.2) then
	      write (6, *) 
     $      'LES FICHIERS DE TYPE "MS" NE SONT PAS SUPPORTES'
	      write (6, *) 'DANS CETTE VERSION DE PGSM'
	   endif
#endif
*
*    fermer fichier sequentiel
*
     	   if (mode.eq.3)  then
	      call fclos(2) 
	   endif

     	   if (mode.eq.4)  then
	      call pgsmcf(2) 
	   endif
	endif
*
*
*
*  fermer fichier 4 dans grille
*
*
*  imprime boite avec le temps d execution du pgm  pgsm
*
	if (ipose.gt.0) then
	   jdate= exfin('  PGSM  ', 'ABORT', 'NON')
	   call qqexit(13)
	else
	   jdate= exfin('  PGSM  ', 'OK', 'NON')
	endif
*
*	 stop
	 end
      subroutine qqqform(theform)
#include "impnone.cdk"

      integer theform(4)
#include "idents.cdk"
      external argdims
      integer argdims

      integer i,j,longueur

      character*80 chaine

      longueur = argdims(1)

      qcform(1:16) = ' '

      do i=1,longueur
         j = 4*(i-1)+1
         write(qcform(j:j+3),'(a4)') theform(i)
      enddo
      
      return
      end
*     
***   s/p coupzm  coupe zonale ou meridionale d un champ
*     
#include "defin.cdk"
      subroutine coupzm(iunit, cnom, cjcoup)
#include "impnone.cdk"
      external calcul,ecritur,gauss,fstinf,pgsmlir,memoir,fstprm,fstcvt,
     $         pgsmabt,imprime,loupmir,louptra,loupin1,fstopc,messags
      integer  fstinf,pgsmlir,fstprm,fstopc,fstcvt
*     
*auteur  p. sarrazin  dorval quebec avril 85 drpn 
*
*revision 
*     4.0.2 - conversion en caracteres de toutes les variables
*             de type hollerith
*             y. chartier- dorval quebec juillet 90 drpn.
*
*langage ratfor
*
*objet(coupzm)
*            faire une coupe zonale ou meridionale sur un champ dont
*            le type de grille est "g"-"a"-"l"-"b"-"c"
*            calcul pour une coupe meridionale sur un champ gaussien
*            "g" est fait a partir de poids calcule par gaussg
*            la moyenne zonale(est-ouest) contient nj points
*            la moyenne meridionale(nord-sud) contient ni points
*
*librairies
*         - source pgsm/un=armnsrc
*         -  objet pgsmlib,id=armnpjs sur xmp
*
*arguments
*  in   iunit  numero du fichier a lire 
*  in   cnom    nom du champ 2 caracteres gz.tt.dd.......
*  in   cjcoup  coupe zonale='zon' meridionale='mer'
*
*appel
*         -via routine coupe
*         call coupzm(iunit, cnom, cjcoup)
*
*messages 
*          record n'existe pas verifier directive moyent/moysrt
*          iunit=  niveaux=   heure=   nom=
*          mauvais type de grille directive moyent/moysrt
*          grtyp=
*          doit-etre "g"-"a"-"l"-"c"-"b"
*
*modules pgsmabt,rfl,fstinf,fstprm,pgsmlir,ecritur
*
*-----------------------------------------------------------------
*
#include "llccmm.cdk"

#include "dates.cdk"
*
*
#include "grilles.cdk"
*
*
#include "indptr.cdk"
*
*
#include "lires.cdk"
*
*
#include "accum.cdk"
*
*
#include "voir.cdk"
*
*
#include "ecrires.cdk"
*
*
#include "packin.cdk"
*
*
#include "param.cdk"
*
*
#include "heures.cdk"
*
*
#include "nivos.cdk"
*
*
#include "cfldinf.cdk"
*
*
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*
      character cnom*3, cjcoup*8
      real coa(500),w(500),sia(500),rad(500),poids(500),sinm2(500),
     $     sinm1(500),sin2(500),champ(1000)
      integer i, iunit
      integer ihr,iheur,iprs,npres,irec,ni,nj,nk 
      integer jp1,jp2,jp3,ig1,ig2,ig3,ig4
      integer num,ilath,j,cnbits,cdatyp,iopc,
     $     cswa, clng, cdltf, cubc, extra1, extra2, extra3
      character*8 cdummy
      integer      dummy
      
      cnomvar = cnom
*     
*     
*     loop des heures
*     
      do ihr=1,nhur
         iheur=heures(ihr)
      enddo
*     
      npres=max0(1,nmo-2)
      do iprs = 1,npres
*     
*     identifier numero du record 
*     
         if (date .eq. 1) then
            if (date3.eq.-1) then
               date=date2
            else
               call newdate(date, date2, date3, 3)
            endif
         endif

*     
*     modification de hollerith a caractere
*     
         
         if (etikent(1) .ne. -1) then
            write(cetiket,'(2A4)') (etikent(i), i=1,nwetike)
         else 
            cetiket = '        '
         endif
         
         if (typeent .ne. -1) then
            write(ctypvar, '(A1)') typeent
         else 
            ctypvar = ' '
         endif
         
         cigtyp = ' '
         irec = fstinf(iunit,ni,nj,nk,date,cetiket,nivospr(iprs), 
     $        iheur,ip3ent,ctypvar,cnomvar)
*
         if (irec .lt. 0) then
            write(6,*)
     $           'RECORD N EXISTE PAS VERIFIER DIRECTIVE MOYENT/MOYSRT'
            write(6,*)
     $           ' IUNIT=',iunit,' NIVEAU=',nivospr(iprs),
     $           ' HEURE=',iheur
            write(6,600) cnom
            return
         endif
  
         if (nk.gt.1) then
            write(6,*)'**********************************************'
            write(6,*)'         PGSM N ACCEPTE PAS UN          '
            write(6,*)' CHAMP DE 3 DIMENSIONS NK>1 ?? (MOYENT-MOYSRT)'
            write(6,*)'***********************************************'
            call pgsmabt
         endif
*
*     
*     identifier parametres si type g-a-b-l-c
*     
*     
         ier = fstprm( irec, dat,deet,npas,ni, nj, nk, cnbits,cdatyp,
     $        jp1,jp2, jp3,ctypvar,cnomvar,cetiket,cigtyp, 
     $        ig1,ig2,ig3,ig4, 
     $        cswa, clng, cdltf, cubc, extra1, extra2, extra3)
         if (ier .lt. 0) then
            write(6,*)' IER = FSTPRM NEGATIF VOIR CHMPDIF'
         endif
*
*     verifier si grille gaussienne ni doit etre pair
*     
         if (cigtyp.eq.'G'.and.mod(ni,2).ne.0)  then
            call messags(ni)
         endif
*     
*     
*     nombre de longitude max=1000
*     
         if (ni.gt.1000) then
            write(6,*)'  TROP DE LONGITUDES CHANGER DIMENSION DANS'
            write(6,*)' COUPZM CHAMP'
            call pgsmabt
         endif
*
*     verifier si dimension nj .gt. 500
*     
         if (ig1.eq.0.and.nj.gt.500) then
            write(6,*)' CHAMP D ENTRE GLOBALE POUR MOYENT-MOYSRT'
            write(6,*)' DIMENSION NJ .GT.500 STOP'
            write(6,*)' MODIFIER ROUTINE COUPZM DANS PGSM'
            call pgsmabt
         endif
*     
*     verifier type de grille
*     
         if (cigtyp.ne.'G'.and.cigtyp.ne.'A'.and.cigtyp.ne.'L'
     $        .and.cigtyp.ne.'B'.and.cigtyp.ne.'C') then
            write(6,*)' MAUVAIS TYPE DE GRILLE DIRECTIVE MOYENT/MOYSRT'
            write(6,601) cigtyp
            write(6,*)' DOIT-ETRE G - L - B - A - C  (MOYENT/MOYSRT) ' 
            return
         endif
*
*     lire champ
*     
         call hpalloc(tmpif1p,ni*nj,ier,1 )
*     
         if (.not.message) then
            iopc= fstopc('TOLRNC','DEBUGS',.true.) 
         endif
         if (date .eq. 1) then
            if (date3.eq.-1) then
               date=date2
            else
               call newdate(date, date2, date3, 3)
            endif
         endif
*
         num=pgsmlir(tmpif1,iunit,ni,nj,nk,date,cetiket,jp1,jp2,
     $        jp3,ctypvar,cnomvar,cigtyp)
  
        if (printen)  then
           call imprime(cnom,tmpif1,ni,nj)
        endif
        if (num .lt. 0)  then
           write(6,*)' CHAMP N EXISTE PAS LIRE DANS MOYENT/MOYSRT'
           call pgsmabt
        endif
*
*     initialiser les poids pour grille gaussienne meridionale
*     
        if (cjcoup.eq.'MER'.and.cigtyp.eq.'G') then
           ilath=nj
           if (ig1.eq.0) then
              ilath=nj/2
           endif
*     
           call gauss(ilath,coa,poids,sia,rad,w,sinm1,sinm2,sin2)
*     
*     sauve les poids dans coa pour renverser le champ si necessaire
*     
           do j=1,ilath
              coa(j)=poids(j)
           enddo
*
*     si gaussienne globale  transfer hemis nord dans hemis sud (miroir)
*     
           if (ig1.eq.0)  then
              call loupmir(poids(ilath),poids(ilath),ilath)
           endif
*     
*  hemisphere sud  orientation nord-sud renverse
*
           if ((ig1.eq.2.and.ig2.eq.1) .or.(ig1.eq.1.and.ig2.eq.0))then
              call louptra(poids(ilath),coa,ilath) 
           else
              call loupin1(poids(1),poids(1),nj)
           endif
        endif
*     calcul moyenne zonale ou meridional 
*     
*     
        call calcul(tmpif1,champ,ni,nj,poids,cjcoup,cigtyp)
*     
*     si type de grille 'b' on reduit ni=ni-1
*     
        if (cigtyp.eq.'B') then
           ni=ni-1
        endif
*     
*     ecrit champ zonal 
*     
        if (cjcoup.eq.'ZON') then
           call ecritur(champ,npack,dat,deet,npas,1,nj,1,jp1,jp2,
     $          jp3,ctypvar,cnomvar,cetiket,cigtyp,ig1,ig2,ig3,ig4)
*     
*     ecrit champ  meridional
*     
        else
           call ecritur(champ,npack,dat,deet,npas,ni,1,1,jp1,jp2,
     $          jp3,ctypvar,cnomvar,cetiket,cigtyp,ig1,ig2,ig3,ig4)
        endif
        call hpdeallc(tmpif1p,ier,1)
      enddo
      
*     
 600  format(' NOM= ',a2)
 601  format(' IGTYP= ',a1)
*     
      return 
      end
      
*     
***S/P GRILTP4   LIRE LAT LONG DE CHAQUE PT D'UNE GRILLE TYPE "X" OU "Y"
*
      subroutine griltp4(nni,nnj,ip1,ip2,ip3)
#include "impnone.cdk"
*
*AUTEUR   - P. SARRAZIN JANVIER 87 DRPN DORVAL P.Q. CANADA
*
*LANGAGE - RATFOR
*
*OBJET(GRILTP4)
*          LIRE LA LATITUDE ET LA LONGITUDE DE TOUS LES POINTS
*          DE LA GRILLE DE SORTIE TAPE4 LAT LON ET ECRIRE LES DEUX
*          RECORDS LAT LONG SUR FICHIER STANDARD TYPE "X" SI
*          IP1,IP2,IP3 SONT DEFINIS TYPE "Y" ET SERONT TRANSFERRE DANS
*          IG1,IG2,IG3   IG4=0
*
*
*LIBRAIRIES
*         -SOURCE  ARMNSRC,DRPN
*         -OBJET   PGSMLIB,ID=ARMNPJS.
*
*------------------------------------------------------
      integer nni,nnj,ip1,ip2,ip3
      write(6,*) 
     $'CE TYPE DE GRILLE N EST PAS SUPPORTE DANS CETTE VERSION DE PGSM'
      call pgsmabt
      return
      end
      subroutine liraxez(iun, ni, nj, nk, ig1, ig2, ig3, ig4)
#include "impnone.cdk"

      integer iun, ni, nj, nk, ig1, ig2, ig3, ig4
      
#include "gdz.cdk"
      
      data niz, njz, nkz 	/0, 0, 0/
      data iaxex, iaxey  	/0, 0 /
      data ig1ref, ig2ref, ig3ref, ig4ref /-1, -1, -1, -1/
      data ig1z,   ig2z,   ig3z,   ig4z   /-1, -1, -1, -1/
      data grref          /'Z'/
      
      integer  fstinf, fstprm, fstluk
      external fstinf, fstprm, fstluk, memoirh, pgsmabt,messags
      
      character *12 citiky,citikx
      character *4 cnmvar1,cnmvar2
      character *2 ctpvry,ctpvrx
      character *1 cgtypx,cgtypy
      
      integer irecy,irecx
      integer idatt,idett,npas,niy,njy,nky,jjp1,jjp2,jjp3
      integer ig1y,ig2y,ig3y,ig4y,nix,njx,nkx
      integer ig1x,ig2x,ig3x,ig4x
      integer numy,numx,ier,iopc
      integer cnbits,cdatyp,extra3,extra2,extra1,cubc,cdltf,clng,cswa
*     
      
      
      if (ni.eq.niz.and.nj.eq.njz.and.nk.eq.nkz.and.ig1.eq.ig1z.and.
     $     ig2.eq.ig2z.and.ig3.eq.ig3z.and.ig4.eq.ig4z) then
         return
      endif

      if (iaxex .ne. 0) then
         call memoirh(axex, iaxex, 0)
         iaxex = 0
      endif
      
      if (iaxey .ne. 0) then
         call memoirh(axey, iaxey, 0)
         iaxey = 0
      endif

      irecx = fstinf(iun, nix, njx, nkx, -1,' ', 
     $     ig1, ig2, ig3,' ','>>')
      irecy = fstinf(iun, niy, njy, nky, -1,' ', 
     $     ig1 ,ig2, ig3,' ','^^')
      
      if (irecy .lt. 0 .or.irecx .lt. 0) then
         print *, 
     $        'FSTINF ROUTINE LIRAXEZ RECORD ^^ OU >> MANQUANT...'
         call pgsmabt
      endif
*     
      if (nky .gt. 1) then
         write(6,*)'************************************************'
         write(6,*)'         PGSM N''ACCEPTE PAS UN          '
         write(6,*)' CHAMP DE 3 DIMENSIONS NK>1 (RECORD ^^ OU >>)'
         write(6,*)'************************************************'
         call pgsmabt
      endif
      
      ier = fstprm(irecy,idatt,idett,npas,niy,njy,nky, cnbits,cdatyp,
     $     jjp1,jjp2,jjp3,ctpvry,cnmvar1,citiky,cgtypy,
     $     ig1y,ig2y,ig3y,ig4y, cswa, clng, cdltf, cubc,
     $     extra1, extra2, extra3)
      if (ier .lt. 0) write(6,*)' IER = FSTPRM NEGATIF VOIR LIRAXEZ'
*     
*     verifier si grille gaussienne ni doit etre pair
*     
      if (cgtypy.eq.'G'.and.mod(niy,2).ne.0)  call messags(niy)
*     
      ier = fstprm(irecx,idatt,idett,npas,nix,njx,nkx, cnbits,cdatyp,
     $     jjp1,jjp2,jjp3,ctpvrx,cnmvar2,citikx,cgtypx,
     $     ig1x,ig2x,ig3x,ig4x, cswa, clng, cdltf, cubc,
     $     extra1, extra2, extra3)
      
      
      if (ier .lt. 0) write(6,*)' IER = FSTPRM NEGATIF VOIR LIRAXEZ'
*     
*     verifier si grille gaussienne ni doit etre pair
*     
      if (cgtypx.eq.'G'.and.mod(nix,2).ne.0)  call messags(nix)
*     
*     
      if (cgtypy.ne.cgtypx .or. ig1y.ne.ig1x .or. ig2y.ne.ig2x .or. 
     $     ig3y.ne.ig3x .or. ig4y .ne.ig4x) then
         write(6,*)' VERIFIER RECORD "^^" OU ">>" '
         write(6,*)' GRTYP,IG1,IG2,IG3,IG4 SONT DIFFERENTS'
         call pgsmabt
      endif
      
*     lecture des axes
      
      call memoirh(axex, iaxex, nix)
      call memoirh(axey, iaxey, njy)
      
      ier = fstluk(axex(iaxex), irecx, nix, njx, nkx)
      if (ier .lt. 0) then
         print *, 'PROBLEME LECTURE ENREGISTREMENT >> '
         stop
      endif
      
      ier = fstluk(axey(iaxey), irecy, niy, njy, nky)
      if (ier .lt. 0) then
         print *, 'PROBLEME LECTURE ENREGISTREMENT ^^ '
         stop
      endif
      
      niz = nix
      njz = njy
      nkz = nkx
      
      ig1z = ig1
      ig2z = ig2
      ig3z = ig3
      ig4z = ig4
      
      grref = cgtypx
      ig1ref = ig1x
      ig2ref = ig2x
      ig3ref = ig3x
      ig4ref = ig4x
      
      return 
      end
      
***s/p pgsmabt  sortie pas trop brutale en cas d'erreur
*
      subroutine pgsmabt
#include "impnone.cdk"
      external abort,fclos,fstfrm,messags,exfin
      integer exfin,fstfrm
*
*auteur   p. sarrazin  rpn mars 1983
*
*langage  ratfor
*
*objet(pgsmabt)
*         faire une sortie sans dommage pour les fichiers
*         ouverts en cas d'erreur fatale dans pgsm
*
#include "indptr.cdk"
*
      integer ier
      jdate= exfin('  PGSM  ', 'ABORT' , 'NON')
*     
      ier = fstfrm(1) 
      if (mode.eq.1)ier = fstfrm(2)
#if defined (SGI) || defined (NEC)
      if (mode.eq.2) then
         write(6,*)' LES FICHIERS "MS" NE SONT PAS SUPPORTES DANS CETTE'
         write(6,*)' VERSION DE PGSM' 
      endif
#endif
      call qqexit(13)
      
      end
      
#include "defin.cdk"
      subroutine qqqident(position, separateur, items)
#include "impnone.cdk"

      integer position, separateur, items(16)

      integer argdims
      external argdims

#include "champs.cdk"
#include "idents.cdk"

      integer i

c      print *, 'qqqident', position, separateur
c      do i=1,16
c        print *, i, items(i)
c      enddo

      qposition = position
      if (qposition.eq.5) then
         qnitems = 0
      endif

      if (separateur.eq.-1) then
         qcsepar = 'T'
      else
         write(qcsepar,'(a1)') separateur
      endif
      
      do i=1,16
         qitems(i) = 0
      enddo

      if (-1.eq.items(1)) then
         qnitems = 11
         do i=1,qnitems
            qitems(i) = i
         enddo
      else
         do i=1,argdims(3)
            qitems(i) = items(i)
         enddo
      endif
      
      return
      end
