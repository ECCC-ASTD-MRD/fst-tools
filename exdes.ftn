*** S/R EXDES DECODE LA DATE, LES IP1, IP2 ET IP3 DE LA CARTE
*             DESIRE/EXCLURE
*
      SUBROUTINE EXDES(CLE, N, M)
  
      IMPLICIT NONE 
  
      INTEGER    CLE(10), N, M
  
*ARGUMENTS
* ENTRE   CLE  -  ARGUMENTS DE L'APPEL A DESIRE (IP1,IP2,IP3,DATE)
*   "     N    -  DIMENSION DE CLE
*   "     M    -  PARAMETRE A DECODER 1=IP1 2=IP2 3=IP3 4=DATE
  
*AUTEURs
*VERSION ORIGINALE  - Y. BOURASSA SEP 90
*REVISION 001         "     "     OCT 90 VERSION QLXINS
*         002         "     "     MAR 92 BUG DANS REQUETE AVEC SAUT
*                                        MAX MIN DIFF. POUR DATE IP1-2-3
*         003         "     "     AVR 92 TEST SUR DATE JULIENNE
*         004         "     "            ALLOUE RANGE INVERSE 
*         005         "     "     MAI 95 ENLEVVE REFERENCES A 1950
*         006         M. Lepine   Mar 98 Traitement des dates > 2000
*         007         M. Lepine   Sep 98 Bug fix stamp limite superieure
*         008         M. Lepine - Mai 02 Code de traitement des IP1 en valeurs reelle
*         009         M. Lepine - Nov 05 Remplacement de fstabt par qqexit
*     LANGUAGE FTN77
*
*MODULES
      EXTERNAL JULSEC, qqexit
*
**
#include "maxprms.cdk"
#include "desrs.cdk"
#include "fiches.cdk"
  
      INTEGER  I, J, BOT(4), TOP(4), temp, deltas, kind, p_int
      integer *8 J8, CLE8(10), kind_8, p_int8, ior
      intrinsic ior
      Real    p
      equivalence (p_int,p)
      CHARACTER *128 string
      EXTERNAL convip
      SAVE     BOT, TOP
*     LIMITE INFERIEURE = 0 POUR IP1-2-3 & JAN 01 1900 00Z POUR DATE
      DATA     BOT/0,0,0,010100000/
*     LIMITE SUPERIEURE POUR IP1-2-3     & JAN 01 2219 00Z POUR DATE
      DATA     TOP/32767, 32767, 4095, 2008728800/

      p_int8 = Z'80000000'
      kind_8 = 31
      top(1) = ior (p_int8, ishft(kind_8,32))   ! valeur maximale pour IP1 encode

      IF (M .EQ. 4) THEN
         DELTAS = 3600   ! Facteur multiplicatif pour passage en secondes
      ELSE
         DELTAS = 1
      ENDIF
*
      DO i = 1,N
         IF ((M .eq. 1) .and. (cle(i) .ne. -2) .and. (cle(i) .ne. -3)) then 
  ! convertir IP1 en Kind et Level dans un integer*8
             CALL convip(cle(i),p,kind,-1,string,.false.)
C             print *,'Debug+ i=',i,' cle(i)=',cle(i),' p=',p
             p_int8 = Z'80000000'
             if (p .lt. 0) then
                p = abs(p)
                p_int8 = p_int8 - p_int
             else
                p_int8 = p_int8 + P_int
             endif
             kind_8 = kind
             CLE8(i) = ior (p_int8, ishft(kind_8,32))
C      write(*,777) cle(i),kind,p,cle8(i)
 777  format('Debug+ cle(i)=',i10,' kind=',i2,' p =',e10.4,' cle8(i) =',z16.16)
         ELSE
            CLE8(i) = CLE(i)
         ENDIF
      ENDDO
*     FAUT-IL PRENDRE LA DATE DE LA PERIODE?
      IF(M.EQ.4 .AND. CLE8(1).EQ.-4) THEN
         IF(JOURS(4) .EQ. 0) THEN
            WRITE(6,*)' PAS RENCONTRE DE DIRECTIVE PERIODE' 
            call qqexit(20)
         ELSE
            REQ(11,M,NREQ) = JOURS(4)
            DO 10 I=1,3
               REQ(I,M,NREQ) = JOURS(I) 
   10          CONTINUE
            RETURN
         ENDIF
      ENDIF
  
      IF(N.EQ.1 .OR. ((CLE8(1).NE.-2).AND.(CLE8(2).NE.-2))) THEN
*        REQUETE = LISTE SE NOMBRES
         REQ(11,M,NREQ) = N
         DO 20 J=1,N
            REQ(J,M,NREQ) = CLE8(J)
   20       CONTINUE
      ELSE
         REQ( 1,M,NREQ) = BOT(M)
         REQ( 2,M,NREQ) = TOP(M)
         if (M .eq. 1) REQ(2,M,NREQ) = ishft(32,32)    ! plus gros entier selon Kind du IP1 
         REQ( 3,M,NREQ) = 1
         REQ(11,M,NREQ) = -1
         IF(CLE8(1) .EQ. -2 ) THEN
*           CHANGE REQUETE DE TYPE [@,-----] 
            REQ(2,M,NREQ) = CLE8(2)
            IF(N .EQ. 3) THEN
*              CHANGE REQUETE DE TYPE [@,-----,-- ]
               REQ(3,M,NREQ) = CLE8(3)
            ELSEIF(N .EQ. 4) THEN
*              CHANGE REQUETE DE TYPE [@,-----,DELTA,--]
               REQ(3,M,NREQ) = CLE8(4) * DELTAS
            ENDIF
         ELSE
*           CHANGE REQUETE DE TYPE [-----,@]
            REQ(1,M,NREQ) = CLE8(1)
            IF(N.GT.2 .AND. CLE8(3).NE.-3) THEN
*              CHANGE REQUETE DE TYPE [-----,@,-----]
               REQ(2,M,NREQ) = CLE8(3)
            ENDIF
            IF(N. GT. 3) THEN
               IF(CLE8(3) .EQ. -3) THEN
*                 CHANGE REQUETE DE TYPE [-----,@,DELTA,--]
                  REQ(3,M,NREQ) = CLE8(4) * DELTAS
               ELSEIF(N .EQ. 4) THEN
*                 CHANGE REQUETE DE TYPE [-----,@,-----,--]
                  REQ(3,M,NREQ) = CLE8(4)
               ELSE
*                 CHANGE REQUETE DE TYPE [-----,@,-----,DELTA,--]
                  REQ(3,M,NREQ) = CLE8(5) * DELTAS
               ENDIF
            ENDIF
         ENDIF  
         if ((m .eq. 1) .and. (req(3,M,NREQ) .ne. 1)) then
            print *,'*** Editfst: ERREUR dans les directives'
            print *,'*** Requete avec Delta non supporte avec variable IP1'
            print *,'*** Veuillez utiliser une version anterieure a V5.85'
            stop
         endif
      ENDIF
  
      IF(M .EQ. 4) THEN
         I = REQ(11,M,NREQ)
         IF(I .EQ. -1) I=2
         DO 40 J=1,I
            temp = REQ(J,M,NREQ)
            CALL JULSEC(REQ(J,M,NREQ), temp)
   40       CONTINUE
      ENDIF

      IF(REQ(11,M,NREQ) .EQ. -1) THEN
         J8 = MAX(REQ(1,M,NREQ), REQ(2,M,NREQ))
         REQ(1,M,NREQ) = MIN(REQ(1,M,NREQ), REQ(2,M,NREQ))
         REQ(2,M,NREQ) = J8
      ENDIF
  
      RETURN
      END 
